<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Coordonator ştiinţific: Prof. Dr. Tiberiu Dumitrescu Student: Sorin Bogde" />
  <title>DIMENSIUNEA COIREDUCTIBILĂ A INELELOR ŞI MODULELOR</title>
  <style>
    /* Default styles provided by pandoc.
    ** See https://pandoc.org/MANUAL.html#variables-for-html for config info.
    */
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
  <link rel="stylesheet" href="style.css" />
  <script
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
  type="text/javascript"></script>
</head>
<body>
<header id="title-block-header">
<h1 class="title">DIMENSIUNEA COIREDUCTIBILĂ A INELELOR ŞI
MODULELOR</h1>
<p class="author">Coordonator ştiinţific: Prof. Dr. Tiberiu
Dumitrescu<br />
Student: Sorin Bogde</p>
<p class="date">Universitatea Bucureşti, Facultatea de Matematică<br />
1999</p>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#generalităţi" id="toc-generalităţi">Generalităţi</a>
<ul>
<li><a href="#module-semisimple" id="toc-module-semisimple">Module
semisimple</a></li>
<li><a
href="#module-noetheriene-artiniene-şi-inele-noetheriene-artiniene"
id="toc-module-noetheriene-artiniene-şi-inele-noetheriene-artiniene">Module
noetheriene (artiniene) şi inele noetheriene (artiniene)</a></li>
<li><a href="#module-de-lungime-finită"
id="toc-module-de-lungime-finită">Module de lungime finită</a></li>
<li><a href="#radicalul-jacobson" id="toc-radicalul-jacobson">Radicalul
Jacobson</a></li>
<li><a href="#inele-semisimple" id="toc-inele-semisimple">Inele
semisimple</a></li>
</ul></li>
<li><a href="#submodule-esenţiale"
id="toc-submodule-esenţiale">Submodule esenţiale</a></li>
<li><a href="#module-injective" id="toc-module-injective">Module
injective</a>
<ul>
<li><a href="#module-injective-1" id="toc-module-injective-1">Module
injective</a></li>
<li><a href="#anvelope-injective" id="toc-anvelope-injective">Anvelope
injective</a></li>
</ul></li>
</ul>
</nav>
<h1 id="generalităţi">Generalităţi</h1>
<h2 id="module-semisimple">Module semisimple</h2>
<div class="definition">
<p><strong>Definiţie 1.1</strong>. Un <span
class="math inline">\(R\)</span>-modul nenul <span
class="math inline">\(S\)</span> se numeşte <em>simplu</em> dacă
singurele sale submodule sunt <span class="math inline">\(0\)</span> şi
<span class="math inline">\(S\)</span>.</p>
</div>
<div class="proposition">
<p><strong>Propoziţie 1.2</strong>. <em>Fie <span
class="math inline">\(S\)</span> un <span
class="math inline">\(R\)</span>-modul. Următoarele afirmaţii sunt
echivalente:</em></p>
<ol>
<li><p><em><span class="math inline">\(S\)</span> este modul
simplu.</em></p></li>
<li><p><em>Pentru orice element nenul <span class="math inline">\(x\in
S\)</span> avem <span class="math inline">\(S =
xR\)</span>.</em></p></li>
<li><p><em><span class="math inline">\(S \simeq R/I\)</span>, unde <span
class="math inline">\(I\)</span> este un ideal drept
maximal.</em></p></li>
</ol>
</div>
<div class="lemma">
<p><strong>Lemă 1.3</strong> (Schur). <em>Fie <span
class="math inline">\(S\)</span> şi <span
class="math inline">\(S&#39;\)</span> două <span
class="math inline">\(R\)</span>-module simple şi <span
class="math inline">\(f\colon S \to S&#39;\)</span> un morfism de <span
class="math inline">\(R\)</span>-module. Atunci <span
class="math inline">\(f = 0\)</span> sau <span
class="math inline">\(f\)</span> este izomorfism. În particular <span
class="math inline">\(\mathop{\mathrm{End}}_R(S)\)</span> este
corp.</em></p>
</div>
<div class="definition">
<p><strong>Definiţie 1.4</strong>. Fie <span
class="math inline">\(M\)</span> un <span
class="math inline">\(R\)</span>-modul şi <span
class="math inline">\((S_i)_{i\in I}\)</span> mulţimea submodulelor
simple ale lui <span class="math inline">\(M\)</span>. Dacă <span
class="math inline">\(M = \sum_{i\in I} S_i\)</span>, atunci <span
class="math inline">\(M\)</span> se numeşte <em>semisimplu</em>.</p>
</div>
<div class="proposition">
<p><strong>Propoziţie 1.5</strong>. <em>Fie <span
class="math inline">\(M\)</span> un <span
class="math inline">\(R\)</span>-modul semisimplu şi <span
class="math inline">\(N\)</span> un submodul al său. Atunci există o
submulţime <span class="math inline">\(J \subseteq I\)</span> astfel
încât:</em></p>
<ol>
<li><p><em>familia <span class="math inline">\((S_j)_{j\in J}\)</span>
este independentă;</em></p></li>
<li><p><em><span class="math inline">\(M = N \oplus
\bigl(\bigoplus_{j\in J} S_j\bigr)\)</span>.</em></p></li>
</ol>
</div>
<div class="corollary">
<p><strong>Corolar 1.6</strong>. <em>Cu notaţiile de mai sus, pentru
modulul semisimplu <span class="math inline">\(M\)</span> există <span
class="math inline">\(J \subseteq I\)</span> astfel încât familia <span
class="math inline">\((S_j)_{j\in J}\)</span> este independentă şi <span
class="math display">\[M = \bigoplus_{i\in I} M_i.\]</span></em></p>
</div>
<div class="corollary">
<p><strong>Corolar 1.7</strong>. <em>Dacă <span
class="math inline">\(M\)</span> este un <span
class="math inline">\(R\)</span>-modul semisimplu şi <span
class="math inline">\(N\)</span> un submodul al său, atunci <span
class="math inline">\(N\)</span> şi <span
class="math inline">\(M/N\)</span> sunt semisimple.</em></p>
</div>
<div class="corollary">
<p><strong>Corolar 1.8</strong>. <em>O sumă directă de module semisimple
este modul semisimplu.</em></p>
</div>
<div class="theorem">
<p><strong>Teoremă 1.9</strong>. <em>Fie <span
class="math inline">\(M\)</span> un <span
class="math inline">\(R\)</span>-modul. Următoarele afirmaţii sunt
echivalente:</em></p>
<ol>
<li><p><em><span class="math inline">\(M\)</span> este
semisimplu;</em></p></li>
<li><p><em><span class="math inline">\(M\)</span> este izomorf cu o sumă
directă de module simple;</em></p></li>
<li><p><em>orice submodul al său este sumand direct în <span
class="math inline">\(M\)</span>;</em></p></li>
<li><p><em>orice şir exact <span class="math display">\[0
\longrightarrow M&#39; \xrightarrow{\,f\,} M \xrightarrow{\,g\,}
M&#39;&#39; \longrightarrow 0\]</span> este scindabil.</em></p></li>
</ol>
</div>
<div class="definition">
<p><strong>Definiţie 1.10</strong>. Suma submodulelor simple ale lui
<span class="math inline">\(M\)</span> se numeşte <em>soclul</em> lui
<span class="math inline">\(M\)</span> şi se notează <span
class="math inline">\(\mathop{\mathrm{soc}}(M)\)</span>. Dacă <span
class="math inline">\(M\)</span> nu conţine nici un submodul simplu
atunci punem <span class="math inline">\(\mathop{\mathrm{soc}}(M) =
0\)</span>.</p>
</div>
<div class="proposition">
<p><strong>Propoziţie 1.11</strong>. <em>Fie <span
class="math inline">\(M\)</span> şi <span
class="math inline">\(N\)</span> două <span
class="math inline">\(R\)</span>-module şi <span
class="math inline">\(f\colon M \to N\)</span> un morfism. Atunci <span
class="math inline">\(f(\mathop{\mathrm{soc}}(M)) \subseteq
\mathop{\mathrm{soc}}(N)\)</span>.</em></p>
</div>
<div class="proposition">
<p><strong>Propoziţie 1.12</strong>. <em>Fie <span
class="math inline">\(M\)</span> un <span
class="math inline">\(R\)</span>-modul şi <span
class="math inline">\(N\)</span> un submodul al său. Atunci <span
class="math display">\[\mathop{\mathrm{soc}}(N) =
\mathop{\mathrm{soc}}(M) \cap N.\]</span></em></p>
</div>
<div class="proposition">
<p><strong>Propoziţie 1.13</strong>. <em>Dacă <span
class="math inline">\(M = \bigoplus_{i\in I} M_i\)</span>, atunci <span
class="math display">\[\mathop{\mathrm{soc}}(M) = \bigoplus_{i\in I}
\mathop{\mathrm{soc}}(M_i).\]</span></em></p>
</div>
<div class="proposition">
<p><strong>Propoziţie 1.14</strong>. <em>Fie <span
class="math inline">\(R\)</span> un inel. Atunci <span
class="math inline">\(\mathop{\mathrm{soc}}(R_R)\)</span> este un ideal
bilateral al lui <span class="math inline">\(R\)</span>.</em></p>
</div>
<h2
id="module-noetheriene-artiniene-şi-inele-noetheriene-artiniene">Module
noetheriene (artiniene) şi inele noetheriene (artiniene)</h2>
<div class="definition">
<p><strong>Definiţie 1.15</strong>. Fie <span
class="math inline">\(R\)</span> un inel şi <span
class="math inline">\(M\)</span> un <span
class="math inline">\(R\)</span>-modul drept. Spunem că <span
class="math inline">\(M\)</span> satisface <em>condiţia maximală</em>
(resp. <em>minimală</em>) dacă orice mulţime nevidă de submodule ale lui
<span class="math inline">\(M\)</span>, ordonată prin incluziune, admite
un element maximal (resp. minimal).</p>
<p>Spunem că <span class="math inline">\(M\)</span> satisface
<em>condiţia lanţurilor ascendente</em> (resp. <em>descendente</em>)
dacă orice şir (lanţ) ascendent de submodule ale lui <span
class="math inline">\(M\)</span> <span class="math display">\[M_1
\subseteq M_2 \subseteq \cdots \subseteq M_i \subseteq \cdots\]</span>
(resp. orice şir descendent <span class="math display">\[M_1 \supseteq
M_2 \supseteq \cdots \supseteq M_i \supseteq \cdots\]</span>) este
staţionar, adică există <span class="math inline">\(n \ge 1\)</span>
astfel încât <span class="math inline">\(M_n = M_{n+1} =
\cdots\)</span>.</p>
</div>
<div class="proposition">
<p><strong>Propoziţie 1.16</strong>. <em>Fie <span
class="math inline">\(M\)</span> un <span
class="math inline">\(R\)</span>-modul. Următoarele afirmaţii sunt
echivalente:</em></p>
<ol>
<li><p><em><span class="math inline">\(M\)</span> satisface condiţia
maximală (minimală);</em></p></li>
<li><p><em><span class="math inline">\(M\)</span> satisface condiţia
lanţurilor ascendente (descendente).</em></p></li>
</ol>
</div>
<div class="definition">
<p><strong>Definiţie 1.17</strong>. Un <span
class="math inline">\(R\)</span>-modul <span
class="math inline">\(M\)</span> se numeşte <em>noetherian</em> (resp.
<em>artinian</em>) dacă satisface condiţia maximală (resp. minimală).
Inelul <span class="math inline">\(R\)</span> se numeşte noetherian
(resp. artinian) la dreapta dacă <span
class="math inline">\(R_R\)</span> este noetherian (resp. artinian).</p>
</div>
<div class="example">
<p><strong>Exemplu 1.18</strong>. </p>
<ol>
<li><p><span class="math inline">\(\mathbb{Z}\)</span> este inel
noetherian dar nu este artinian.</p></li>
<li><p>Orice grup finit este <span
class="math inline">\(\mathbb{Z}\)</span>-modul noetherian şi
artinian.</p></li>
<li><p>Orice inel finit este noetherian şi artinian.</p></li>
<li><p><span
class="math inline">\(\mathbb{Z}[X_1,X_2,\ldots,X_n,\ldots]\)</span> nu
este nici noetherian, nici artinian: <span class="math display">\[(X_1)
\subsetneq (X_1,X_2) \subsetneq \cdots \subsetneq
          (X_1,\ldots,X_n) \subsetneq \cdots\]</span> <span
class="math display">\[(X_1) \supsetneq (X_1^2) \supsetneq \cdots
\supsetneq
          (X_1^k) \supsetneq \cdots\]</span></p></li>
<li><p><span class="math inline">\(\mathbb{Z}_{p^\infty}\)</span> este
<span class="math inline">\(\mathbb{Z}\)</span>-modul artinian dar nu
este noetherian.</p></li>
</ol>
</div>
<div class="proposition">
<p><strong>Propoziţie 1.19</strong>. <em>Fie <span
class="math inline">\(N, P\)</span> două submodule ale lui <span
class="math inline">\(M\)</span> astfel încât <span
class="math inline">\(M = N + P\)</span>. Atunci <span
class="math inline">\(M\)</span> este noetherian (artinian) dacă şi
numai dacă <span class="math inline">\(N\)</span> şi <span
class="math inline">\(P\)</span> sunt noetheriene (artiniene).</em></p>
</div>
<div class="proposition">
<p><strong>Propoziţie 1.20</strong>. <em>Pentru un <span
class="math inline">\(R\)</span>-modul <span
class="math inline">\(M\)</span> următoarele afirmaţii sunt
echivalente:</em></p>
<ol>
<li><p><em><span class="math inline">\(M\)</span> este
noetherian;</em></p></li>
<li><p><em>orice submodul al lui <span class="math inline">\(M\)</span>
este finit generat.</em></p></li>
</ol>
</div>
<div class="proposition">
<p><strong>Propoziţie 1.21</strong>. <em>Pentru un <span
class="math inline">\(R\)</span>-modul <span
class="math inline">\(M\)</span> următoarele afirmaţii sunt
echivalente:</em></p>
<ol>
<li><p><em><span class="math inline">\(M\)</span> este
artinian;</em></p></li>
<li><p><em>oricare ar fi familia <span class="math inline">\((X_i)_{i\in
I}\)</span> de submodule ale lui <span class="math inline">\(M\)</span>,
există <span class="math inline">\(J \subseteq I\)</span>, <span
class="math inline">\(J\)</span> finită, astfel încât <span
class="math display">\[\bigcap_{i\in I} X_i = \bigcap_{j\in J}
X_j.\]</span></em></p></li>
</ol>
</div>
<h2 id="module-de-lungime-finită">Module de lungime finită</h2>
<div class="definition">
<p><strong>Definiţie 1.22</strong>. Fie <span
class="math inline">\(M\)</span> un <span
class="math inline">\(R\)</span>-modul drept nenul. Se numeşte <em>şir
de compoziţie</em> sau <em>şir Jordan–Hölder</em> al lui <span
class="math inline">\(M\)</span> un lanţ finit strict ascendent de
submodule <span class="math display">\[0 = X_0 \subset X_1 \subset
\cdots \subset X_n = M\]</span> astfel încât <span
class="math inline">\(X_{i+1}/X_i\)</span> este modul simplu pentru
<span class="math inline">\(0 \le i \le n-1\)</span>. Numărul <span
class="math inline">\(n\)</span> se numeşte <em>lungimea şirului</em>,
iar modulele <span class="math inline">\(X_{i+1}/X_i\)</span> se numesc
<em>factorii şirului</em>.</p>
</div>
<div class="proposition">
<p><strong>Propoziţie 1.23</strong>. <em>Fie <span
class="math inline">\(M\)</span> un <span
class="math inline">\(R\)</span>-modul. Următoarele afirmaţii sunt
echivalente:</em></p>
<ol>
<li><p><em><span class="math inline">\(M\)</span> are un şir de
compoziţie;</em></p></li>
<li><p><em><span class="math inline">\(M\)</span> este noetherian şi
artinian.</em></p></li>
</ol>
</div>
<div class="proposition">
<p><strong>Propoziţie 1.24</strong>. <em>Fie <span
class="math display">\[0 \longrightarrow M&#39; \longrightarrow M
\longrightarrow M&#39;&#39; \longrightarrow 0\]</span> un şir exact de
<span class="math inline">\(R\)</span>-module drepte. Atunci <span
class="math inline">\(M\)</span> admite un şir de compoziţie dacă şi
numai dacă <span class="math inline">\(M&#39;\)</span> şi <span
class="math inline">\(M&#39;&#39;\)</span> admit un şir de
compoziţie.</em></p>
</div>
<p>Dacă <span class="math display">\[0 = M_0 \subseteq M_1 \subseteq
\cdots \subseteq M_n = M,\qquad
  0 = N_0 \subseteq N_1 \subseteq \cdots \subseteq N_p = M\]</span> sunt
două şiruri de compoziţie ale lui <span
class="math inline">\(M\)</span>, vom spune că ele sunt
<em>echivalente</em> dacă <span class="math inline">\(n=p\)</span> şi
există o bijecţie <span class="math inline">\(\sigma : \{0,\ldots,n-1\}
\to \{0,\ldots,n-1\}\)</span> astfel încât <span
class="math display">\[M_{i+1}/M_i \cong M_{\sigma(i)+1}/M_{\sigma(i)}
  \quad (0 \le i \le n-1).\]</span></p>
<div class="theorem">
<p><strong>Teoremă 1.25</strong> (Jordan–Hölder). <em>Dacă un <span
class="math inline">\(R\)</span>-modul <span
class="math inline">\(M\)</span> are două şiruri de compoziţie <span
class="math display">\[0 = M_0 \subseteq M_1 \subseteq \cdots \subseteq
M_n = M,\qquad
  0 = N_0 \subseteq N_1 \subseteq \cdots \subseteq N_p = M,\]</span>
atunci aceste două şiruri sunt echivalente.</em></p>
</div>
<div class="definition">
<p><strong>Definiţie 1.26</strong>. Un <span
class="math inline">\(R\)</span>-modul <span
class="math inline">\(M\)</span> care admite un şir de compoziţie se
numeşte <em>modul de lungime finită</em>. Lungimea şirurilor de
compoziţie se numeşte <em>lungimea</em> lui <span
class="math inline">\(M\)</span> şi se notează <span
class="math inline">\(l(M)\)</span>. Dacă <span
class="math inline">\(M\)</span> nu admite nici un şir de com­po­zi­ţie,
atunci spunem că <span class="math inline">\(M\)</span> este <em>de
lungime infinită</em> şi scriem <span
class="math inline">\(l(M)=\infty\)</span>.</p>
</div>
<div class="proposition">
<p><strong>Propoziţie 1.27</strong>. <em>Fie <span
class="math display">\[0 \longrightarrow M&#39; \longrightarrow M
\longrightarrow M&#39;&#39; \longrightarrow 0\]</span> un şir exact de
<span class="math inline">\(R\)</span>-module de lungime finită. Atunci
<span class="math display">\[l(M) = l(M&#39;) +
l(M&#39;&#39;).\]</span></em></p>
</div>
<div class="corollary">
<p><strong>Corolar 1.28</strong>. <em>Fie <span
class="math inline">\(M\)</span> un <span
class="math inline">\(R\)</span>-modul de lungime finită şi <span
class="math inline">\(N,L\)</span> două submodule ale sale.
Atunci:</em></p>
<ol>
<li><p><em><span class="math inline">\(l(M) = l(N) +
l(M/N)\)</span>;</em></p></li>
<li><p><em><span class="math inline">\(l(N+L) + l(N\cap L) = l(N) +
l(L)\)</span>.</em></p></li>
</ol>
</div>
<div class="corollary">
<p><strong>Corolar 1.29</strong>. <em>Fie <span
class="math inline">\(M\)</span> un <span
class="math inline">\(R\)</span>-modul de lungime finită şi <span
class="math inline">\(M_1,M_2,\ldots,M_n\)</span> submodule ale sale
astfel încât <span class="math display">\[M = M_1 \oplus M_2 \oplus
\cdots \oplus M_n.\]</span> Atunci <span class="math display">\[l(M) =
\sum_{i=1}^{n} l(M_i).\]</span></em></p>
</div>
<h2 id="radicalul-jacobson">Radicalul Jacobson</h2>
<h3 class="unnumbered" id="radicalul-jacobson-al-unui-modul">Radicalul
Jacobson al unui modul</h3>
<div class="definition">
<p><strong>Definiţie 1.30</strong>. Fie <span
class="math inline">\(M\)</span> un <span
class="math inline">\(R\)</span>-modul. Intersecţia tuturor submodulelor
maximale ale lui <span class="math inline">\(M\)</span> se numeşte
<em>radicalul Jacobson</em> al modulului <span
class="math inline">\(M\)</span> şi se notează <span
class="math inline">\(\mathop{\mathrm{Rad}}(M)\)</span>. Dacă <span
class="math inline">\(M\)</span> nu are nici un submodul maximal, atunci
prin convenţie punem <span
class="math inline">\(\mathop{\mathrm{Rad}}(M)=M\)</span>.</p>
</div>
<div class="remark">
<p><em>Observaţie 1.31</em>. Dacă <span class="math inline">\(M\)</span>
este un <span class="math inline">\(R\)</span>-modul finit generat,
atunci <span class="math inline">\(\mathop{\mathrm{Rad}}(M)\ne
M\)</span>.</p>
</div>
<div class="proposition">
<p><strong>Propoziţie 1.32</strong>. <em>Fie <span
class="math inline">\(M\)</span> un <span
class="math inline">\(R\)</span>-modul. Atunci <span
class="math display">\[\mathop{\mathrm{Rad}}(M)
  = \bigcap_{\substack{f : M \to S\\ S\ \text{simplu}}} \ker(f)
  = \bigcap_{\substack{f : M \to X\\ X\ \text{semisimplu}}}
\ker(f).\]</span></em></p>
</div>
<div class="proposition">
<p><strong>Propoziţie 1.33</strong>. <em>Fie <span
class="math inline">\(f : M \to N\)</span> un morfism de <span
class="math inline">\(R\)</span>-module. Atunci <span
class="math inline">\(f(\mathop{\mathrm{Rad}}(M)) \subseteq
\mathop{\mathrm{Rad}}(N)\)</span>. Dacă, în plus, <span
class="math inline">\(f\)</span> este epimorfism şi <span
class="math inline">\(\ker(f) \subseteq
\mathop{\mathrm{Rad}}(M)\)</span>, atunci <span
class="math inline">\(f(\mathop{\mathrm{Rad}}(M)) =
\mathop{\mathrm{Rad}}(N)\)</span>.</em></p>
</div>
<div class="corollary">
<p><strong>Corolar 1.34</strong>. <em>Pentru orice <span
class="math inline">\(R\)</span>-modul <span
class="math inline">\(M\)</span> are loc egalitatea <span
class="math inline">\(\mathop{\mathrm{Rad}}(M/\mathop{\mathrm{Rad}}(M))
= 0\)</span>.</em></p>
</div>
<div class="corollary">
<p><strong>Corolar 1.35</strong>. <em>Dacă <span
class="math inline">\(M\)</span> este un <span
class="math inline">\(R\)</span>-modul semisimplu, atunci <span
class="math inline">\(\mathop{\mathrm{Rad}}(M)=0\)</span>.</em></p>
</div>
<div class="corollary">
<p><strong>Corolar 1.36</strong>. <em>Dacă <span class="math inline">\(M
= \bigoplus_{i\in I} M_i\)</span>, atunci <span
class="math display">\[\mathop{\mathrm{Rad}}(M) = \bigoplus_{i\in I}
\mathop{\mathrm{Rad}}(M_i).\]</span></em></p>
</div>
<div class="proposition">
<p><strong>Propoziţie 1.37</strong>. <em>Fie <span
class="math inline">\(M\)</span> un <span
class="math inline">\(R\)</span>-modul astfel încât <span
class="math inline">\(\mathop{\mathrm{Rad}}(M)\ne M\)</span>. Atunci
<span class="math display">\[\mathop{\mathrm{Rad}}(M)
  = \bigcap \{\,L \le M \mid L \text{ este submodul
superfluu}\,\}.\]</span></em></p>
</div>
<div class="proposition">
<p><strong>Propoziţie 1.38</strong> (Lema lui Nakayama). <em>Fie <span
class="math inline">\(M\)</span> un <span
class="math inline">\(R\)</span>-modul finit generat şi <span
class="math inline">\(N\)</span> un submodul al său. Dacă <span
class="math inline">\(N + \mathop{\mathrm{Rad}}(M) = M\)</span>, atunci
<span class="math inline">\(N = M\)</span>. (Adică <span
class="math inline">\(\mathop{\mathrm{Rad}}(M)\)</span> este cel mai
mare submodul superfluu al lui <span
class="math inline">\(M\)</span>.)</em></p>
</div>
<h3 class="unnumbered" id="radicalul-jacobson-al-unui-inel">Radicalul
Jacobson al unui inel</h3>
<p>Fie <span class="math inline">\(R\)</span> un inel. Considerăm
idealul stâng <span class="math inline">\(\mathop{\mathrm{Rad}}({}_R
R)\)</span> ca intersecţie a idealelor stângi maximale ale lui <span
class="math inline">\(R\)</span> şi <span
class="math inline">\(\mathop{\mathrm{Rad}}(R_R)\)</span> ca intersecţie
a idealelor drepte maximale ale lui <span
class="math inline">\(R\)</span>.</p>
<div class="proposition">
<p><strong>Propoziţie 1.39</strong>. </p>
<ol>
<li><p><em><span
class="math inline">\(\mathop{\mathrm{Rad}}(R_R)\)</span> este un ideal
bilateral.</em></p></li>
<li><p><em><span class="math inline">\(\mathop{\mathrm{Rad}}(R_R) =
\{\,r \in R \mid 1-ar \in U(R)\ \text{pentru orice } a \in
R\,\}\)</span>.</em></p></li>
<li><p><em><span class="math inline">\(\mathop{\mathrm{Rad}}(R_R) =
\mathop{\mathrm{Rad}}({}_R R)\)</span>.</em></p></li>
</ol>
</div>
<div class="definition">
<p><strong>Definiţie 1.40</strong>. Idealul bilateral <span
class="math inline">\(\mathop{\mathrm{Rad}}(R_R) =
\mathop{\mathrm{Rad}}({}_R R)\)</span> se numeşte <em>radicalul
Jacobson</em> al inelului <span class="math inline">\(R\)</span> şi se
notează <span
class="math inline">\(\mathop{\mathrm{Rad}}(R)\)</span>.</p>
</div>
<div class="proposition">
<p><strong>Propoziţie 1.41</strong>. </p>
<ol>
<li><p><em>Dacă <span class="math inline">\(J\)</span> este un ideal
stâng (resp. drept sau bilateral) cu proprietatea că <span
class="math inline">\(1-x\)</span> este inversabil pentru orice <span
class="math inline">\(x \in J\)</span>, atunci <span
class="math inline">\(J \subseteq
\mathop{\mathrm{Rad}}(R)\)</span>.</em></p></li>
<li><p><em>Dacă <span class="math inline">\(J\)</span> este un nilideal
stâng (resp. drept sau bilateral), atunci <span class="math inline">\(J
\subseteq \mathop{\mathrm{Rad}}(R)\)</span>.</em></p></li>
</ol>
</div>
<div class="proposition">
<p><strong>Propoziţie 1.42</strong>. <em>Fie <span
class="math inline">\(\varphi : R \to S\)</span> un morfism surjectiv de
inele. Atunci <span
class="math inline">\(\varphi(\mathop{\mathrm{Rad}}(R)) \subseteq
\mathop{\mathrm{Rad}}(S)\)</span>. Dacă <span
class="math inline">\(\ker(\varphi)
\subseteq \mathop{\mathrm{Rad}}(R)\)</span>, atunci <span
class="math inline">\(\varphi(\mathop{\mathrm{Rad}}(R)) =
\mathop{\mathrm{Rad}}(S)\)</span>.</em></p>
</div>
<div class="proposition">
<p><strong>Propoziţie 1.43</strong>. <em>Dacă <span
class="math inline">\((R_i)_{i\in I}\)</span> este o familie de inele,
atunci <span
class="math display">\[\mathop{\mathrm{Rad}}\Bigl(\prod_{i\in I}
R_i\Bigr) = \prod_{i\in I} \mathop{\mathrm{Rad}}(R_i).\]</span></em></p>
</div>
<div class="proposition">
<p><strong>Propoziţie 1.44</strong>. <em>Fie <span
class="math inline">\(M\)</span> un <span
class="math inline">\(R\)</span>-modul. Atunci <span
class="math inline">\(M\,\mathop{\mathrm{Rad}}(R) \subseteq
\mathop{\mathrm{Rad}}(M)\)</span>.</em></p>
</div>
<div class="theorem">
<p><strong>Teoremă 1.45</strong>. <em>Dacă <span
class="math inline">\(R\)</span> este un inel artinian, atunci <span
class="math inline">\(\mathop{\mathrm{Rad}}(R)\)</span> este
nilpotent.</em></p>
</div>
<h2 id="inele-semisimple">Inele semisimple</h2>
<div class="theorem">
<p><strong>Teoremă 1.46</strong>. <em>Pentru un inel <span
class="math inline">\(R\)</span> următoarele afirmaţii sunt
echivalente:</em></p>
<ol>
<li><p><em>orice <span class="math inline">\(R\)</span>-modul drept
nenul este semisimplu;</em></p></li>
<li><p><em><span class="math inline">\(R\)</span> este <span
class="math inline">\(R\)</span>-modul drept semisimplu;</em></p></li>
<li><p><em><span class="math inline">\(R\)</span> este artinian şi <span
class="math inline">\(\mathop{\mathrm{Rad}}(R)=0\)</span>.</em></p></li>
</ol>
</div>
<div class="definition">
<p><strong>Definiţie 1.47</strong>. Un inel <span
class="math inline">\(R\)</span> care satisface una din condiţiile de
mai sus se numeşte <em>inel semisimplu</em>.</p>
</div>
<div class="proposition">
<p><strong>Propoziţie 1.48</strong>. <em>Fie <span
class="math inline">\(R\)</span> un inel semisimplu şi <span
class="math inline">\(M\)</span> un <span
class="math inline">\(R\)</span>-modul nenul. Următoarele afirmaţii sunt
echivalente:</em></p>
<ol>
<li><p><em><span class="math inline">\(M\)</span> este de lungime
finită;</em></p></li>
<li><p><em><span class="math inline">\(M\)</span> este
noetherian;</em></p></li>
<li><p><em><span class="math inline">\(M\)</span> este
artinian.</em></p></li>
</ol>
</div>
<div class="theorem">
<p><strong>Teoremă 1.49</strong>. <em>Fie <span
class="math inline">\(R\)</span> un inel artinian la dreapta şi <span
class="math inline">\(M\)</span> un <span
class="math inline">\(R\)</span>-modul nenul. Următoarele afirmaţii sunt
echivalente:</em></p>
<ol>
<li><p><em><span class="math inline">\(M\)</span> este de lungime
finită;</em></p></li>
<li><p><em><span class="math inline">\(M\)</span> este
noetherian;</em></p></li>
<li><p><em><span class="math inline">\(M\)</span> este
artinian.</em></p></li>
</ol>
</div>
<div class="corollary">
<p><strong>Corolar 1.50</strong> (Hopkins). <em>Un inel artinian la
dreapta (respectiv la stânga) este noetherian la dreapta (respectiv la
stânga).</em></p>
</div>
<h1 id="submodule-esenţiale">Submodule esenţiale</h1>
<div id="def:submodul-esential" class="definition">
<p><strong>Definiţie 2.1</strong>. Fie <span
class="math inline">\(M\)</span> un <span
class="math inline">\(R\)</span>-modul drept. Un submodul <span
class="math inline">\(N\)</span> al lui <span
class="math inline">\(M\)</span> se numeşte <em>esenţial</em> (sau
spunem că <span class="math inline">\(M\)</span> este o extensie
esenţială a lui <span class="math inline">\(N\)</span>) dacă <span
class="math inline">\(N \cap N&#39; \neq 0\)</span> pentru orice
submodul nenul <span class="math inline">\(N&#39;\)</span> al lui <span
class="math inline">\(M\)</span>. În acest caz vom folosi notaţia <span
class="math inline">\(N \trianglelefteq M_R\)</span>.</p>
<p>Un monomorfism de <span class="math inline">\(R\)</span>-module la
dreapta <span class="math inline">\(f : M \to N\)</span> se numeşte
<em>esenţial</em> dacă <span class="math inline">\(\operatorname{Im}
f\)</span> este submodul esenţial în <span
class="math inline">\(N\)</span> (adică <span
class="math inline">\(\operatorname{Im} f \trianglelefteq
N_R\)</span>).</p>
</div>
<div class="example*">
<p><strong>Exemplu 2.1</strong>. </p>
<ol>
<li><p><span class="math inline">\(n\mathbb{Z}
\trianglelefteq\mathbb{Z}_\mathbb{Z}\)</span> pentru orice <span
class="math inline">\(n \geq 1\)</span>.</p></li>
<li><p>Orice submodul al lui <span
class="math inline">\(\mathbb{Z}_{p^\infty}\)</span> este
esenţial.</p></li>
</ol>
</div>
<div class="remark">
<p><em>Observaţie 2.2</em>. Fie <span class="math inline">\(M\)</span>
un <span class="math inline">\(R\)</span>-modul drept şi <span
class="math inline">\(N\)</span> un submodul al lui <span
class="math inline">\(M\)</span>. Atunci <span class="math inline">\(N
\trianglelefteq M_R\)</span> dacă şi numai dacă pentru orice <span
class="math inline">\(x \in M\)</span>, <span class="math inline">\(x
\neq 0\)</span>, există <span class="math inline">\(r \in R\)</span>
astfel încât <span class="math inline">\(xr \in N \setminus
\{0\}\)</span>.</p>
</div>
<div class="proof">
<p><em>Proof.</em> „<span class="math inline">\(\Rightarrow\)</span>”
Fie <span class="math inline">\(x \in M \setminus \{0\}\)</span>. Cum
<span class="math inline">\(0 \neq xR \subseteq M_R\)</span> şi <span
class="math inline">\(N \trianglelefteq M_R\)</span>, rezultă că <span
class="math inline">\(xR \cap N \neq 0\)</span>, deci există <span
class="math inline">\(xr \in xR \cap N \setminus \{0\}\)</span>.</p>
<p>„<span class="math inline">\(\Leftarrow\)</span>” Fie <span
class="math inline">\(N&#39; \leq M_R\)</span>, <span
class="math inline">\(N&#39; \neq 0\)</span>. Pentru <span
class="math inline">\(x \in N&#39; \setminus \{0\}\)</span> există <span
class="math inline">\(r \in R\)</span> astfel încât <span
class="math inline">\(xr \in N \setminus \{0\}\)</span>, deci <span
class="math inline">\(N \cap N&#39; \neq 0\)</span>. ◻</p>
</div>
<div class="definition">
<p><strong>Definiţie 2.3</strong>. Un monomorfism de <span
class="math inline">\(R\)</span>-module la dreapta <span
class="math inline">\(f : N_R \to M_R\)</span> se numeşte esenţial dacă
<span class="math inline">\(\operatorname{Im} f \trianglelefteq
M_R\)</span>. Se observă imediat că dacă <span
class="math inline">\(N\)</span> este un submodul al lui <span
class="math inline">\(M\)</span> atunci incluziunea canonică <span
class="math inline">\(i_N : N \to M\)</span> este monomorfism esenţial
dacă şi numai dacă <span class="math inline">\(N \trianglelefteq
M_R\)</span>.</p>
</div>
<div class="proposition">
<p><strong>Propoziţie 2.4</strong>. <em>Un monomorfism <span
class="math inline">\(f : N_R \to M_R\)</span> este esenţial dacă şi
numai dacă pentru orice <span class="math inline">\(R\)</span>-modul
drept <span class="math inline">\(M&#39;\)</span> şi orice <span
class="math inline">\(g \in \mathop{\mathrm{Hom}}(M,M&#39;)\)</span>,
faptul că <span class="math inline">\(g \circ f\)</span> este
monomorfism implică <span class="math inline">\(g\)</span>
monomorfism.</em></p>
</div>
<div class="proof">
<p><em>Proof.</em> <br />
„<span class="math inline">\(\Rightarrow\)</span>” Fie <span
class="math inline">\(g\)</span> ca în enunţ astfel încât <span
class="math inline">\(g \circ f\)</span> este monomorfism. Presupunem
<span class="math inline">\(g \neq 0\)</span>. Fie <span
class="math inline">\(x \in \mathop{\mathrm{Ker}}g \cap
\operatorname{Im} f \setminus \{0\}\)</span>. Există <span
class="math inline">\(x&#39; \in N\)</span> astfel încât <span
class="math inline">\(x = f(x&#39;)\)</span> şi <span
class="math inline">\(g(x) = 0\)</span>, de unde <span
class="math inline">\(g(f(x&#39;)) = 0\)</span>. Cum <span
class="math inline">\(g \circ f\)</span> este monomorfism, rezultă <span
class="math inline">\(x&#39; = 0\)</span> şi deci <span
class="math inline">\(x = 0\)</span>, contradicţie.</p>
<p>„<span class="math inline">\(\Leftarrow\)</span>” Dacă <span
class="math inline">\(f\)</span> nu este monomorfism esenţial atunci
există <span class="math inline">\(N&#39; \leq M_R\)</span>, <span
class="math inline">\(N&#39; \neq 0\)</span>, astfel încât <span
class="math inline">\(N&#39; \cap \operatorname{Im} f = 0\)</span>.
Considerăm proiecţia canonică <span class="math inline">\(\pi_{N&#39;} :
M \to M/N&#39;\)</span>. Dacă <span class="math inline">\(x \in
\mathop{\mathrm{Ker}}(\pi_{N&#39;} \circ f)\)</span>, atunci <span
class="math inline">\(f(x) \in N&#39;\)</span>, deci <span
class="math inline">\(f(x) = 0\)</span>, adică <span
class="math inline">\(x = 0\)</span>. Obţinem astfel că <span
class="math inline">\(\pi_{N&#39;} \circ f\)</span> este injectiv, de
unde rezultă că <span class="math inline">\(\pi_{N&#39;}\)</span> este
injectiv, ceea ce implică <span class="math inline">\(N&#39; =
0\)</span>, contradicţie. ◻</p>
</div>
<div class="corollary">
<p><strong>Corolar 2.5</strong>. <em>Fie <span
class="math inline">\(M\)</span> un <span
class="math inline">\(R\)</span>-modul la dreapta şi <span
class="math inline">\(N \leq M_R\)</span>. Atunci următoarele afirmaţii
sunt echivalente:</em></p>
<ol>
<li><p><em><span class="math inline">\(N \trianglelefteq
M_R\)</span>;</em></p></li>
<li><p><em>incluziunea <span class="math inline">\(i_N : N \to
M\)</span> este monomorfism esenţial;</em></p></li>
<li><p><em>pentru orice <span class="math inline">\(f \in
\mathop{\mathrm{Hom}}(M,M&#39;)\)</span> cu <span
class="math inline">\(M&#39;\)</span> <span
class="math inline">\(R\)</span>-modul arbitrar, faptul că <span
class="math inline">\(f \circ i_N\)</span> este monomorfism implică
<span class="math inline">\(f\)</span> monomorfism.</em></p></li>
</ol>
</div>
<div class="proposition">
<p><strong>Propoziţie 2.6</strong>. <em>Fie <span
class="math inline">\(f : N_R \to M_R\)</span> şi <span
class="math inline">\(g : M_R \to P_R\)</span> două monomorfisme. Atunci
<span class="math inline">\(g \circ f\)</span> este esenţial dacă şi
numai dacă <span class="math inline">\(g\)</span> şi <span
class="math inline">\(f\)</span> sunt esenţiale.</em></p>
</div>
<div class="proof">
<p><em>Proof.</em> <br />
„<span class="math inline">\(\Leftarrow\)</span>” Fie <span
class="math inline">\(z \in P \setminus \{0\}\)</span>. Cum <span
class="math inline">\(g\)</span> este esenţial, există <span
class="math inline">\(r \in R\)</span> astfel încât <span
class="math inline">\(zr \in \operatorname{Im} g \setminus
\{0\}\)</span>. Există <span class="math inline">\(y \in M \setminus
\{0\}\)</span> astfel încât <span class="math inline">\(zr =
g(y)\)</span>.</p>
<p>Cum <span class="math inline">\(f\)</span> este esenţial, există
<span class="math inline">\(r&#39; \in R\)</span> astfel încât <span
class="math inline">\(y r&#39; \in \mathrm{Im}\, f \setminus
\{0\}\)</span>. De aici există <span class="math inline">\(x \in N
\setminus \{0\}\)</span> astfel încât <span class="math inline">\(y
r&#39; = f(x)\)</span>. Dar <span class="math inline">\(zr&#39; = g(y)
r&#39; = g(y r&#39;) = g(f(x))\)</span>. Dacă <span
class="math inline">\(zr&#39; = 0\)</span>, atunci <span
class="math inline">\(g(f(x)) = 0\)</span> şi deci <span
class="math inline">\(x = 0\)</span>, contradicţie. Obţinem astfel că
<span class="math inline">\(zr&#39; \in \mathrm{Im}(g \circ f)\)</span>
şi că <span class="math inline">\(zr&#39; \neq 0\)</span>, ceea ce ne
arată că <span class="math inline">\(g \circ f\)</span> este
esenţial.</p>
<p>„<span class="math inline">\(\Rightarrow\)</span>” Fie <span
class="math inline">\(y \in M \setminus \{0\}\)</span>. Cum <span
class="math inline">\(g\)</span> este monomorfism, <span
class="math inline">\(g(y) \neq 0\)</span>. Deci există <span
class="math inline">\(r \in R\)</span> astfel încât <span
class="math inline">\(g(yr) \in \mathrm{Im}\, g \setminus \{0\}\)</span>
şi <span class="math inline">\(g(yr) \neq 0\)</span>. Rezultă că există
<span class="math inline">\(x \in N \setminus \{0\}\)</span> astfel
încât <span class="math inline">\(g(yr) = g(f(x))\)</span> de unde <span
class="math inline">\(yr = f(x) \in \mathrm{Im}\, f\)</span>, ceea ce ne
arată că <span class="math inline">\(f\)</span> este monomorfism
esenţial.</p>
<p>Dacă <span class="math inline">\(z \in P \setminus \{0\}\)</span>
există <span class="math inline">\(r \in R\)</span> astfel încât <span
class="math inline">\(zr \in \mathrm{Im}(g \circ f)\)</span> şi <span
class="math inline">\(zr \neq 0\)</span>. Cum <span
class="math inline">\(\mathrm{Im}(g \circ f) \subseteq \mathrm{Im}
g\)</span>, rezultă că <span class="math inline">\(zr \in \mathrm{Im}
g\)</span>, şi deci <span class="math inline">\(g\)</span> este
monomorfism esenţial. ◻</p>
</div>
<div class="proposition">
<p><strong>Propoziţie 2.7</strong>. <em>Fie <span
class="math inline">\(M\)</span> un <span
class="math inline">\(R\)</span>-modul la dreapta şi <span
class="math inline">\(L_1, L_2, \ldots, L_n\)</span> submodule ale lui
<span class="math inline">\(M\)</span>. Atunci:</em></p>
<p><em>1) <span class="math inline">\(\displaystyle \bigcap_{i=1}^n
L_i\)</span> este esenţial în <span class="math inline">\(M\)</span>
dacă şi numai dacă <span class="math inline">\(L_i\)</span> este
esenţial în <span class="math inline">\(M\)</span> pentru orice <span
class="math inline">\(i = 1,\ldots,n\)</span>.</em></p>
<p><em>2) Dacă <span class="math inline">\(L_1 \subseteq L_2\)</span> şi
<span class="math inline">\(L_1\)</span> este esenţial în <span
class="math inline">\(M\)</span>, atunci <span
class="math inline">\(L_2\)</span> este esenţial în <span
class="math inline">\(M\)</span>.</em></p>
<p><em>Demonstraţia este evidentă.</em></p>
</div>
<div class="proposition">
<p><strong>Propoziţie 2.8</strong>. <em>Fie <span
class="math inline">\(K\)</span> şi <span
class="math inline">\(L\)</span> două submodule ale lui <span
class="math inline">\(M\)</span>. 1) Dacă <span class="math inline">\(K
\subseteq L \subseteq M\)</span>, atunci <span class="math inline">\(K
\, \trianglelefteq\, M\)</span> dacă şi numai dacă <span
class="math inline">\(K \, \trianglelefteq\, L\)</span> şi <span
class="math inline">\(L \, \trianglelefteq\, M\)</span>.</em></p>
<p><em>2) Dacă <span class="math inline">\(h : K_R \to M_R\)</span> este
morfism de module şi <span class="math inline">\(L \, \trianglelefteq\,
M\)</span>, atunci <span class="math inline">\(h^{-1}(L) \,
\trianglelefteq\, K\)</span>.</em></p>
<p><em>3) Dacă <span class="math inline">\(L_1, L_2 \leq M_R\)</span> şi
<span class="math inline">\(K_1 \, \trianglelefteq\, L_1\)</span>, <span
class="math inline">\(K_2 \, \trianglelefteq\, L_2\)</span>, atunci
<span class="math inline">\(K_1 \cap K_2 \, \trianglelefteq\, L_1 \cap
L_2\)</span>.</em></p>
</div>
<div class="proof">
<p><em>Proof.</em> <br />
1) Se aplică 1.5 şi 1.6.</p>
<p>2) Fie <span class="math inline">\(U\)</span> submodul nenul al lui
<span class="math inline">\(K\)</span>. (i) Dacă <span
class="math inline">\(h(U) = 0\)</span>, atunci <span
class="math inline">\(U \subseteq \ker h \subseteq h^{-1}(L)\)</span>,
ceea ce implică <span class="math inline">\(U \cap h^{-1}(L) \neq
0\)</span>. (ii) Dacă <span class="math inline">\(h(U) \neq 0\)</span>,
atunci <span class="math inline">\(h(U) \cap L \neq 0\)</span> şi deci
există <span class="math inline">\(u \in U\)</span> astfel încât <span
class="math inline">\(h(u) \in L\)</span>, <span
class="math inline">\(h(u) \neq 0\)</span>, de unde <span
class="math inline">\(u \in U \cap h^{-1}(L)\)</span> şi <span
class="math inline">\(u \neq 0\)</span>. Din (i) şi (ii) rezultă că
<span class="math inline">\(h^{-1}(L) \, \trianglelefteq\,
K\)</span>.</p>
<p>3) Dacă <span class="math inline">\(0 \neq X \leq L_1 \cap
L_2\)</span> atunci <span class="math inline">\(X \subseteq L_1\)</span>
ceea ce implică <span class="math inline">\(0 \neq X \cap K_1 \leq
L_1\)</span>. Dar cum <span class="math inline">\(X \subseteq
L_2\)</span>, rezultă <span class="math inline">\(0 \neq (X \cap K_1)
\cap L_2 = X \cap (K_1 \cap K_2)\)</span>, şi deci <span
class="math inline">\(K_1 \cap K_2 \, \trianglelefteq\, L_1 \cap
L_2\)</span>. ◻</p>
</div>
<div class="proposition">
<p><strong>Propoziţie 2.9</strong>. <em>Fie <span
class="math inline">\((K_\lambda)_{\lambda \in \Lambda}\)</span>, <span
class="math inline">\((L_\lambda)_{\lambda \in \Lambda}\)</span> două
familii de submodule ale lui <span class="math inline">\(M\)</span>.
Dacă <span class="math inline">\((K_\lambda)_{\lambda \in
\Lambda}\)</span> este familie independentă în <span
class="math inline">\(M\)</span> şi <span
class="math inline">\(K_\lambda \, \trianglelefteq\, L_\lambda\)</span>
pentru orice <span class="math inline">\(\lambda \in \Lambda\)</span>,
atunci <span class="math inline">\((L_\lambda)_{\lambda \in
\Lambda}\)</span> este familie independentă în <span
class="math inline">\(M\)</span> şi <span
class="math inline">\((\oplus_{\lambda \in \Lambda} K_\lambda) \,
\trianglelefteq\,
(\oplus_{\lambda \in \Lambda} L_\lambda)\)</span>.</em></p>
</div>
<div class="proof">
<p><em>Proof.</em> <br />
Fie <span class="math inline">\(K_1 \, \trianglelefteq\, L_1\)</span>,
<span class="math inline">\(K_2 \, \trianglelefteq\, L_2\)</span> astfel
încât <span class="math inline">\(K_1 \cap K_2 = 0\)</span>. Din 1.8(3)
rezultă că <span class="math inline">\(0 \, \trianglelefteq\, L_1 \cap
L_2\)</span>, adică <span class="math inline">\(L_1 \cap L_2 =
0\)</span>.</p>
<p>Fie proiecţiile canonice <span class="math inline">\(\pi_1 : L_1
\oplus L_2 \to L_1\)</span>, <span class="math inline">\(\pi_2 : L_1
\oplus L_2 \to L_2\)</span>. Cum <span class="math inline">\(K_1 \,
\trianglelefteq\, L_1\)</span>, <span class="math inline">\(K_2 \,
\trianglelefteq\, L_2\)</span> rezultă că</p>
<p><span class="math display">\[\pi_1^{-1}(K_1)
  = K_1 \oplus 0 \, \trianglelefteq\, L_1 \oplus L_2,\]</span> şi <span
class="math display">\[\pi_2^{-1}(K_2)
  = 0 \oplus K_2 \, \trianglelefteq\, L_1 \oplus L_2.\]</span></p>
<p>Deci <span class="math display">\[K_1 \oplus K_2
  = (\pi_1^{-1}(K_1)) \cap (\pi_2^{-1}(K_2))
  \, \trianglelefteq\, L_1 \oplus L_2.\]</span></p>
<p>Prin inducţie se obţine afirmaţia pentru mulţimi finite. În cazul
general, fie <span class="math inline">\(0 \neq m \in \oplus_{\lambda
\in \Lambda} L_\lambda\)</span>. Atunci există o mulţime finită <span
class="math inline">\(\Lambda_0 \subseteq \Lambda\)</span> cu <span
class="math inline">\(m \in \oplus_{\lambda \in \Lambda_0}
L_\lambda\)</span>. Cum <span class="math inline">\((\oplus_{\lambda \in
\Lambda_0} K_\lambda) \, \trianglelefteq\,
(\oplus_{\lambda \in \Lambda_0} L_\lambda)\)</span>, există <span
class="math inline">\(r \in R\)</span> astfel încât <span
class="math inline">\(rm \in (\oplus_{\lambda \in \Lambda_0} K_\lambda)
\setminus \{0\}
\subseteq (\oplus_{\lambda \in \Lambda} K_\lambda) \setminus
\{0\}\)</span>. Rezultă că <span class="math inline">\((\oplus_{\lambda
\in \Lambda} K_\lambda) \, \trianglelefteq\,
(\oplus_{\lambda \in \Lambda} L_\lambda)\)</span>. ◻</p>
</div>
<div class="proposition">
<p><strong>Propoziţie 2.10</strong>. <em>Fie <span
class="math inline">\(N\)</span> un submodul al lui <span
class="math inline">\(M\)</span>. Atunci există un submodul <span
class="math inline">\(Q\)</span>, <span class="math inline">\(N
\subseteq Q \subseteq M\)</span>, astfel încât <span
class="math inline">\(Q\)</span> este o extensie esenţială maximală a
lui <span class="math inline">\(N\)</span> conţinută în <span
class="math inline">\(M\)</span>.</em></p>
</div>
<div class="proof">
<p><em>Proof.</em> <br />
Fie <span class="math inline">\(\mathfrak{S} = \{ L \leq M ; \; N
\subseteq L \subseteq M, \; N \, \ulcorner \, L \}\)</span>, <span
class="math inline">\(\mathfrak{S}\)</span> cu relaţia de ordine
incluziunea. <span class="math inline">\(\mathfrak{S} \neq
\varnothing\)</span> deoarece <span class="math inline">\(N \in
\mathfrak{S}\)</span>. Fie <span
class="math inline">\((L_\lambda)_{\lambda \in \Lambda}\)</span> o
familie total ordonată de elemente din <span
class="math inline">\(\mathfrak{S}\)</span> şi <span
class="math display">\[L := \bigcup_{\lambda \in \Lambda}
L_\lambda.\]</span> Evident <span class="math inline">\(L \leq
M_R\)</span>.</p>
<p>Fie <span class="math inline">\(x \in L \setminus \{0\}\)</span>.
Atunci există <span class="math inline">\(\lambda_0 \in \Lambda\)</span>
cu <span class="math inline">\(x \in L_{\lambda_0}\)</span>. Cum <span
class="math inline">\(N\)</span> este esenţial în <span
class="math inline">\(L_{\lambda_0}\)</span>, rezultă că există <span
class="math inline">\(r \in R\)</span> astfel încât <span
class="math inline">\(xr \in N\)</span> şi <span
class="math inline">\(xr \neq 0\)</span>, de unde obţinem că <span
class="math inline">\(L\)</span> este extensie esenţială a lui <span
class="math inline">\(N\)</span>. Deci <span
class="math inline">\(\mathfrak{S}\)</span> este inductivă şi, conform
lemei lui Zorn, <span class="math inline">\(\mathfrak{S}\)</span> admite
un element maximal <span class="math inline">\(Q\)</span> care satisface
condiţiile cerute. ◻</p>
</div>
<div class="definition">
<p><strong>Definiţie 2.11</strong>. Fie <span
class="math inline">\(M\)</span> un <span
class="math inline">\(R\)</span>-modul la dreapta şi <span
class="math inline">\(N \leq M_R\)</span>. Un submodul <span
class="math inline">\(K \leq M_R\)</span> se numeşte <em>complement</em>
al lui <span class="math inline">\(N\)</span> în <span
class="math inline">\(M\)</span> dacă <span
class="math inline">\(K\)</span> este un submodul maximal al lui <span
class="math inline">\(M\)</span> cu proprietatea că <span
class="math inline">\(K \cap N = 0\)</span>. Un submodul <span
class="math inline">\(K \leq M_R\)</span> se numeşte <em>submodul
complement al lui <span class="math inline">\(M\)</span></em> dacă
există <span class="math inline">\(N \leq M_R\)</span> astfel încât
<span class="math inline">\(K\)</span> este complement al lui <span
class="math inline">\(N\)</span> în <span
class="math inline">\(M\)</span>.</p>
</div>
<div class="remark">
<p><em>Observaţie 2.12</em>. Mulţimea <span
class="math display">\[\widetilde{\mathfrak{S}}
  = \{\,L \leq M_R \mid N \cap L = 0\,\}\]</span> este inductivă şi,
aplicând lema lui Zorn, rezultă că există un complement al lui <span
class="math inline">\(N\)</span> în <span
class="math inline">\(M\)</span>. În particular, <span
class="math inline">\(0\)</span> şi <span
class="math inline">\(M\)</span> sunt submodule complement ale lui <span
class="math inline">\(M\)</span>.</p>
</div>
<div class="proposition">
<p><strong>Propoziţie 2.13</strong>. <em>Fie <span
class="math inline">\(M_R\)</span>, <span class="math inline">\(N \leq
M_R\)</span> şi <span class="math inline">\(K \leq M_R\)</span>, <span
class="math inline">\(K\)</span> un complement al lui <span
class="math inline">\(N\)</span> în <span
class="math inline">\(M\)</span>. Există un complement <span
class="math inline">\(Q\)</span> al lui <span
class="math inline">\(K\)</span> în <span
class="math inline">\(M\)</span> astfel încât <span
class="math inline">\(N \subseteq Q\)</span>. Mai mult, <span
class="math inline">\(Q\)</span> este o extensie esenţială maximală a
lui <span class="math inline">\(N\)</span> în <span
class="math inline">\(M\)</span>.</em></p>
</div>
<div class="proof">
<p><em>Proof.</em> Se observă uşor că mulţimea <span
class="math display">\[\widetilde{\mathfrak{S}}
  = \{\,L \leq M_R \mid K \cap L = 0,\; N \subseteq L\,\}\]</span> este
inductivă şi lema lui Zorn asigură existenţa lui <span
class="math inline">\(Q\)</span>.</p>
<p>Fie <span class="math inline">\(L\)</span> un submodul nenul al lui
<span class="math inline">\(Q\)</span> astfel încât <span
class="math inline">\(L \cap N = 0\)</span>. Fie <span
class="math inline">\(K_1 = L + K\)</span>. Este clar că <span
class="math inline">\(K \subseteq K_1\)</span>. Dacă <span
class="math inline">\(x \in N \cap (L + K)\)</span>, atunci <span
class="math inline">\(x = y + z\)</span> cu <span
class="math inline">\(y \in L\)</span>, <span class="math inline">\(z
\in K\)</span>. Dar <span class="math inline">\(z = x - y \in
Q\)</span>. Cum <span class="math inline">\(Q \cap K = 0\)</span>,
rezultă <span class="math inline">\(z = 0\)</span> şi deci <span
class="math inline">\(x = y\)</span>. Din egalitatea <span
class="math inline">\(L \cap N = 0\)</span> deducem <span
class="math inline">\(x = y = 0\)</span> şi deci <span
class="math inline">\(N \cap (L + K) = 0\)</span>, ceea ce contrazice
faptul că <span class="math inline">\(K\)</span> este un complement al
lui <span class="math inline">\(N\)</span> în <span
class="math inline">\(M\)</span>. Obţinem <span class="math inline">\(L
\cap N \neq 0\)</span> pentru orice <span class="math inline">\(0 \neq L
\leq Q\)</span>, de unde <span class="math inline">\(Q\)</span> este
extensie esenţială a lui <span class="math inline">\(N\)</span>.</p>
<p>Presupunem că există <span class="math inline">\(Q&#39; \leq
M_R\)</span> cu <span class="math inline">\(N \trianglelefteq
Q&#39;\)</span> şi <span class="math inline">\(Q \subsetneq
Q&#39;\)</span>. Cum <span class="math inline">\(Q&#39;\)</span> este
complement al lui <span class="math inline">\(K\)</span>, rezultă <span
class="math inline">\(Q&#39; \cap K \neq 0\)</span>. Dar <span
class="math inline">\(N \cap (Q&#39; \cap K) = 0\)</span> şi <span
class="math inline">\(0 \neq Q&#39; \cap K \leq Q&#39;\)</span>,
contradicţie cu <span class="math inline">\(N \trianglelefteq
Q&#39;\)</span>. Rezultă că <span class="math inline">\(Q\)</span> este
extensie esenţială maximală a lui <span class="math inline">\(N\)</span>
în <span class="math inline">\(M\)</span>. ◻</p>
</div>
<div class="definition">
<p><strong>Definiţie 2.14</strong>. Un submodul <span
class="math inline">\(N\)</span> al lui <span
class="math inline">\(M_R\)</span> se numeşte <em>închis</em> dacă <span
class="math inline">\(N\)</span> nu are nicio extensie esenţială în
<span class="math inline">\(M\)</span> proprie (diferită de <span
class="math inline">\(N\)</span>).</p>
</div>
<div class="corollary">
<p><strong>Corolar 2.15</strong>. <em>Fie <span
class="math inline">\(M_R\)</span> un <span
class="math inline">\(R\)</span>-modul. Submodulele complement ale lui
<span class="math inline">\(M\)</span> coincid cu submodulele închise
ale lui <span class="math inline">\(M\)</span>.</em></p>
</div>
<div class="proof">
<p><em>Proof.</em> Din 1.13 rezultă imediat că orice submodul închis al
lui <span class="math inline">\(M\)</span> este un submodul complement
al lui <span class="math inline">\(M\)</span>.</p>
<p>Invers, fie <span class="math inline">\(K\)</span> un submodul
complement al lui <span class="math inline">\(M_R\)</span>. Rezultă că
există <span class="math inline">\(N \leq M_R\)</span> astfel încât
<span class="math inline">\(K\)</span> este un complement al lui <span
class="math inline">\(N\)</span> în <span
class="math inline">\(M\)</span>. Presupunem că <span
class="math inline">\(K\)</span> are o extensie esenţială în <span
class="math inline">\(M\)</span> proprie, adică există <span
class="math inline">\(K&#39; \leq M_R\)</span> cu <span
class="math inline">\(K \trianglelefteq K&#39;\)</span> şi <span
class="math inline">\(K \subsetneq K&#39;\)</span>. Atunci <span
class="math inline">\(K&#39; \cap N \neq 0\)</span>, din maximalitatea
lui <span class="math inline">\(K\)</span>, iar cum <span
class="math inline">\(K \trianglelefteq K&#39;\)</span>, rezultă că
<span class="math display">\[K \cap K&#39; \cap N \neq 0,\]</span>
contradicţie. ◻</p>
</div>
<div class="corollary">
<p><strong>Corolar 2.16</strong>. <em>Fie <span
class="math inline">\(N\)</span> un submodul al lui <span
class="math inline">\(M_R\)</span>. Dacă <span
class="math inline">\(K\)</span> este un complement al lui <span
class="math inline">\(N\)</span> în <span
class="math inline">\(M\)</span>, atunci:</em></p>
<ol>
<li><p><em><span class="math inline">\((N + K) \trianglelefteq
M_R\)</span>.</em></p></li>
<li><p><em>Morfismul canonic <span class="math inline">\(\pi_K \circ i_N
: N \to M/K\)</span> este monomorfism esenţial.</em></p></li>
</ol>
</div>
<div class="proof">
<p><em>Proof.</em> (1) Fie <span class="math inline">\(x \in M \setminus
\{0\}\)</span>. Dacă <span class="math inline">\(x \notin K\)</span>,
atunci <span class="math inline">\(K + Rx \neq K\)</span> şi deci <span
class="math inline">\(N \cap (K + Rx) \neq 0\)</span>. Fie <span
class="math inline">\(y \in N \cap (K + Rx)\)</span>, <span
class="math inline">\(y \neq 0\)</span>. Există <span
class="math inline">\(z \in K\)</span>, <span class="math inline">\(r
\in R\)</span> cu <span class="math inline">\(y = z + rx\)</span>. Dacă
<span class="math inline">\(rx = 0\)</span>, atunci <span
class="math inline">\(y = z\)</span> şi cum <span
class="math inline">\(N \cap K = 0\)</span> rezultă <span
class="math inline">\(y = 0\)</span>, contradicţie. Deci <span
class="math inline">\(rx \neq 0\)</span> şi, cum <span
class="math inline">\(rx = y - z\)</span>, obţinem <span
class="math inline">\(rx \in N + K\)</span>, ceea ce ne arată că <span
class="math inline">\((N + K) \trianglelefteq M_R\)</span>.</p>
<p>(2) <span class="math inline">\(\mathrm{Im}(\pi_K \circ i_N) = (N +
K)/K\)</span>. Fie <span class="math inline">\(L/K\)</span> un submodul
nenul al lui <span class="math inline">\(M/K\)</span>. Atunci <span
class="math display">\[\frac{N + K}{K} \cap \frac{L}{K}
   = \frac{(N + K) \cap L}{K}
   = \frac{N \cap L + K}{K}.\]</span> Cum <span
class="math inline">\(K\)</span> este un complement al lui <span
class="math inline">\(N\)</span>, rezultă că <span
class="math inline">\(N \cap L \neq 0\)</span> şi deci <span
class="math display">\[\frac{N \cap L + K}{K} \neq 0,\]</span> ceea ce
ne arată că <span class="math inline">\(\pi_K \circ i_N\)</span> este
monomorfism esenţial. ◻</p>
</div>
<h1 id="module-injective">Module injective</h1>
<h2 id="module-injective-1">Module injective</h2>
<p>Fie <span class="math inline">\(Q\)</span> şi <span
class="math inline">\(M\)</span> două <span
class="math inline">\(R\)</span>-module drepte. <span
class="math inline">\(Q\)</span> se numeşte <em><span
class="math inline">\(M\)</span>-injectiv</em> dacă pentru orice
monomorfism <span class="math inline">\(u : M&#39; \to M\)</span> şi
orice morfism <span class="math inline">\(f : M&#39; \to Q\)</span>,
există <span class="math inline">\(g : M \to Q\)</span> astfel încât
<span class="math inline">\(g \circ u = f\)</span>, adică diagrama</p>
<p><img src="diagrams/diagram_0.svg" alt="Commutative diagram" style="max-width: 100%; height: auto; display: block; margin: 1em auto;"></p>
<p>este comutativă.</p>
<p>Această proprietate este echivalentă cu condiţia ca aplicaţia <span
class="math display">\[\mathop{\mathrm{Hom}}(u,Q) :
\mathop{\mathrm{Hom}}(M,Q) \longrightarrow
\mathop{\mathrm{Hom}}(M&#39;,Q)\]</span> să fie surjectivă pentru orice
monomorfism <span class="math inline">\(u : M&#39; \to M\)</span>. Cum
functorul <span
class="math inline">\(\mathop{\mathrm{Hom}}(-,Q)\)</span> este exact la
stânga, rezultă că <span class="math inline">\(Q\)</span> este <span
class="math inline">\(M\)</span>-injectiv dacă şi numai dacă <span
class="math inline">\(\mathop{\mathrm{Hom}}(-,Q)\)</span> este exact în
raport cu orice şir exact de forma <span class="math display">\[0
\longrightarrow M&#39; \longrightarrow M \longrightarrow M&#39;&#39;
\longrightarrow 0.\]</span></p>
<p><span class="math inline">\(R\)</span>-modulul <span
class="math inline">\(Q\)</span> se numeşte <em>quasi-injectiv</em> (sau
<em>self-injectiv</em>) dacă este <span
class="math inline">\(Q\)</span>-injectiv. Dacă <span
class="math inline">\(Q\)</span> este <span
class="math inline">\(M\)</span>-injectiv pentru orice <span
class="math inline">\(R\)</span>-modul <span
class="math inline">\(M\)</span>, atunci <span
class="math inline">\(Q\)</span> se numeşte <em>injectiv</em>.</p>
<p>2.1.1 Propoziţie</p>
<div class="proposition">
<p><strong>Propoziţie 3.1</strong>. <em>Fie <span
class="math inline">\(Q\)</span> şi <span
class="math inline">\(M\)</span> două <span
class="math inline">\(R\)</span>-module. Următoarele afirmaţii sunt
echivalente:</em></p>
<ol>
<li><p><em><span class="math inline">\(Q\)</span> este <span
class="math inline">\(M\)</span>-injectiv.</em></p></li>
<li><p><em>Pentru orice submodul <span class="math inline">\(N\)</span>
al lui <span class="math inline">\(M\)</span> şi orice morfism <span
class="math inline">\(f : N \to Q\)</span>, există <span
class="math inline">\(g : M \to Q\)</span> astfel încât <span
class="math inline">\(g_{\mid N} = f\)</span>.</em></p></li>
<li><p><em>Pentru orice submodul esenţial <span
class="math inline">\(N\)</span> al lui <span
class="math inline">\(M\)</span> şi orice morfism <span
class="math inline">\(f : N \to Q\)</span>, există <span
class="math inline">\(g : M \to Q\)</span> astfel încât <span
class="math inline">\(g_{\mid N} = f\)</span>.</em></p></li>
</ol>
</div>
<div class="proof">
<p><em>Proof.</em> Implicaţiile <span class="math inline">\((1)
\Rightarrow (2)\)</span> şi <span class="math inline">\((2) \Rightarrow
(3)\)</span> sunt evidente.</p>
<p><span class="math inline">\((2) \Rightarrow (1)\)</span>. Fie <span
class="math inline">\(M&#39;_R\)</span>, <span class="math inline">\(0
\longrightarrow M&#39; \xrightarrow{u} M\)</span> şi <span
class="math inline">\(f : M&#39; \to Q\)</span>. Atunci <span
class="math inline">\(u(M&#39;) \leq M\)</span>. Considerăm <span
class="math inline">\(i : u(M&#39;) \to M\)</span> injecţia canonică şi
<span class="math inline">\(\bar{u} : M&#39; \to u(M&#39;)\)</span>
izomorfismul indus de <span class="math inline">\(u\)</span>. Există
<span class="math inline">\(g : M \to Q\)</span> astfel încât <span
class="math inline">\(g \circ i = f \circ \bar{u}^{-1}\)</span>. Atunci
<span class="math display">\[g \circ i \circ \bar{u} = f
\quad\text{şi deci}\quad
g \circ u = f.\]</span></p>
<p>Diagrama corespunzătoare este</p>
<p><img src="diagrams/diagram_1.svg" alt="Commutative diagram" style="max-width: 100%; height: auto; display: block; margin: 1em auto;"></p>
<p><span class="math inline">\((3) \Rightarrow (2)\)</span>. Fie <span
class="math inline">\(N\)</span> un submodul al lui <span
class="math inline">\(M\)</span> şi <span
class="math inline">\(K\)</span> un complement al lui <span
class="math inline">\(N\)</span> în <span
class="math inline">\(M\)</span>. Atunci <span class="math inline">\((N
\oplus K) \trianglelefteq M\)</span>. Fie <span class="math inline">\(h
: N \oplus K \to Q\)</span>, definit prin <span
class="math inline">\(h(n+k) = f(n)\)</span> pentru orice <span
class="math inline">\(n \in N\)</span>, <span class="math inline">\(k
\in K\)</span>. Cum <span class="math inline">\(N \cap K = 0\)</span>,
aplicaţia <span class="math inline">\(h\)</span> este bine definită.
Există <span class="math inline">\(g : M \to Q\)</span> astfel încât
<span class="math inline">\(g_{\mid N \oplus K} = h\)</span> şi deci
<span class="math inline">\(g_{\mid N} = h_{\mid N} = f\)</span>.</p>
<p>Aceasta se poate reprezenta prin diagrama
<img src="diagrams/diagram_2.svg" alt="Commutative diagram" style="max-width: 100%; height: auto; display: block; margin: 1em auto;"> ◻</p>
</div>
<div class="proposition">
<p><strong>Propoziţie 3.2</strong>. <em>Fie <span
class="math inline">\((M_\alpha)_{\alpha \in \Lambda}\)</span> o familie
de <span class="math inline">\(R\)</span>-module şi <span
class="math inline">\(M\)</span> un <span
class="math inline">\(R\)</span>-modul. Atunci <span
class="math inline">\(\displaystyle \prod_{\alpha \in \Lambda}
M_\alpha\)</span> este <span class="math inline">\(M\)</span>-injectiv
dacă şi numai dacă <span class="math inline">\(M_\alpha\)</span> este
<span class="math inline">\(M\)</span>-injectiv pentru orice <span
class="math inline">\(\alpha \in \Lambda\)</span>.</em></p>
</div>
<div class="proof">
<p><em>Proof.</em> Fie <span class="math inline">\(N\)</span> un
submodul al lui <span class="math inline">\(M\)</span>. Notăm <span
class="math inline">\(P = \displaystyle\prod_{\alpha \in \Lambda}
M_\alpha\)</span> şi <span class="math inline">\(\pi_\alpha : P \to
M_\alpha\)</span> proiecţiile canonice, pentru orice <span
class="math inline">\(\alpha \in \Lambda\)</span>.</p>
<p><span class="math inline">\(&quot;\Leftarrow&quot;\)</span>
Considerând un morfism <span class="math inline">\(f : N \to P\)</span>,
avem că morfismele <span class="math inline">\(\pi_\alpha \circ f : N
\to M_\alpha\)</span> pot fi extinse la <span
class="math inline">\(g_\alpha : M \to M_\alpha\)</span>. Există <span
class="math inline">\(g : M \to P\)</span> astfel încât <span
class="math inline">\(g_{\mid N} = f\)</span>.</p>
<p><img src="diagrams/diagram_3.svg" alt="Commutative diagram" style="max-width: 100%; height: auto; display: block; margin: 1em auto;"></p>
<p><span class="math inline">\(&quot;\Rightarrow&quot;\)</span> Fie
<span class="math inline">\(\forall \alpha \in \Lambda\)</span> şi <span
class="math inline">\(f : N \to M_\alpha\)</span>. Considerând
incluziunea canonică <span class="math inline">\(\varepsilon_\alpha :
M_\alpha \to P\)</span>, cum <span class="math inline">\(P\)</span> este
<span class="math inline">\(M\)</span>-injectiv, există <span
class="math inline">\(g : M \to P\)</span> care îl extinde pe <span
class="math inline">\(\varepsilon_\alpha \circ f : N \to P\)</span>.
Atunci <span class="math inline">\(\varepsilon_\alpha : M_\alpha \to
P\)</span> îl extinde pe <span class="math inline">\(f\)</span> şi deci
<span class="math inline">\(M_\alpha\)</span> este <span
class="math inline">\(M\)</span>-injectiv.</p>
<p><img src="diagrams/diagram_4.svg" alt="Commutative diagram" style="max-width: 100%; height: auto; display: block; margin: 1em auto;"> ◻</p>
</div>
<div class="corollary">
<p><strong>Corolar 3.3</strong>. </p>
<ol>
<li><p><em>Fie <span class="math inline">\((Q_\alpha)_{\alpha \in
\Lambda}\)</span> o familie de <span
class="math inline">\(R\)</span>-module. Atunci <span
class="math inline">\(\prod_{\alpha \in \Lambda} Q_\alpha\)</span> este
injectiv dacă şi numai dacă <span
class="math inline">\(Q_\alpha\)</span> este injectiv pentru orice <span
class="math inline">\(\alpha\in\Lambda\)</span>.</em></p></li>
<li><p><em><span class="math inline">\(Q_1 \oplus Q_2\)</span> este
<span class="math inline">\(R\)</span>-modul injectiv dacă şi numai dacă
<span class="math inline">\(Q_i\)</span> este injectiv pentru <span
class="math inline">\(i=1,2\)</span>. În particular, un sumand direct al
unui modul injectiv este injectiv.</em></p></li>
</ol>
</div>
<div class="proposition">
<p><strong>Propoziţie 3.4</strong>. <em>Fie <span
class="math inline">\(Q\)</span> un <span
class="math inline">\(R\)</span>-modul.</em></p>
<ol>
<li><p><em>Dacă <span class="math inline">\(0 \to M&#39; \xrightarrow{f}
M \xrightarrow{g} M&#39;&#39; \to 0\)</span> este un şir exact de <span
class="math inline">\(R\)</span>-module şi <span
class="math inline">\(Q\)</span> este <span
class="math inline">\(M\)</span>-injectiv, atunci <span
class="math inline">\(Q\)</span> este <span
class="math inline">\(M&#39;\)</span>-injectiv şi <span
class="math inline">\(M&#39;&#39;\)</span>-injectiv.</em></p></li>
<li><p><em>Dacă <span class="math inline">\((M_\alpha)_{\alpha \in
\Lambda}\)</span> este o familie de submodule ale lui <span
class="math inline">\(M\)</span> astfel încât <span
class="math inline">\(M = \sum_{\alpha\in\Lambda} M_\alpha\)</span> şi
<span class="math inline">\(Q\)</span> este <span
class="math inline">\(M_\alpha\)</span>-injectiv pentru orice <span
class="math inline">\(\alpha\)</span>, atunci <span
class="math inline">\(Q\)</span> este <span
class="math inline">\(M\)</span>-injectiv.</em></p></li>
<li><p><em>Fie <span
class="math inline">\((N_\alpha)_{\alpha\in\Lambda}\)</span> o familie
de <span class="math inline">\(R\)</span>-module. Atunci <span
class="math inline">\(Q\)</span> este <span
class="math inline">\(\bigoplus_{\alpha\in\Lambda}
N_\alpha\)</span>-injectiv dacă şi numai dacă <span
class="math inline">\(Q\)</span> este <span
class="math inline">\(N_\alpha\)</span>-injectiv pentru orice <span
class="math inline">\(\alpha\in\Lambda\)</span>.</em></p></li>
</ol>
</div>
<div class="proof">
<p><em>Proof.</em> Pentru a arăta că <span
class="math inline">\(Q\)</span> este <span
class="math inline">\(M&#39;\)</span>-injectiv, considerăm <span
class="math inline">\(N\)</span> un submodul al lui <span
class="math inline">\(M&#39;\)</span> și <span
class="math inline">\(\varphi : N \rightarrow Q\)</span> un morfism de
<span class="math inline">\(R\)</span>-module. Cum <span
class="math inline">\(Q\)</span> este <span
class="math inline">\(M\)</span>-injectiv, există <span
class="math inline">\(\phi : M \to Q\)</span> astfel încât <span
class="math inline">\(g \circ f\!\mid_{N} = \varphi\)</span> și deci
<span class="math inline">\(\psi \circ f : M&#39; \to Q\)</span> este un
morfism care îl extinde pe <span class="math inline">\(\varphi\)</span>.
<img src="diagrams/diagram_5.svg" alt="Commutative diagram" style="max-width: 100%; height: auto; display: block; margin: 1em auto;"></p>
<p>Fie <span class="math inline">\(h : L \to M&#39;&#39;\)</span> un
monomorfism. Putem presupune, fără a restrânge generalitatea, că <span
class="math inline">\(M&#39; \le M\)</span> și <span
class="math inline">\(M&#39;&#39; = M / M&#39;\)</span>. Cum <span
class="math inline">\(L \cong h(L) \le M&#39;&#39;\)</span>, există
<span class="math inline">\(P \le M\)</span>, <span
class="math inline">\(M&#39; \subseteq P\)</span> astfel încât <span
class="math inline">\(h(L) = P / M&#39;\)</span> și deci <span
class="math inline">\(L \cong P/M&#39;\)</span>. Obținem diagrama
comutativă:</p>
<p><img src="diagrams/diagram_6.svg" alt="Commutative diagram" style="max-width: 100%; height: auto; display: block; margin: 1em auto;"></p>
<p>Cum <span class="math inline">\(Q\)</span> este <span
class="math inline">\(M\)</span>-injectiv, aplicând functorul <span
class="math inline">\(\mathop{\mathrm{Hom}}(-,Q)\)</span> obținem
diagrama comutativă:</p>
<p><img src="diagrams/diagram_7.svg" alt="Commutative diagram" style="max-width: 100%; height: auto; display: block; margin: 1em auto;"></p>
<p>Obținem că <span class="math inline">\(h^{*} =
\mathop{\mathrm{Hom}}(h,Q)\)</span> este epimorfism, ceea ce arată că
<span class="math inline">\(Q\)</span> este <span
class="math inline">\(M&#39;&#39;\)</span>-injectiv.</p>
<p>2) Fie <span class="math inline">\(N\)</span> un submodul al lui
<span class="math inline">\(M\)</span> şi <span class="math inline">\(f
: N \to Q\)</span> un morfism de <span
class="math inline">\(R\)</span>-module. Considerăm mulţimea <span
class="math display">\[\mathfrak{S} = \{(L,h) \mid N \le L \le M,\; h :
L \to Q,\; h\!\mid_{N} = f\}.\]</span> Cum <span
class="math inline">\((N,f) \in \mathfrak{S}\)</span>, avem <span
class="math inline">\(\mathfrak{S} \ne \varnothing\)</span>. Definim pe
<span class="math inline">\(\mathfrak{S}\)</span> relaţia de ordine
<span class="math inline">\((L_1,h_1) \preccurlyeq (L_2,h_2)\)</span>
dacă şi numai dacă <span class="math inline">\(L_1 \le L_2\)</span> şi
<span class="math inline">\(h_2\!\mid_{L_1} = h_1\)</span>. Se observă
că <span class="math inline">\(\mathfrak{S}\)</span> este inductivă şi,
din lema lui Zorn, rezultă că există <span
class="math inline">\((L_0,g_0)\)</span> element maximal al lui <span
class="math inline">\(\mathfrak{S}\)</span>. Pentru a arăta că <span
class="math inline">\(L_0 = M\)</span> este suficient să arătăm că <span
class="math inline">\(M_\alpha \le L_0\)</span> pentru orice <span
class="math inline">\(\alpha \in \Lambda\)</span>.</p>
<p>Considerând diagrama</p>
<p><img src="diagrams/diagram_8.svg" alt="Commutative diagram" style="max-width: 100%; height: auto; display: block; margin: 1em auto;"></p>
<p>rezultă că există <span class="math inline">\(h_\alpha : M_\alpha \to
Q\)</span> astfel încât <span class="math inline">\(h_\alpha \circ
i_\alpha = g_0 \circ i_\alpha\)</span>. Definim <span
class="math inline">\(h^{*} : L_0 + M_\alpha \to Q\)</span>, <span
class="math inline">\(h^{*}(l + m_\alpha) = g_0(l) +
h_\alpha(m_\alpha)\)</span>, pentru orice <span class="math inline">\(l
\in L_0\)</span>, <span class="math inline">\(m_\alpha \in
M_\alpha\)</span>. Dacă <span class="math inline">\(l + m_\alpha =
0\)</span>, atunci <span class="math inline">\(l = -m_\alpha \in L_0
\cap M_\alpha\)</span> şi deci <span class="math inline">\(h^{*}(l +
m_\alpha) = g_0(l) + h_\alpha(l)\)</span>, ceea ce arată că <span
class="math inline">\(h^{*}\)</span> este bine definită. Atunci <span
class="math inline">\((L_0 + M_\alpha, h^{*}) \in \mathfrak{S}\)</span>
şi, cum <span class="math inline">\((L_0,g_0) \preccurlyeq (L_0 +
M_\alpha, h^{*})\)</span>, din maximalitatea lui <span
class="math inline">\((L_0,g_0)\)</span> rezultă că <span
class="math inline">\(L_0 = L_0 + M_\alpha\)</span>, adică <span
class="math inline">\(M_\alpha \le L_0\)</span> pentru orice <span
class="math inline">\(\alpha \in \Lambda\)</span>.</p>
<p>3) „<span class="math inline">\(\Rightarrow\)</span>” Cum <span
class="math inline">\(N_\alpha \le N\)</span> şi <span
class="math inline">\(Q\)</span> este <span
class="math inline">\(N\)</span>-injectiv, avem că <span
class="math inline">\(Q\)</span> este <span
class="math inline">\(N_\alpha\)</span>-injectiv pentru orice <span
class="math inline">\(\alpha \in \Lambda\)</span>.</p>
<p>„<span class="math inline">\(\Leftarrow\)</span>” Fie <span
class="math inline">\(N&#39;_\alpha = i_\alpha(N_\alpha)\)</span>. Cum
<span class="math inline">\(Q\)</span> este <span
class="math inline">\(N_\alpha\)</span>-injectiv şi <span
class="math inline">\(N&#39;_\alpha \cong N_\alpha\)</span>, rezultă că
<span class="math inline">\(Q\)</span> este <span
class="math inline">\(N&#39;_\alpha\)</span>-injectiv. Apoi aplicăm
(2). ◻</p>
</div>
<div class="corollary">
<p><strong>Corolar 3.5</strong>. </p>
<ol>
<li><p><em><span class="math inline">\(Q_1 \oplus Q_2\)</span> este
<span class="math inline">\(R\)</span>-modul quasi-injectiv dacă şi
numai dacă <span class="math inline">\(Q_i\)</span> este <span
class="math inline">\(Q_j\)</span>-injectiv pentru orice <span
class="math inline">\(i,j = 1,2\)</span>. În particular, un sumand
direct al unui modul quasi-injectiv este quasi-injectiv.</em></p></li>
<li><p><em><span class="math inline">\(Q^{n}\)</span> este <span
class="math inline">\(R\)</span>-modul quasi-injectiv dacă şi numai dacă
<span class="math inline">\(Q\)</span> este
quasi-injectiv.</em></p></li>
</ol>
</div>
<div class="corollary">
<p><strong>Corolar 3.6</strong>. <em>Fie <span
class="math inline">\(Q\)</span> şi <span
class="math inline">\(M\)</span> două <span
class="math inline">\(R\)</span>-module. Atunci <span
class="math inline">\(Q\)</span> este <span
class="math inline">\(M\)</span>-injectiv dacă şi numai dacă <span
class="math inline">\(Q\)</span> este <span
class="math inline">\(mR\)</span>-injectiv pentru orice <span
class="math inline">\(m \in M\)</span>.</em></p>
</div>
<div class="proof">
<p><em>Proof.</em> „<span class="math inline">\(\Rightarrow\)</span>”
este evident.</p>
<p>„<span class="math inline">\(\Leftarrow\)</span>” Cum <span
class="math inline">\(M = \sum_{m \in M} mR\)</span>, din 2.1.4(2)
rezultă că <span class="math inline">\(Q\)</span> este <span
class="math inline">\(M\)</span>-injectiv. ◻</p>
</div>
<div id="thm:Baer-ro" class="theorem">
<p><strong>Teoremă 3.7</strong> (Criteriul lui Baer). <em>Pentru un
<span class="math inline">\(R\)</span>-modul <span
class="math inline">\(Q\)</span> următoarele afirmaţii sunt
echivalente:</em></p>
<ol>
<li><p><em><span class="math inline">\(Q\)</span> este
injectiv.</em></p></li>
<li><p><em><span class="math inline">\(Q\)</span> este <span
class="math inline">\(R\)</span>-injectiv.</em></p></li>
<li><p><em>Pentru orice ideal drept <span
class="math inline">\(I\)</span> al lui <span
class="math inline">\(R\)</span> şi orice morfism <span
class="math inline">\(f : I \to Q\)</span> există <span
class="math inline">\(x \in Q\)</span> astfel încât <span
class="math inline">\(f(a) = xa\)</span> pentru orice <span
class="math inline">\(a \in I\)</span>.</em></p></li>
</ol>
</div>
<div class="proof">
<p><em>Proof.</em> Implicaţia <span class="math inline">\((1)
\Rightarrow (2)\)</span> este evidentă.</p>
<p><span class="math inline">\((2) \Rightarrow (1)\)</span>. Fie <span
class="math inline">\(M\)</span> un <span
class="math inline">\(R\)</span>-modul şi <span class="math inline">\(x
\in M\)</span>. Cum <span class="math inline">\(\varphi_x : R \to
xR\)</span>, <span class="math inline">\(\varphi_x(a) = xa\)</span>
pentru orice <span class="math inline">\(a \in R\)</span>, este morfism
surjectiv de <span class="math inline">\(R\)</span>-module, rezultă că
<span class="math inline">\(R / \mathop{\mathrm{Ker}}\varphi_x \cong
xR\)</span>. Cum <span class="math inline">\(Q\)</span> este <span
class="math inline">\(R\)</span>-injectiv, din 2.1.4(1) rezultă că <span
class="math inline">\(Q\)</span> este <span class="math inline">\(R /
\mathop{\mathrm{Ker}}\varphi_x\)</span>-injectiv şi deci <span
class="math inline">\(Q\)</span> este <span
class="math inline">\(xR\)</span>-injectiv pentru orice <span
class="math inline">\(x \in M\)</span>. Atunci, din 2.1.6 obţinem că
<span class="math inline">\(Q\)</span> este <span
class="math inline">\(M\)</span>-injectiv.</p>
<p><span class="math inline">\((2) \Rightarrow (3)\)</span>. Fie <span
class="math inline">\(I\)</span> un ideal drept al lui <span
class="math inline">\(R\)</span> şi <span class="math inline">\(f : I
\to Q\)</span>. Există <span class="math inline">\(g : R \to Q\)</span>
astfel încât <span class="math inline">\(g\!\mid_{I} = f\)</span>. Fie
<span class="math inline">\(x = g(1) \in Q\)</span>. Atunci <span
class="math inline">\(f(a) = g(a) = ag(1) = xa\)</span> pentru orice
<span class="math inline">\(a \in I\)</span>.</p>
<p><span class="math inline">\((3) \Rightarrow (2)\)</span>. Dacă pentru
un morfism <span class="math inline">\(f : I \to Q\)</span> există <span
class="math inline">\(x \in Q\)</span> cu <span
class="math inline">\(f(a) = xa\)</span> pentru orice <span
class="math inline">\(a \in I\)</span>, atunci, definind <span
class="math inline">\(g : R \to Q\)</span> prin <span
class="math inline">\(g(r) = xr\)</span> pentru orice <span
class="math inline">\(r \in R\)</span>, rezultă că <span
class="math inline">\(g\!\mid_{I} = f\)</span>. ◻</p>
</div>
<div class="definition">
<p><strong>Definiţie 3.8</strong>. </p>
<ol>
<li><p>Un <span class="math inline">\(R\)</span>-modul <span
class="math inline">\(Q\)</span> se numeşte <em>divizibil</em> dacă
pentru orice <span class="math inline">\(y \in Q\)</span> şi orice <span
class="math inline">\(a \in R\)</span> nendivizor al lui zero, există
<span class="math inline">\(x \in Q\)</span> astfel încât <span
class="math inline">\(ax = y\)</span>. Se verifică uşor că orice modul
factor al unui modul divizibil este divizibil.</p></li>
<li><p>Un domeniu de integritate comutativ se numeşte <em>PID-inel</em>
dacă orice ideal al său este principal.</p></li>
</ol>
</div>
<div class="proposition">
<p><strong>Propoziţie 3.9</strong>. </p>
<ol>
<li><p><em>Orice modul injectiv este divizibil.</em></p></li>
<li><p><em>Fie <span class="math inline">\(R\)</span> un
PID-inel.</em></p>
<ol>
<li><p><em>Dacă <span class="math inline">\(Q\)</span> este un <span
class="math inline">\(R\)</span>-modul, atunci <span
class="math inline">\(Q\)</span> este injectiv dacă şi numai dacă este
divizibil.</em></p></li>
<li><p><em>Dacă <span class="math inline">\(I\)</span> este un ideal
nenul al lui <span class="math inline">\(R\)</span>, atunci <span
class="math inline">\(R/I\)</span> este <span
class="math inline">\(R\)</span>-modul quasi-injectiv. În particular,
<span class="math inline">\(\mathbb{Z}_n\)</span> este <span
class="math inline">\(\mathbb{Z}\)</span>-modul quasi-injectiv, <span
class="math inline">\(\forall n \ge 1\)</span>.</em></p></li>
</ol></li>
</ol>
</div>
<div class="proof">
<p><em>Proof.</em> 1) Fie <span class="math inline">\(Q\)</span> un
<span class="math inline">\(R\)</span>-modul divizibil, <span
class="math inline">\(y \in Q\)</span> şi <span class="math inline">\(a
\in R\)</span> nendivizor al lui zero. Definim <span
class="math inline">\(f : aR \to Q\)</span> prin <span
class="math inline">\(f(ax) = yx\)</span> pentru orice <span
class="math inline">\(x \in R\)</span>. Cum <span
class="math inline">\(a\)</span> este nendivizor al lui zero, <span
class="math inline">\(f\)</span> este bine definită. Folosind criteriul
lui Baer rezultă că există <span class="math inline">\(x \in Q\)</span>
astfel încât <span class="math inline">\(f(\lambda) = x\lambda\)</span>,
pentru orice <span class="math inline">\(\lambda \in I\)</span>. Deci
<span class="math inline">\(y = f(a) = f(a \cdot 1) = xa\)</span>.</p>
<p>2) <span class="math inline">\((i)\)</span> Implicaţia „<span
class="math inline">\(\Rightarrow\)</span>” este evidentă din (1).</p>
<p>„<span class="math inline">\(\Leftarrow\)</span>” Fie <span
class="math inline">\(Q\)</span> un <span
class="math inline">\(R\)</span>-modul divizibil şi <span
class="math inline">\(I\)</span> un ideal drept al lui <span
class="math inline">\(R\)</span>. Atunci există <span
class="math inline">\(a \in R\)</span> astfel încât <span
class="math inline">\(I = aR\)</span>. Considerăm <span
class="math inline">\(f : I \to Q\)</span> un morfism de <span
class="math inline">\(R\)</span>-module. Există <span
class="math inline">\(x \in Q\)</span> astfel încât <span
class="math inline">\(f(a) = xa\)</span>. Atunci <span
class="math inline">\(f(ar) = xar\)</span> pentru orice <span
class="math inline">\(r \in R\)</span> şi deci, conform criteriului lui
Baer, <span class="math inline">\(Q\)</span> este injectiv.</p>
<p>(ii) Fie <span class="math inline">\(I = aR\)</span> şi <span
class="math inline">\(J = bR\)</span> ideale nenule ale lui <span
class="math inline">\(R\)</span> astfel încât <span
class="math inline">\(I \subseteq J\)</span> şi <span
class="math inline">\(f : J/I \to R/I\)</span> un morfism de <span
class="math inline">\(R\)</span>-module. Există <span
class="math inline">\(c \in R\)</span> astfel încât <span
class="math inline">\(a = bc\)</span>. Dacă <span
class="math inline">\(f(\bar{b}) = \hat{x} \in R/I\)</span>, atunci
<span class="math inline">\(x \in I\)</span> şi deci există <span
class="math inline">\(a_1 \in R\)</span> astfel încât <span
class="math inline">\(x = aa_1\)</span>. Rezultă că <span
class="math inline">\(x = ba_1\)</span>. Definim <span
class="math inline">\(g : R/I \to R/I\)</span>, <span
class="math inline">\(g(\bar{r}) = \widehat{ar_1}\)</span> pentru orice
<span class="math inline">\(r \in R\)</span>. Atunci <span
class="math inline">\(g\)</span> este morfism de <span
class="math inline">\(R\)</span>-module şi <span
class="math inline">\(g(\bar{b}) = \hat{x}\)</span>, deci <span
class="math inline">\(g\!\mid_{J/I} = f\)</span>, ceea ce arată că <span
class="math inline">\(R/I\)</span> este quasi-injectiv. ◻</p>
</div>
<div class="corollary">
<p><strong>Corolar 3.10</strong>. <em>Un grup abelian <span
class="math inline">\(G\)</span> este <span
class="math inline">\(\mathbb{Z}\)</span>-modul injectiv dacă şi numai
dacă <span class="math inline">\(G\)</span> este divizibil.</em></p>
</div>
<div class="corollary">
<p><strong>Corolar 3.11</strong>. </p>
<ol>
<li><p><em><span class="math inline">\(\mathbb{Q}\)</span> şi <span
class="math inline">\(\mathbb{Z}_{p^\infty}\)</span> sunt <span
class="math inline">\(\mathbb{Z}\)</span>-module
injective.</em></p></li>
<li><p><em>Orice sumă directă de <span
class="math inline">\(\mathbb{Z}\)</span>-module injective este <span
class="math inline">\(\mathbb{Z}\)</span>-modul injectiv.</em></p></li>
<li><p><em>Orice grup factor al unui <span
class="math inline">\(\mathbb{Z}\)</span>-modul injectiv este
injectiv.</em></p></li>
</ol>
</div>
<div class="lemma">
<p><strong>Lemă 3.12</strong>. <em>Fie inelele <span
class="math inline">\(A, S, T\)</span> şi bimodulele <span
class="math inline">\({}_S M_A\)</span>, <span
class="math inline">\({}_A N_T\)</span>. Atunci <span
class="math inline">\(\mathop{\mathrm{Hom}}_A(M,N)\)</span> are o
structură de bimodul <span class="math inline">\(S\)</span>-stâng şi
<span class="math inline">\(T\)</span>-drept prin operaţiile: <span
class="math display">\[(s \cdot f)(x) = f(xs), \qquad (f \cdot t)(x) =
f(x)t,\]</span> unde <span class="math inline">\(s \in S\)</span>, <span
class="math inline">\(t \in T\)</span>, <span class="math inline">\(x
\in M\)</span>, <span class="math inline">\(f \in
\mathop{\mathrm{Hom}}_A(M,N)\)</span>.</em></p>
</div>
<div class="proof">
<p><em>Proof.</em> Fie <span class="math inline">\(a,b \in A\)</span> şi
<span class="math inline">\(x,y \in M\)</span>. Atunci: <span
class="math display">\[(s \cdot f)(ax + by)
= f((ax+by)s)
= f(a(xs)) + f(b(ys)) = a f(xs) + b f(ys)
= a (s \cdot f)(x) + b (s \cdot f)(y),\]</span> şi deci <span
class="math inline">\(s \cdot f \in
\mathop{\mathrm{Hom}}_A(M,N)\)</span>. Analog <span
class="math inline">\(f \cdot t \in
\mathop{\mathrm{Hom}}_A(M,N)\)</span>.</p>
<p>Pentru <span class="math inline">\(s,s&#39; \in S\)</span> şi <span
class="math inline">\(f,g \in \mathop{\mathrm{Hom}}_A(M,N)\)</span>:
<span class="math display">\[(s \cdot (f+g))(x) = (f+g)(xs) = f(xs) +
g(xs) = (s\cdot f)(x) + (s \cdot g)(x).
\tag{1}\]</span></p>
<p><span class="math display">\[((s+s&#39;) \cdot f)(x) = f(x(s+s&#39;))
= f(xs + xs&#39;) = f(xs) + f(xs&#39;) = (s\cdot f)(x) + (s&#39; \cdot
f)(x).
\tag{2}\]</span></p>
<p><span class="math display">\[((ss&#39;) \cdot f)(x) = f(x(ss&#39;)) =
f((xs)s&#39;) = (s&#39; \cdot f)(xs) = (s \cdot (s&#39; \cdot f))(x).
\tag{3}\]</span></p>
<p><span class="math display">\[(1_S \cdot f)(x) = f(x1_S) = f(x).
\tag{4}\]</span></p>
<p>Din (1)–(4) avem că <span
class="math inline">\(\mathop{\mathrm{Hom}}_A(M,N)\)</span> este <span
class="math inline">\(S\)</span>-modul stâng. La fel se arată că este şi
<span class="math inline">\(T\)</span>-modul drept. Prin urmare <span
class="math inline">\(\mathop{\mathrm{Hom}}_A(M,N)\)</span> este un
bimodul <span class="math inline">\(S\)</span>-stâng şi <span
class="math inline">\(T\)</span>-drept. ◻</p>
</div>
<div class="proposition">
<p><strong>Propoziţie 3.13</strong> (Eckmann–Schopf). <em>Fie <span
class="math inline">\(Q\)</span> un grup abelian divizibil. Atunci <span
class="math inline">\(R\)</span>-modulul stâng <span
class="math inline">\(\mathop{\mathrm{Hom}}_\mathbb{Z}(R,Q)\)</span>
este injectiv.</em></p>
</div>
<div class="proof">
<p><em>Proof.</em> Conform lemei precedente, <span
class="math inline">\(\mathop{\mathrm{Hom}}_{\mathbb{Z}}(R,Q)\)</span>
are o structură de <span class="math inline">\(R\)</span>-modul stâng
dată de operaţia <span class="math display">\[(r \cdot f)(a) = f(ar),
\qquad \forall a,r \in R,\ f \in
\mathop{\mathrm{Hom}}_{\mathbb{Z}}(R,Q).\]</span> Fie <span
class="math inline">\(I\)</span> un ideal stâng al lui <span
class="math inline">\(R\)</span> şi <span class="math inline">\(h : I
\to \mathop{\mathrm{Hom}}_{\mathbb{Z}}(R,Q)\)</span> un morfism de <span
class="math inline">\(R\)</span>-module stângi. Atunci aplicaţia <span
class="math display">\[\gamma : \mathbb{Z}I \longrightarrow \mathbb{Z}Q,
\qquad
\gamma(a) = h(a)(1)\]</span> defineşte un morfism de <span
class="math inline">\(\mathbb{Z}\)</span>–module. Cum <span
class="math inline">\(Q\)</span> este <span
class="math inline">\(\mathbb{Z}\)</span>–injectiv, există <span
class="math inline">\(\widetilde{\gamma} : \mathbb{Z}R \to
\mathbb{Z}Q\)</span> astfel încât <span
class="math inline">\(\widetilde{\gamma}_{\mid I} = \gamma\)</span>.
Pentru <span class="math inline">\(a \in I\)</span> şi <span
class="math inline">\(r \in R\)</span> avem <span
class="math display">\[(a \cdot \widetilde{\gamma})(r)
  = \widetilde{\gamma}(ra)
  = h(ra)(1)
  = (r \cdot h(a))(1)
  = h(a)(r),\]</span> deci <span class="math inline">\(h(a) = a \cdot
\widetilde{\gamma}\)</span> pentru orice <span class="math inline">\(a
\in I\)</span>. Conform criteriului lui Baer, <span
class="math inline">\(\mathop{\mathrm{Hom}}_{\mathbb{Z}}(R,Q)\)</span>
este <span class="math inline">\(R\)</span>–modul stâng injectiv. ◻</p>
</div>
<div class="proposition">
<p><strong>Propoziţie 3.14</strong>. <em>Orice <span
class="math inline">\(R\)</span>-modul stâng <span
class="math inline">\(M\)</span> poate fi scufundat într-un <span
class="math inline">\(R\)</span>-modul stâng injectiv.</em></p>
</div>
<div class="proof">
<p><em>Proof.</em> Există un <span
class="math inline">\(\mathbb{Z}\)</span>-modul liber de forma <span
class="math inline">\(\mathbb{Z}^{(A)}\)</span> şi un <span
class="math inline">\(\mathbb{Z}\)</span>-morfism surjectiv <span
class="math inline">\(f : \mathbb{Z}^{(A)} \to M\)</span>. Atunci <span
class="math display">\[\mathbb{Z}M \cong \mathbb{Z}^{(A)} / \ker f
  \subseteq \mathbb{Q}^{(A)} / \ker f,\]</span> şi deci există un grup
abelian divizibil <span class="math inline">\(G\)</span> astfel încât
<span class="math inline">\(\mathbb{Z}M \subseteq \mathbb{Z}G\)</span>.
Aplicând functorul <span
class="math inline">\(\mathop{\mathrm{Hom}}_{\mathbb{Z}}(R,-)\)</span>
obţinem un monomorfism <span class="math display">\[{}_R M \cong
\mathop{\mathrm{Hom}}_{\mathbb{Z}}(R,M)
   \hookrightarrow \mathop{\mathrm{Hom}}_{\mathbb{Z}}(R,G).\]</span> Cum
<span class="math inline">\(G\)</span> este divizibil, din
Propoziţia 2.1.13 rezultă că <span
class="math inline">\(\mathop{\mathrm{Hom}}_{\mathbb{Z}}(R,G)\)</span>
este <span class="math inline">\(R\)</span>-modul stâng injectiv. Prin
urmare <span class="math inline">\(M\)</span> se scufundă într-un <span
class="math inline">\(R\)</span>-modul stâng injectiv. ◻</p>
</div>
<div class="proposition">
<p><strong>Propoziţie 3.15</strong>. <em>Fie <span
class="math inline">\(Q\)</span> un <span
class="math inline">\(R\)</span>-modul. Atunci <span
class="math inline">\(Q\)</span> este injectiv dacă şi numai dacă orice
şir exact de forma <span class="math display">\[0 \longrightarrow Q
\xrightarrow{f} M \xrightarrow{g} M&#39; \longrightarrow 0\]</span> este
scindat.</em></p>
</div>
<div class="proof">
<p><em>Proof.</em> „<span class="math inline">\(\Rightarrow\)</span>”
Presupunem că <span class="math inline">\(Q\)</span> este injectiv. Din
exactitatea şirului avem că <span class="math inline">\(f\)</span> este
monomorfism. Prin injectivitatea lui <span
class="math inline">\(Q\)</span> există <span class="math inline">\(h :
M \to Q\)</span> astfel încât <span class="math inline">\(h f =
\mathrm{id}_Q\)</span>, ceea ce arată că şirul este scindat.</p>
<p>„<span class="math inline">\(\Leftarrow\)</span>” Folosind
Propoziţia 2.1.14, există un <span
class="math inline">\(R\)</span>-modul injectiv <span
class="math inline">\(Q&#39;\)</span> şi un monomorfism <span
class="math inline">\(i : Q \to Q&#39;\)</span>. Avem un şir exact <span
class="math display">\[0 \longrightarrow Q \xrightarrow{i} Q&#39;
\longrightarrow Q&#39;/i(Q) \longrightarrow 0.\]</span> Prin ipoteză
acest şir este scindat, deci <span class="math inline">\(Q\)</span> este
sumand direct în <span class="math inline">\(Q&#39;\)</span>. Un sumand
direct al unui modul injectiv este injectiv, aşadar <span
class="math inline">\(Q\)</span> este injectiv. ◻</p>
</div>
<h2 id="anvelope-injective">Anvelope injective</h2>
<div class="definition">
<p><strong>Definiţie 3.16</strong>. Fie <span
class="math inline">\(M\)</span> un <span
class="math inline">\(R\)</span>-modul. O pereche <span
class="math inline">\((E,i)\)</span> se numeşte <em>anvelopă
injectivă</em> a lui <span class="math inline">\(M\)</span> dacă <span
class="math inline">\(E\)</span> este modul injectiv şi <span
class="math inline">\(i : M \to E\)</span> este un monomorfism
esenţial.</p>
</div>
<div class="proposition">
<p><strong>Propoziţie 3.17</strong>. <em>Fie <span
class="math inline">\(Q\)</span> un <span
class="math inline">\(R\)</span>-modul injectiv. Atunci orice submodul
complement al lui <span class="math inline">\(Q\)</span> este sumand
direct în <span class="math inline">\(Q\)</span>.</em></p>
</div>
<div class="proof">
<p><em>Proof.</em> Fie <span class="math inline">\(K\)</span> un
submodul al lui <span class="math inline">\(Q\)</span> şi <span
class="math inline">\(N\)</span> un complement al lui <span
class="math inline">\(K\)</span> în <span
class="math inline">\(Q\)</span>, adică <span class="math inline">\(K
\cap N = 0\)</span> şi <span class="math inline">\(K+N\)</span> este
submodul esenţial în <span class="math inline">\(Q\)</span>. Atunci
<span class="math inline">\((K+N)/N \cong Q/N\)</span>. Definim <span
class="math inline">\(g : (K+N)/N \to Q\)</span> prin <span
class="math display">\[g((x+y)+N) = x, \qquad x \in K,\ y \in
N.\]</span> Cum <span class="math inline">\(K \cap N = 0\)</span>,
aplicaţia <span class="math inline">\(g\)</span> este bine definită şi
este monomorfism. Injectivitatea lui <span
class="math inline">\(Q\)</span> asigură existenţa unui morfism <span
class="math inline">\(h : Q/N \to Q\)</span> astfel încât <span
class="math inline">\(h_{\mid (K+N)/N} = g\)</span>. Deoarece <span
class="math inline">\((K+N)/N \cong Q/N\)</span> şi <span
class="math inline">\(g\)</span> este monomorfism, şi <span
class="math inline">\(h\)</span> este monomorfism. Avem <span
class="math inline">\(K = \operatorname{Im} g = h((K+N)/N) \subseteq
h(Q/N)\)</span>. Cum <span class="math inline">\(K\)</span> este
submodul închis, rezultă <span class="math inline">\(K =
h(Q/N)\)</span>. Din <span class="math inline">\(h\)</span> monomorfism
obţinem <span class="math inline">\((K+N)/N = Q/N\)</span>, deci <span
class="math inline">\(K+N = Q\)</span>. Prin urmare <span
class="math inline">\(K\)</span> este un sumand direct în <span
class="math inline">\(Q\)</span>. ◻</p>
</div>
<div class="theorem">
<p><strong>Teoremă 3.18</strong> (Eckmann–Schopf). <em>Orice <span
class="math inline">\(R\)</span>-modul <span
class="math inline">\(M\)</span> are o anvelopă injectivă unică până la
un izomorfism.</em></p>
</div>
<div class="proof">
<p><em>Proof.</em> Din Propoziţia 2.1.14 există un <span
class="math inline">\(R\)</span>-modul injectiv <span
class="math inline">\(Q\)</span> astfel încât <span
class="math inline">\(M \leq Q\)</span>. Fie <span
class="math inline">\(E\)</span> o extensie esenţială maximală a lui
<span class="math inline">\(M\)</span> în <span
class="math inline">\(Q\)</span>. Atunci <span
class="math inline">\(E\)</span> este un submodul complement în <span
class="math inline">\(Q\)</span>, iar din propoziţia precedentă rezultă
că <span class="math inline">\(E\)</span> este injectiv. Astfel <span
class="math inline">\((E,i)\)</span>, cu <span class="math inline">\(i :
M \hookrightarrow E\)</span> incluziunea, este o anvelopă injectivă a
lui <span class="math inline">\(M\)</span>.</p>
<p>Pentru unicitate, fie <span class="math inline">\((E_1,i_1)\)</span>
şi <span class="math inline">\((E_2,i_2)\)</span> două anvelope
injective ale lui <span class="math inline">\(M\)</span>. Cum <span
class="math inline">\(E_2\)</span> este injectiv, există <span
class="math inline">\(f : E_1 \to E_2\)</span> astfel încât <span
class="math inline">\(f i_1 = i_2\)</span>. Morfismul <span
class="math inline">\(i_2\)</span> este monomorfism, iar <span
class="math inline">\(i_1\)</span> este monomorfism esenţial, deci
(folosind 1.4) rezultă că <span class="math inline">\(f\)</span> este
monomorfism. Avem <span class="math inline">\(E_1 \cong f(E_1)\)</span>
şi <span class="math inline">\(E_2 = f(E_1) \oplus E_3\)</span> pentru
un anumit submodul <span class="math inline">\(E_3\)</span>. Dar <span
class="math inline">\(i_2(M) \subseteq f(E_1)\)</span>, deci <span
class="math inline">\(i_2(M) \cap E_3 = 0\)</span>. Cum <span
class="math inline">\(i_2\)</span> este monomorfism esenţial, rezultă
<span class="math inline">\(E_3 = 0\)</span>, deci <span
class="math inline">\(E_2 = f(E_1)\)</span> şi <span
class="math inline">\(f\)</span> este izomorfism. ◻</p>
</div>
<p>În practică vom considera un reprezentant al acestei clase pe care îl
vom nota <span class="math inline">\(E(M)\)</span> astfel încât <span
class="math inline">\(M \trianglelefteq E(M)\)</span>.</p>
<div class="proposition">
<p><strong>Propoziţie 3.19</strong>. <em>Fie <span
class="math inline">\(M\)</span> un <span
class="math inline">\(R\)</span>-modul şi <span class="math inline">\(i
: M \to Q\)</span> un monomorfism cu <span
class="math inline">\(Q_R\)</span> injectiv. Următoarele afirmaţii sunt
echivalente:</em></p>
<ol>
<li><p><em><span class="math inline">\((Q,i)\)</span> este o anvelopă
injectivă a lui <span class="math inline">\(M\)</span>;</em></p></li>
<li><p><em>pentru orice monomorfism <span class="math inline">\(f : M
\to Q&#39;\)</span> cu <span class="math inline">\(Q&#39;\)</span>
injectiv, există un monomorfism <span class="math inline">\(g : Q \to
Q&#39;\)</span> astfel încât <span class="math inline">\(g i =
f\)</span>.</em></p></li>
</ol>
</div>
<div class="proof">
<p><em>Proof.</em> <span class="math inline">\((1) \Rightarrow
(2)\)</span>. Fie <span class="math inline">\(f : M \to Q&#39;\)</span>
un monomorfism cu <span class="math inline">\(Q&#39;\)</span> injectiv.
Prin injectivitatea lui <span class="math inline">\(Q&#39;\)</span>
există <span class="math inline">\(u : Q \to Q&#39;\)</span> astfel
încât <span class="math inline">\(u i = f\)</span>. Cum <span
class="math inline">\(i\)</span> este monomorfism esenţial şi <span
class="math inline">\(Q&#39;\)</span> este injectiv, imaginea <span
class="math inline">\(u(Q)\)</span> este un complement al lui <span
class="math inline">\(f(M)\)</span>, iar din definiţia anvelopei
injective rezultă că <span class="math inline">\(u\)</span> este
monomorfism; punem <span class="math inline">\(g=u\)</span>.</p>
<p><span class="math inline">\((2) \Rightarrow (1)\)</span>. Fie <span
class="math inline">\((E(M),j)\)</span> o anvelopă injectivă a lui <span
class="math inline">\(M\)</span>. Aplicând (2) la <span
class="math inline">\(f=j\)</span> obţinem un monomorfism <span
class="math inline">\(g : Q \to E(M)\)</span> cu <span
class="math inline">\(g i = j\)</span>. Cum <span
class="math inline">\(j\)</span> este monomorfism esenţial, rezultă că
şi <span class="math inline">\(i\)</span> este monomorfism esenţial,
deci <span class="math inline">\((Q,i)\)</span> este o anvelopă
injectivă a lui <span class="math inline">\(M\)</span>. ◻</p>
</div>
<div class="proposition">
<p><strong>Propoziţie 3.20</strong>. <em>Oricare ar fi <span
class="math inline">\(R\)</span>-modulele drepte <span
class="math inline">\(M_1,M_2,\dots,M_n\)</span> avem <span
class="math display">\[E\!\left(\bigoplus_{i=1}^{n} M_i\right)
  \cong \bigoplus_{i=1}^{n} E(M_i).\]</span></em></p>
</div>
<div class="proof">
<p><em>Proof.</em> Din 1.9, <span
class="math inline">\(\bigoplus_{i=1}^{n} E(M_i)\)</span> este o
extensie esenţială a lui <span class="math inline">\(\bigoplus_{i=1}^{n}
M_i\)</span>. Cum <span class="math display">\[\bigoplus_{i=1}^{n}
E(M_i) \cong \prod_{i=1}^{n} E(M_i),\]</span> din 2.1.3 rezultă că <span
class="math inline">\(\bigoplus_{i=1}^{n} E(M_i)\)</span> este injectiv.
Prin unicitatea anvelopei injective obţinem <span
class="math display">\[E\!\left(\bigoplus_{i=1}^{n} M_i\right)
  \cong \bigoplus_{i=1}^{n} E(M_i).\]</span> ◻</p>
</div>
<div class="theorem">
<p><strong>Teoremă 3.21</strong>. <em>Fie <span
class="math inline">\(Q\)</span> şi <span
class="math inline">\(M\)</span> două <span
class="math inline">\(R\)</span>-module. Atunci <span
class="math inline">\(Q\)</span> este <span
class="math inline">\(M\)</span>-injectiv dacă şi numai dacă <span
class="math inline">\(f(M) \leq Q\)</span>, oricare ar fi <span
class="math inline">\(f \in
\mathop{\mathrm{Hom}}(E(M),E(Q))\)</span>.</em></p>
</div>
<div class="proof">
<p><em>Proof.</em> „<span class="math inline">\(\Rightarrow\)</span>”
Fie <span class="math inline">\(f \in
\mathop{\mathrm{Hom}}(E(M),E(Q))\)</span> şi notăm <span
class="math display">\[K := \{\,m \in M \mid f(m) \in Q\,\}.\]</span>
Cum <span class="math inline">\(Q\)</span> este <span
class="math inline">\(M\)</span>-injectiv, există un morfism <span
class="math inline">\(\bar{f} : M \to Q\)</span> astfel încât <span
class="math inline">\(\bar{f}\!\mid_{K} = f\!\mid_{K}\)</span>. Arătăm
că <span class="math display">\[Q \cap (\bar{f}-f)(M) = 0.\]</span> Fie
<span class="math inline">\(x \in Q\)</span> şi <span
class="math inline">\(m \in M\)</span> cu <span class="math inline">\(x
= (\bar{f}-f)(m)\)</span>. Atunci <span class="math display">\[f(m) =
\bar{f}(m) - x \in Q,\]</span> deci <span class="math inline">\(m \in
K\)</span>. Urmează că <span class="math display">\[x = \bar{f}(m) -
f(m) = f(m) - f(m) = 0.\]</span> Prin urmare <span
class="math inline">\(Q \cap (\bar{f}-f)(M) = 0\)</span> şi, cum <span
class="math inline">\(Q \trianglelefteq E(Q)\)</span>, rezultă că <span
class="math inline">\((\bar{f}-f)(M) = 0\)</span>. Aşadar <span
class="math inline">\(f(M) = \bar{f}(M) \leq Q\)</span>.</p>
<p>„<span class="math inline">\(\Leftarrow\)</span>” Întrucât <span
class="math inline">\(E(Q)\)</span> este injectiv, este suficient să
considerăm <span class="math inline">\(f \in
\mathop{\mathrm{Hom}}(M,E(Q))\)</span>. Fie <span
class="math inline">\(N\)</span> un submodul al lui <span
class="math inline">\(M\)</span> şi <span class="math inline">\(g : N
\to Q\)</span> un morfism de <span
class="math inline">\(R\)</span>-module. Cum <span
class="math inline">\(E(Q)\)</span> este injectiv, există un morfism
<span class="math inline">\(\tilde{g} : M \to E(Q)\)</span> astfel încât
<span class="math inline">\(\tilde{g}\!\mid_{N} = i \circ g\)</span>,
unde <span class="math inline">\(i : Q \to E(Q)\)</span> este injecţia
canonică. Prin ipoteză avem <span class="math inline">\(\tilde{g}(M)
\leq Q\)</span>, astfel încât, identificând <span
class="math inline">\(\tilde{g}\)</span> cu corestricţia sa la <span
class="math inline">\(Q\)</span>, obţinem un morfism <span
class="math inline">\(h : M \to Q\)</span> cu <span
class="math inline">\(h\!\mid_{N} = g\)</span>. Prin urmare <span
class="math inline">\(Q\)</span> este <span
class="math inline">\(M\)</span>-injectiv. ◻</p>
</div>
<div class="corollary">
<p><strong>Corolar 3.22</strong>. <em>Un <span
class="math inline">\(R\)</span>-modul <span
class="math inline">\(Q\)</span> este quasi-injectiv dacă şi numai dacă
<span class="math inline">\(f(Q) \leq Q\)</span> pentru orice <span
class="math inline">\(f \in
\mathop{\mathrm{End}}(E(Q))\)</span>.</em></p>
</div>
<div class="theorem">
<p><strong>Teoremă 3.23</strong> (Matlis–Bass). <em>Fie <span
class="math inline">\(R\)</span> un inel. Atunci <span
class="math inline">\(R\)</span> este noetherian la dreapta dacă şi
numai dacă, pentru orice <span class="math inline">\(R\)</span>-modul
simplu <span class="math inline">\(S_i\)</span> (<span
class="math inline">\(i \geq 1\)</span>), <span class="math display">\[Q
:= \bigoplus_{i=1}^{\infty} E(S_i)\]</span> este un <span
class="math inline">\(R\)</span>-modul injectiv.</em></p>
</div>
<div class="proof">
<p><em>Proof.</em> „<span class="math inline">\(\Rightarrow\)</span>”
Fie <span class="math inline">\(L\)</span> un ideal drept al lui <span
class="math inline">\(R\)</span>, <span class="math display">\[Q =
\bigoplus_{i=1}^{\infty} E(S_i)\]</span> şi <span
class="math inline">\(f : L \to Q\)</span> un morfism de <span
class="math inline">\(R\)</span>-module. Există elemente <span
class="math inline">\(a_1,\dots,a_n \in L\)</span> astfel încât <span
class="math display">\[L = a_1 R + a_2 R + \cdots + a_n R.\]</span> În
mod evident există <span class="math inline">\(m \geq 1\)</span> astfel
încât <span class="math inline">\(f(a_k) \in \bigoplus_{j=1}^{m}
E(S_j)\)</span> pentru orice <span class="math inline">\(k =
1,\dots,n\)</span>, deci <span class="math display">\[\Im f \subseteq
\bigoplus_{j=1}^{m} E(S_j).\]</span> Cum <span
class="math inline">\(\bigoplus_{j=1}^{m} E(S_j)\)</span> este injectiv,
există <span class="math inline">\(g : R \to \bigoplus_{j=1}^{m}
E(S_j)\)</span> astfel încât <span class="math inline">\(g\!\mid_{L} =
f\)</span>. Notăm <span class="math inline">\(\bar{f} = i \circ
g\)</span>, unde <span class="math inline">\(i : \bigoplus_{j=1}^{m}
E(S_j) \to Q\)</span> este injecţia canonică. Atunci <span
class="math inline">\(\bar{f}\!\mid_{L} = f\)</span>, deci <span
class="math inline">\(Q\)</span> este injectiv.</p>
<p>„<span class="math inline">\(\Leftarrow\)</span>” Presupunem că <span
class="math inline">\(R\)</span> nu este noetherian la dreapta. Atunci
există un şir strict ascendent de ideale la dreapta, finit generate:
<span class="math display">\[L_1 \subsetneq L_2 \subsetneq \cdots
\subsetneq L_n \subsetneq \cdots .\]</span> Din lema lui Krull rezultă
că, pentru orice <span class="math inline">\(n \geq 1\)</span>, există
un submodul maximal <span class="math inline">\(M_n \subsetneq
L_n\)</span> astfel încât <span class="math display">\[L_{n-1} \subseteq
M_n \quad \text{pentru orice } n \geq 2.\]</span> Fie <span
class="math display">\[L := \bigcup_{k=1}^{\infty} L_k, \qquad
\pi_k : L_k \longrightarrow L_k/M_k\]</span> proiecţiile canonice şi
<span class="math display">\[E_k := E(L_k/M_k) \quad \text{pentru orice
} k \geq 1.\]</span> Atunci <span class="math display">\[E :=
\bigoplus_{k=1}^{\infty} E_k\]</span> este injectiv şi <span
class="math display">\[f : L \longrightarrow E, \qquad
f(a) = \sum_{k=1}^{\infty} \pi_k(a)\]</span> este bine definit. Există
un element <span class="math inline">\(x \in E_1 \oplus \cdots \oplus
E_n\)</span> astfel încât <span class="math inline">\(f(a) = x
a\)</span> pentru orice <span class="math inline">\(a \in L\)</span>.
Rezultă că <span class="math inline">\(\pi_k(a) = 0\)</span> pentru
orice <span class="math inline">\(k \geq n+1\)</span>, adică <span
class="math inline">\(a \in M_k\)</span> pentru orice <span
class="math inline">\(k \geq n+1\)</span>. Prin urmare <span
class="math display">\[L \subseteq M_{n+1} \subsetneq L_{n+1} \subseteq
M_{n+2} \subsetneq L_{n+2}
\subseteq \cdots \subseteq L,\]</span> contradicţie. Obţinem că <span
class="math inline">\(R\)</span> este noetherian la dreapta. ◻</p>
</div>
</body>
</html>
