<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Coordonator ÅŸtiinÅ£ific: Prof. Dr. Tiberiu Dumitrescu Student: Sorin Bogde" />
  <title>DIMENSIUNEA COIREDUCTIBILÄ‚ A INELELOR ÅI MODULELOR</title>
  <style>
    /* Default styles provided by pandoc.
    ** See https://pandoc.org/MANUAL.html#variables-for-html for config info.
    */
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
  <link rel="stylesheet" href="style.css?v=1763893170" />
  <script
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
  type="text/javascript"></script>
  <!-- Cache Control -->
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
  <meta http-equiv="Pragma" content="no-cache">
  <meta http-equiv="Expires" content="0">
  <meta name="build-timestamp" content="1763893170">
  
  <!-- PWA and Favicon -->
  <link rel="icon" type="image/svg+xml" href="favicon.svg">
  <link rel="manifest" href="manifest.json?v=1763893170">
  <meta name="theme-color" content="#2c3e50">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="default">
  <meta name="apple-mobile-web-app-title" content="Fosile Algebrice">
  <link rel="apple-touch-icon" href="icon-192.png">
</head>
<body>
<header id="title-block-header">
<h1 class="title">DIMENSIUNEA COIREDUCTIBILÄ‚ A INELELOR ÅI
MODULELOR</h1>
<p class="author">Coordonator ÅŸtiinÅ£ific: Prof. Dr. Tiberiu
Dumitrescu<br />
Student: Sorin Bogde</p>
<p class="date">Universitatea BucureÅŸti, Facultatea de MatematicÄƒ<br />
1999</p>
</header>
<div style="text-align: center; margin: 2em 0; padding: 1em; background-color: #f0f0f0; border-radius: 8px;">
  <a href="thesis.pdf" download style="display: inline-block; padding: 0.75em 1.5em; background-color: #2c3e50; color: white; text-decoration: none; border-radius: 4px; font-weight: bold; transition: background-color 0.3s;">
    ğŸ“¥ DescarcÄƒ PDF (Download PDF)
  </a>
</div>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#generalitÄƒÅ£i" id="toc-generalitÄƒÅ£i">GeneralitÄƒÅ£i</a>
<ul>
<li><a href="#module-semisimple" id="toc-module-semisimple">Module
semisimple</a></li>
<li><a
href="#module-noetheriene-artiniene-ÅŸi-inele-noetheriene-artiniene"
id="toc-module-noetheriene-artiniene-ÅŸi-inele-noetheriene-artiniene">Module
noetheriene (artiniene) ÅŸi inele noetheriene (artiniene)</a></li>
<li><a href="#module-de-lungime-finitÄƒ"
id="toc-module-de-lungime-finitÄƒ">Module de lungime finitÄƒ</a></li>
<li><a href="#radicalul-jacobson" id="toc-radicalul-jacobson">Radicalul
Jacobson</a></li>
<li><a href="#inele-semisimple" id="toc-inele-semisimple">Inele
semisimple</a></li>
</ul></li>
<li><a href="#submodule-esenÅ£iale"
id="toc-submodule-esenÅ£iale">Submodule esenÅ£iale</a></li>
<li><a href="#module-injective" id="toc-module-injective">Module
injective</a>
<ul>
<li><a href="#module-injective-1" id="toc-module-injective-1">Module
injective</a></li>
<li><a href="#anvelope-injective" id="toc-anvelope-injective">Anvelope
injective</a></li>
</ul></li>
<li><a href="#sume-directe-de-module-coireductibile"
id="toc-sume-directe-de-module-coireductibile">Sume directe de module
coireductibile</a></li>
<li><a href="#domenii-ore-ÅŸi-inele-goldie"
id="toc-domenii-ore-ÅŸi-inele-goldie">Domenii Ore ÅŸi inele
Goldie</a></li>
<li><a href="#teorema-osofskysmith"
id="toc-teorema-osofskysmith">Teorema Osofskyâ€“Smith</a></li>
</ul>
</nav>
<h1 id="generalitÄƒÅ£i">GeneralitÄƒÅ£i</h1>
<h2 id="module-semisimple">Module semisimple</h2>
<div class="definition">
<p><strong>DefiniÅ£ie 1.1</strong>. Un <span
class="math inline">\(R\)</span>-modul nenul <span
class="math inline">\(S\)</span> se numeÅŸte <em>simplu</em> dacÄƒ
singurele sale submodule sunt <span class="math inline">\(0\)</span> ÅŸi
<span class="math inline">\(S\)</span>.</p>
</div>
<div class="proposition">
<p><strong>PropoziÅ£ie 1.2</strong>. <em>Fie <span
class="math inline">\(S\)</span> un <span
class="math inline">\(R\)</span>-modul. UrmÄƒtoarele afirmaÅ£ii sunt
echivalente:</em></p>
<ol>
<li><p><em><span class="math inline">\(S\)</span> este modul
simplu.</em></p></li>
<li><p><em>Pentru orice element nenul <span class="math inline">\(x\in
S\)</span> avem <span class="math inline">\(S =
xR\)</span>.</em></p></li>
<li><p><em><span class="math inline">\(S \simeq R/I\)</span>, unde <span
class="math inline">\(I\)</span> este un ideal drept
maximal.</em></p></li>
</ol>
</div>
<div class="lemma">
<p><strong>LemÄƒ 1.3</strong> (Schur). <em>Fie <span
class="math inline">\(S\)</span> ÅŸi <span
class="math inline">\(S&#39;\)</span> douÄƒ <span
class="math inline">\(R\)</span>-module simple ÅŸi <span
class="math inline">\(f\colon S \to S&#39;\)</span> un morfism de <span
class="math inline">\(R\)</span>-module. Atunci <span
class="math inline">\(f = 0\)</span> sau <span
class="math inline">\(f\)</span> este izomorfism. Ãn particular <span
class="math inline">\(\mathop{\mathrm{End}}_R(S)\)</span> este
corp.</em></p>
</div>
<div class="definition">
<p><strong>DefiniÅ£ie 1.4</strong>. Fie <span
class="math inline">\(M\)</span> un <span
class="math inline">\(R\)</span>-modul ÅŸi <span
class="math inline">\((S_i)_{i\in I}\)</span> mulÅ£imea submodulelor
simple ale lui <span class="math inline">\(M\)</span>. DacÄƒ <span
class="math inline">\(M = \sum_{i\in I} S_i\)</span>, atunci <span
class="math inline">\(M\)</span> se numeÅŸte <em>semisimplu</em>.</p>
</div>
<div class="proposition">
<p><strong>PropoziÅ£ie 1.5</strong>. <em>Fie <span
class="math inline">\(M\)</span> un <span
class="math inline">\(R\)</span>-modul semisimplu ÅŸi <span
class="math inline">\(N\)</span> un submodul al sÄƒu. Atunci existÄƒ o
submulÅ£ime <span class="math inline">\(J \subseteq I\)</span> astfel
Ã®ncÃ¢t:</em></p>
<ol>
<li><p><em>familia <span class="math inline">\((S_j)_{j\in J}\)</span>
este independentÄƒ;</em></p></li>
<li><p><em><span class="math inline">\(M = N \oplus
\bigl(\bigoplus_{j\in J} S_j\bigr)\)</span>.</em></p></li>
</ol>
</div>
<div class="corollary">
<p><strong>Corolar 1.6</strong>. <em>Cu notaÅ£iile de mai sus, pentru
modulul semisimplu <span class="math inline">\(M\)</span> existÄƒ <span
class="math inline">\(J \subseteq I\)</span> astfel Ã®ncÃ¢t familia <span
class="math inline">\((S_j)_{j\in J}\)</span> este independentÄƒ ÅŸi <span
class="math display">\[M = \bigoplus_{i\in I} M_i.\]</span></em></p>
</div>
<div class="corollary">
<p><strong>Corolar 1.7</strong>. <em>DacÄƒ <span
class="math inline">\(M\)</span> este un <span
class="math inline">\(R\)</span>-modul semisimplu ÅŸi <span
class="math inline">\(N\)</span> un submodul al sÄƒu, atunci <span
class="math inline">\(N\)</span> ÅŸi <span
class="math inline">\(M/N\)</span> sunt semisimple.</em></p>
</div>
<div class="corollary">
<p><strong>Corolar 1.8</strong>. <em>O sumÄƒ directÄƒ de module semisimple
este modul semisimplu.</em></p>
</div>
<div class="theorem">
<p><strong>TeoremÄƒ 1.9</strong>. <em>Fie <span
class="math inline">\(M\)</span> un <span
class="math inline">\(R\)</span>-modul. UrmÄƒtoarele afirmaÅ£ii sunt
echivalente:</em></p>
<ol>
<li><p><em><span class="math inline">\(M\)</span> este
semisimplu;</em></p></li>
<li><p><em><span class="math inline">\(M\)</span> este izomorf cu o sumÄƒ
directÄƒ de module simple;</em></p></li>
<li><p><em>orice submodul al sÄƒu este sumand direct Ã®n <span
class="math inline">\(M\)</span>;</em></p></li>
<li><p><em>orice ÅŸir exact <span class="math display">\[0
\longrightarrow M&#39; \xrightarrow{\,f\,} M \xrightarrow{\,g\,}
M&#39;&#39; \longrightarrow 0\]</span> este scindabil.</em></p></li>
</ol>
</div>
<div class="definition">
<p><strong>DefiniÅ£ie 1.10</strong>. Suma submodulelor simple ale lui
<span class="math inline">\(M\)</span> se numeÅŸte <em>soclul</em> lui
<span class="math inline">\(M\)</span> ÅŸi se noteazÄƒ <span
class="math inline">\(\mathop{\mathrm{soc}}(M)\)</span>. DacÄƒ <span
class="math inline">\(M\)</span> nu conÅ£ine nici un submodul simplu
atunci punem <span class="math inline">\(\mathop{\mathrm{soc}}(M) =
0\)</span>.</p>
</div>
<div class="proposition">
<p><strong>PropoziÅ£ie 1.11</strong>. <em>Fie <span
class="math inline">\(M\)</span> ÅŸi <span
class="math inline">\(N\)</span> douÄƒ <span
class="math inline">\(R\)</span>-module ÅŸi <span
class="math inline">\(f\colon M \to N\)</span> un morfism. Atunci <span
class="math inline">\(f(\mathop{\mathrm{soc}}(M)) \subseteq
\mathop{\mathrm{soc}}(N)\)</span>.</em></p>
</div>
<div class="proposition">
<p><strong>PropoziÅ£ie 1.12</strong>. <em>Fie <span
class="math inline">\(M\)</span> un <span
class="math inline">\(R\)</span>-modul ÅŸi <span
class="math inline">\(N\)</span> un submodul al sÄƒu. Atunci <span
class="math display">\[\mathop{\mathrm{soc}}(N) =
\mathop{\mathrm{soc}}(M) \cap N.\]</span></em></p>
</div>
<div class="proposition">
<p><strong>PropoziÅ£ie 1.13</strong>. <em>DacÄƒ <span
class="math inline">\(M = \bigoplus_{i\in I} M_i\)</span>, atunci <span
class="math display">\[\mathop{\mathrm{soc}}(M) = \bigoplus_{i\in I}
\mathop{\mathrm{soc}}(M_i).\]</span></em></p>
</div>
<div class="proposition">
<p><strong>PropoziÅ£ie 1.14</strong>. <em>Fie <span
class="math inline">\(R\)</span> un inel. Atunci <span
class="math inline">\(\mathop{\mathrm{soc}}(R_R)\)</span> este un ideal
bilateral al lui <span class="math inline">\(R\)</span>.</em></p>
</div>
<h2
id="module-noetheriene-artiniene-ÅŸi-inele-noetheriene-artiniene">Module
noetheriene (artiniene) ÅŸi inele noetheriene (artiniene)</h2>
<div class="definition">
<p><strong>DefiniÅ£ie 1.15</strong>. Fie <span
class="math inline">\(R\)</span> un inel ÅŸi <span
class="math inline">\(M\)</span> un <span
class="math inline">\(R\)</span>-modul drept. Spunem cÄƒ <span
class="math inline">\(M\)</span> satisface <em>condiÅ£ia maximalÄƒ</em>
(resp. <em>minimalÄƒ</em>) dacÄƒ orice mulÅ£ime nevidÄƒ de submodule ale lui
<span class="math inline">\(M\)</span>, ordonatÄƒ prin incluziune, admite
un element maximal (resp. minimal).</p>
<p>Spunem cÄƒ <span class="math inline">\(M\)</span> satisface
<em>condiÅ£ia lanÅ£urilor ascendente</em> (resp. <em>descendente</em>)
dacÄƒ orice ÅŸir (lanÅ£) ascendent de submodule ale lui <span
class="math inline">\(M\)</span> <span class="math display">\[M_1
\subseteq M_2 \subseteq \cdots \subseteq M_i \subseteq \cdots\]</span>
(resp. orice ÅŸir descendent <span class="math display">\[M_1 \supseteq
M_2 \supseteq \cdots \supseteq M_i \supseteq \cdots\]</span>) este
staÅ£ionar, adicÄƒ existÄƒ <span class="math inline">\(n \ge 1\)</span>
astfel Ã®ncÃ¢t <span class="math inline">\(M_n = M_{n+1} =
\cdots\)</span>.</p>
</div>
<div class="proposition">
<p><strong>PropoziÅ£ie 1.16</strong>. <em>Fie <span
class="math inline">\(M\)</span> un <span
class="math inline">\(R\)</span>-modul. UrmÄƒtoarele afirmaÅ£ii sunt
echivalente:</em></p>
<ol>
<li><p><em><span class="math inline">\(M\)</span> satisface condiÅ£ia
maximalÄƒ (minimalÄƒ);</em></p></li>
<li><p><em><span class="math inline">\(M\)</span> satisface condiÅ£ia
lanÅ£urilor ascendente (descendente).</em></p></li>
</ol>
</div>
<div class="definition">
<p><strong>DefiniÅ£ie 1.17</strong>. Un <span
class="math inline">\(R\)</span>-modul <span
class="math inline">\(M\)</span> se numeÅŸte <em>noetherian</em> (resp.
<em>artinian</em>) dacÄƒ satisface condiÅ£ia maximalÄƒ (resp. minimalÄƒ).
Inelul <span class="math inline">\(R\)</span> se numeÅŸte noetherian
(resp. artinian) la dreapta dacÄƒ <span
class="math inline">\(R_R\)</span> este noetherian (resp. artinian).</p>
</div>
<div class="example">
<p><strong>Exemplu 1.18</strong>. </p>
<ol>
<li><p><span class="math inline">\(\mathbb{Z}\)</span> este inel
noetherian dar nu este artinian.</p></li>
<li><p>Orice grup finit este <span
class="math inline">\(\mathbb{Z}\)</span>-modul noetherian ÅŸi
artinian.</p></li>
<li><p>Orice inel finit este noetherian ÅŸi artinian.</p></li>
<li><p><span
class="math inline">\(\mathbb{Z}[X_1,X_2,\ldots,X_n,\ldots]\)</span> nu
este nici noetherian, nici artinian: <span class="math display">\[(X_1)
\subsetneq (X_1,X_2) \subsetneq \cdots \subsetneq
          (X_1,\ldots,X_n) \subsetneq \cdots\]</span> <span
class="math display">\[(X_1) \supsetneq (X_1^2) \supsetneq \cdots
\supsetneq
          (X_1^k) \supsetneq \cdots\]</span></p></li>
<li><p><span class="math inline">\(\mathbb{Z}_{p^\infty}\)</span> este
<span class="math inline">\(\mathbb{Z}\)</span>-modul artinian dar nu
este noetherian.</p></li>
</ol>
</div>
<div class="proposition">
<p><strong>PropoziÅ£ie 1.19</strong>. <em>Fie <span
class="math inline">\(N, P\)</span> douÄƒ submodule ale lui <span
class="math inline">\(M\)</span> astfel Ã®ncÃ¢t <span
class="math inline">\(M = N + P\)</span>. Atunci <span
class="math inline">\(M\)</span> este noetherian (artinian) dacÄƒ ÅŸi
numai dacÄƒ <span class="math inline">\(N\)</span> ÅŸi <span
class="math inline">\(P\)</span> sunt noetheriene (artiniene).</em></p>
</div>
<div class="proposition">
<p><strong>PropoziÅ£ie 1.20</strong>. <em>Pentru un <span
class="math inline">\(R\)</span>-modul <span
class="math inline">\(M\)</span> urmÄƒtoarele afirmaÅ£ii sunt
echivalente:</em></p>
<ol>
<li><p><em><span class="math inline">\(M\)</span> este
noetherian;</em></p></li>
<li><p><em>orice submodul al lui <span class="math inline">\(M\)</span>
este finit generat.</em></p></li>
</ol>
</div>
<div class="proposition">
<p><strong>PropoziÅ£ie 1.21</strong>. <em>Pentru un <span
class="math inline">\(R\)</span>-modul <span
class="math inline">\(M\)</span> urmÄƒtoarele afirmaÅ£ii sunt
echivalente:</em></p>
<ol>
<li><p><em><span class="math inline">\(M\)</span> este
artinian;</em></p></li>
<li><p><em>oricare ar fi familia <span class="math inline">\((X_i)_{i\in
I}\)</span> de submodule ale lui <span class="math inline">\(M\)</span>,
existÄƒ <span class="math inline">\(J \subseteq I\)</span>, <span
class="math inline">\(J\)</span> finitÄƒ, astfel Ã®ncÃ¢t <span
class="math display">\[\bigcap_{i\in I} X_i = \bigcap_{j\in J}
X_j.\]</span></em></p></li>
</ol>
</div>
<h2 id="module-de-lungime-finitÄƒ">Module de lungime finitÄƒ</h2>
<div class="definition">
<p><strong>DefiniÅ£ie 1.22</strong>. Fie <span
class="math inline">\(M\)</span> un <span
class="math inline">\(R\)</span>-modul drept nenul. Se numeÅŸte <em>ÅŸir
de compoziÅ£ie</em> sau <em>ÅŸir Jordanâ€“HÃ¶lder</em> al lui <span
class="math inline">\(M\)</span> un lanÅ£ finit strict ascendent de
submodule <span class="math display">\[0 = X_0 \subset X_1 \subset
\cdots \subset X_n = M\]</span> astfel Ã®ncÃ¢t <span
class="math inline">\(X_{i+1}/X_i\)</span> este modul simplu pentru
<span class="math inline">\(0 \le i \le n-1\)</span>. NumÄƒrul <span
class="math inline">\(n\)</span> se numeÅŸte <em>lungimea ÅŸirului</em>,
iar modulele <span class="math inline">\(X_{i+1}/X_i\)</span> se numesc
<em>factorii ÅŸirului</em>.</p>
</div>
<div class="proposition">
<p><strong>PropoziÅ£ie 1.23</strong>. <em>Fie <span
class="math inline">\(M\)</span> un <span
class="math inline">\(R\)</span>-modul. UrmÄƒtoarele afirmaÅ£ii sunt
echivalente:</em></p>
<ol>
<li><p><em><span class="math inline">\(M\)</span> are un ÅŸir de
compoziÅ£ie;</em></p></li>
<li><p><em><span class="math inline">\(M\)</span> este noetherian ÅŸi
artinian.</em></p></li>
</ol>
</div>
<div class="proposition">
<p><strong>PropoziÅ£ie 1.24</strong>. <em>Fie <span
class="math display">\[0 \longrightarrow M&#39; \longrightarrow M
\longrightarrow M&#39;&#39; \longrightarrow 0\]</span> un ÅŸir exact de
<span class="math inline">\(R\)</span>-module drepte. Atunci <span
class="math inline">\(M\)</span> admite un ÅŸir de compoziÅ£ie dacÄƒ ÅŸi
numai dacÄƒ <span class="math inline">\(M&#39;\)</span> ÅŸi <span
class="math inline">\(M&#39;&#39;\)</span> admit un ÅŸir de
compoziÅ£ie.</em></p>
</div>
<p>DacÄƒ <span class="math display">\[0 = M_0 \subseteq M_1 \subseteq
\cdots \subseteq M_n = M,\qquad
  0 = N_0 \subseteq N_1 \subseteq \cdots \subseteq N_p = M\]</span> sunt
douÄƒ ÅŸiruri de compoziÅ£ie ale lui <span
class="math inline">\(M\)</span>, vom spune cÄƒ ele sunt
<em>echivalente</em> dacÄƒ <span class="math inline">\(n=p\)</span> ÅŸi
existÄƒ o bijecÅ£ie <span class="math inline">\(\sigma : \{0,\ldots,n-1\}
\to \{0,\ldots,n-1\}\)</span> astfel Ã®ncÃ¢t <span
class="math display">\[M_{i+1}/M_i \cong M_{\sigma(i)+1}/M_{\sigma(i)}
  \quad (0 \le i \le n-1).\]</span></p>
<div class="theorem">
<p><strong>TeoremÄƒ 1.25</strong> (Jordanâ€“HÃ¶lder). <em>DacÄƒ un <span
class="math inline">\(R\)</span>-modul <span
class="math inline">\(M\)</span> are douÄƒ ÅŸiruri de compoziÅ£ie <span
class="math display">\[0 = M_0 \subseteq M_1 \subseteq \cdots \subseteq
M_n = M,\qquad
  0 = N_0 \subseteq N_1 \subseteq \cdots \subseteq N_p = M,\]</span>
atunci aceste douÄƒ ÅŸiruri sunt echivalente.</em></p>
</div>
<div class="definition">
<p><strong>DefiniÅ£ie 1.26</strong>. Un <span
class="math inline">\(R\)</span>-modul <span
class="math inline">\(M\)</span> care admite un ÅŸir de compoziÅ£ie se
numeÅŸte <em>modul de lungime finitÄƒ</em>. Lungimea ÅŸirurilor de
compoziÅ£ie se numeÅŸte <em>lungimea</em> lui <span
class="math inline">\(M\)</span> ÅŸi se noteazÄƒ <span
class="math inline">\(l(M)\)</span>. DacÄƒ <span
class="math inline">\(M\)</span> nu admite nici un ÅŸir de comÂ­poÂ­ziÂ­Å£ie,
atunci spunem cÄƒ <span class="math inline">\(M\)</span> este <em>de
lungime infinitÄƒ</em> ÅŸi scriem <span
class="math inline">\(l(M)=\infty\)</span>.</p>
</div>
<div class="proposition">
<p><strong>PropoziÅ£ie 1.27</strong>. <em>Fie <span
class="math display">\[0 \longrightarrow M&#39; \longrightarrow M
\longrightarrow M&#39;&#39; \longrightarrow 0\]</span> un ÅŸir exact de
<span class="math inline">\(R\)</span>-module de lungime finitÄƒ. Atunci
<span class="math display">\[l(M) = l(M&#39;) +
l(M&#39;&#39;).\]</span></em></p>
</div>
<div class="corollary">
<p><strong>Corolar 1.28</strong>. <em>Fie <span
class="math inline">\(M\)</span> un <span
class="math inline">\(R\)</span>-modul de lungime finitÄƒ ÅŸi <span
class="math inline">\(N,L\)</span> douÄƒ submodule ale sale.
Atunci:</em></p>
<ol>
<li><p><em><span class="math inline">\(l(M) = l(N) +
l(M/N)\)</span>;</em></p></li>
<li><p><em><span class="math inline">\(l(N+L) + l(N\cap L) = l(N) +
l(L)\)</span>.</em></p></li>
</ol>
</div>
<div class="corollary">
<p><strong>Corolar 1.29</strong>. <em>Fie <span
class="math inline">\(M\)</span> un <span
class="math inline">\(R\)</span>-modul de lungime finitÄƒ ÅŸi <span
class="math inline">\(M_1,M_2,\ldots,M_n\)</span> submodule ale sale
astfel Ã®ncÃ¢t <span class="math display">\[M = M_1 \oplus M_2 \oplus
\cdots \oplus M_n.\]</span> Atunci <span class="math display">\[l(M) =
\sum_{i=1}^{n} l(M_i).\]</span></em></p>
</div>
<h2 id="radicalul-jacobson">Radicalul Jacobson</h2>
<h3 class="unnumbered" id="radicalul-jacobson-al-unui-modul">Radicalul
Jacobson al unui modul</h3>
<div class="definition">
<p><strong>DefiniÅ£ie 1.30</strong>. Fie <span
class="math inline">\(M\)</span> un <span
class="math inline">\(R\)</span>-modul. IntersecÅ£ia tuturor submodulelor
maximale ale lui <span class="math inline">\(M\)</span> se numeÅŸte
<em>radicalul Jacobson</em> al modulului <span
class="math inline">\(M\)</span> ÅŸi se noteazÄƒ <span
class="math inline">\(\mathop{\mathrm{Rad}}(M)\)</span>. DacÄƒ <span
class="math inline">\(M\)</span> nu are nici un submodul maximal, atunci
prin convenÅ£ie punem <span
class="math inline">\(\mathop{\mathrm{Rad}}(M)=M\)</span>.</p>
</div>
<div class="remark">
<p><em>ObservaÅ£ie 1.31</em>. DacÄƒ <span class="math inline">\(M\)</span>
este un <span class="math inline">\(R\)</span>-modul finit generat,
atunci <span class="math inline">\(\mathop{\mathrm{Rad}}(M)\ne
M\)</span>.</p>
</div>
<div class="proposition">
<p><strong>PropoziÅ£ie 1.32</strong>. <em>Fie <span
class="math inline">\(M\)</span> un <span
class="math inline">\(R\)</span>-modul. Atunci <span
class="math display">\[\mathop{\mathrm{Rad}}(M)
  = \bigcap_{\substack{f : M \to S\\ S\ \text{simplu}}} \ker(f)
  = \bigcap_{\substack{f : M \to X\\ X\ \text{semisimplu}}}
\ker(f).\]</span></em></p>
</div>
<div class="proposition">
<p><strong>PropoziÅ£ie 1.33</strong>. <em>Fie <span
class="math inline">\(f : M \to N\)</span> un morfism de <span
class="math inline">\(R\)</span>-module. Atunci <span
class="math inline">\(f(\mathop{\mathrm{Rad}}(M)) \subseteq
\mathop{\mathrm{Rad}}(N)\)</span>. DacÄƒ, Ã®n plus, <span
class="math inline">\(f\)</span> este epimorfism ÅŸi <span
class="math inline">\(\ker(f) \subseteq
\mathop{\mathrm{Rad}}(M)\)</span>, atunci <span
class="math inline">\(f(\mathop{\mathrm{Rad}}(M)) =
\mathop{\mathrm{Rad}}(N)\)</span>.</em></p>
</div>
<div class="corollary">
<p><strong>Corolar 1.34</strong>. <em>Pentru orice <span
class="math inline">\(R\)</span>-modul <span
class="math inline">\(M\)</span> are loc egalitatea <span
class="math inline">\(\mathop{\mathrm{Rad}}(M/\mathop{\mathrm{Rad}}(M))
= 0\)</span>.</em></p>
</div>
<div class="corollary">
<p><strong>Corolar 1.35</strong>. <em>DacÄƒ <span
class="math inline">\(M\)</span> este un <span
class="math inline">\(R\)</span>-modul semisimplu, atunci <span
class="math inline">\(\mathop{\mathrm{Rad}}(M)=0\)</span>.</em></p>
</div>
<div class="corollary">
<p><strong>Corolar 1.36</strong>. <em>DacÄƒ <span class="math inline">\(M
= \bigoplus_{i\in I} M_i\)</span>, atunci <span
class="math display">\[\mathop{\mathrm{Rad}}(M) = \bigoplus_{i\in I}
\mathop{\mathrm{Rad}}(M_i).\]</span></em></p>
</div>
<div class="proposition">
<p><strong>PropoziÅ£ie 1.37</strong>. <em>Fie <span
class="math inline">\(M\)</span> un <span
class="math inline">\(R\)</span>-modul astfel Ã®ncÃ¢t <span
class="math inline">\(\mathop{\mathrm{Rad}}(M)\ne M\)</span>. Atunci
<span class="math display">\[\mathop{\mathrm{Rad}}(M)
  = \bigcap \{\,L \le M \mid L \text{ este submodul
superfluu}\,\}.\]</span></em></p>
</div>
<div class="proposition">
<p><strong>PropoziÅ£ie 1.38</strong> (Lema lui Nakayama). <em>Fie <span
class="math inline">\(M\)</span> un <span
class="math inline">\(R\)</span>-modul finit generat ÅŸi <span
class="math inline">\(N\)</span> un submodul al sÄƒu. DacÄƒ <span
class="math inline">\(N + \mathop{\mathrm{Rad}}(M) = M\)</span>, atunci
<span class="math inline">\(N = M\)</span>. (AdicÄƒ <span
class="math inline">\(\mathop{\mathrm{Rad}}(M)\)</span> este cel mai
mare submodul superfluu al lui <span
class="math inline">\(M\)</span>.)</em></p>
</div>
<h3 class="unnumbered" id="radicalul-jacobson-al-unui-inel">Radicalul
Jacobson al unui inel</h3>
<p>Fie <span class="math inline">\(R\)</span> un inel. ConsiderÄƒm
idealul stÃ¢ng <span class="math inline">\(\mathop{\mathrm{Rad}}({}_R
R)\)</span> ca intersecÅ£ie a idealelor stÃ¢ngi maximale ale lui <span
class="math inline">\(R\)</span> ÅŸi <span
class="math inline">\(\mathop{\mathrm{Rad}}(R_R)\)</span> ca intersecÅ£ie
a idealelor drepte maximale ale lui <span
class="math inline">\(R\)</span>.</p>
<div class="proposition">
<p><strong>PropoziÅ£ie 1.39</strong>. </p>
<ol>
<li><p><em><span
class="math inline">\(\mathop{\mathrm{Rad}}(R_R)\)</span> este un ideal
bilateral.</em></p></li>
<li><p><em><span class="math inline">\(\mathop{\mathrm{Rad}}(R_R) =
\{\,r \in R \mid 1-ar \in U(R)\ \text{pentru orice } a \in
R\,\}\)</span>.</em></p></li>
<li><p><em><span class="math inline">\(\mathop{\mathrm{Rad}}(R_R) =
\mathop{\mathrm{Rad}}({}_R R)\)</span>.</em></p></li>
</ol>
</div>
<div class="definition">
<p><strong>DefiniÅ£ie 1.40</strong>. Idealul bilateral <span
class="math inline">\(\mathop{\mathrm{Rad}}(R_R) =
\mathop{\mathrm{Rad}}({}_R R)\)</span> se numeÅŸte <em>radicalul
Jacobson</em> al inelului <span class="math inline">\(R\)</span> ÅŸi se
noteazÄƒ <span
class="math inline">\(\mathop{\mathrm{Rad}}(R)\)</span>.</p>
</div>
<div class="proposition">
<p><strong>PropoziÅ£ie 1.41</strong>. </p>
<ol>
<li><p><em>DacÄƒ <span class="math inline">\(J\)</span> este un ideal
stÃ¢ng (resp.Â drept sau bilateral) cu proprietatea cÄƒ <span
class="math inline">\(1-x\)</span> este inversabil pentru orice <span
class="math inline">\(x \in J\)</span>, atunci <span
class="math inline">\(J \subseteq
\mathop{\mathrm{Rad}}(R)\)</span>.</em></p></li>
<li><p><em>DacÄƒ <span class="math inline">\(J\)</span> este un nilideal
stÃ¢ng (resp.Â drept sau bilateral), atunci <span class="math inline">\(J
\subseteq \mathop{\mathrm{Rad}}(R)\)</span>.</em></p></li>
</ol>
</div>
<div class="proposition">
<p><strong>PropoziÅ£ie 1.42</strong>. <em>Fie <span
class="math inline">\(\varphi : R \to S\)</span> un morfism surjectiv de
inele. Atunci <span
class="math inline">\(\varphi(\mathop{\mathrm{Rad}}(R)) \subseteq
\mathop{\mathrm{Rad}}(S)\)</span>. DacÄƒ <span
class="math inline">\(\ker(\varphi)
\subseteq \mathop{\mathrm{Rad}}(R)\)</span>, atunci <span
class="math inline">\(\varphi(\mathop{\mathrm{Rad}}(R)) =
\mathop{\mathrm{Rad}}(S)\)</span>.</em></p>
</div>
<div class="proposition">
<p><strong>PropoziÅ£ie 1.43</strong>. <em>DacÄƒ <span
class="math inline">\((R_i)_{i\in I}\)</span> este o familie de inele,
atunci <span
class="math display">\[\mathop{\mathrm{Rad}}\Bigl(\prod_{i\in I}
R_i\Bigr) = \prod_{i\in I} \mathop{\mathrm{Rad}}(R_i).\]</span></em></p>
</div>
<div class="proposition">
<p><strong>PropoziÅ£ie 1.44</strong>. <em>Fie <span
class="math inline">\(M\)</span> un <span
class="math inline">\(R\)</span>-modul. Atunci <span
class="math inline">\(M\,\mathop{\mathrm{Rad}}(R) \subseteq
\mathop{\mathrm{Rad}}(M)\)</span>.</em></p>
</div>
<div class="theorem">
<p><strong>TeoremÄƒ 1.45</strong>. <em>DacÄƒ <span
class="math inline">\(R\)</span> este un inel artinian, atunci <span
class="math inline">\(\mathop{\mathrm{Rad}}(R)\)</span> este
nilpotent.</em></p>
</div>
<h2 id="inele-semisimple">Inele semisimple</h2>
<div class="theorem">
<p><strong>TeoremÄƒ 1.46</strong>. <em>Pentru un inel <span
class="math inline">\(R\)</span> urmÄƒtoarele afirmaÅ£ii sunt
echivalente:</em></p>
<ol>
<li><p><em>orice <span class="math inline">\(R\)</span>-modul drept
nenul este semisimplu;</em></p></li>
<li><p><em><span class="math inline">\(R\)</span> este <span
class="math inline">\(R\)</span>-modul drept semisimplu;</em></p></li>
<li><p><em><span class="math inline">\(R\)</span> este artinian ÅŸi <span
class="math inline">\(\mathop{\mathrm{Rad}}(R)=0\)</span>.</em></p></li>
</ol>
</div>
<div class="definition">
<p><strong>DefiniÅ£ie 1.47</strong>. Un inel <span
class="math inline">\(R\)</span> care satisface una din condiÅ£iile de
mai sus se numeÅŸte <em>inel semisimplu</em>.</p>
</div>
<div class="proposition">
<p><strong>PropoziÅ£ie 1.48</strong>. <em>Fie <span
class="math inline">\(R\)</span> un inel semisimplu ÅŸi <span
class="math inline">\(M\)</span> un <span
class="math inline">\(R\)</span>-modul nenul. UrmÄƒtoarele afirmaÅ£ii sunt
echivalente:</em></p>
<ol>
<li><p><em><span class="math inline">\(M\)</span> este de lungime
finitÄƒ;</em></p></li>
<li><p><em><span class="math inline">\(M\)</span> este
noetherian;</em></p></li>
<li><p><em><span class="math inline">\(M\)</span> este
artinian.</em></p></li>
</ol>
</div>
<div class="theorem">
<p><strong>TeoremÄƒ 1.49</strong>. <em>Fie <span
class="math inline">\(R\)</span> un inel artinian la dreapta ÅŸi <span
class="math inline">\(M\)</span> un <span
class="math inline">\(R\)</span>-modul nenul. UrmÄƒtoarele afirmaÅ£ii sunt
echivalente:</em></p>
<ol>
<li><p><em><span class="math inline">\(M\)</span> este de lungime
finitÄƒ;</em></p></li>
<li><p><em><span class="math inline">\(M\)</span> este
noetherian;</em></p></li>
<li><p><em><span class="math inline">\(M\)</span> este
artinian.</em></p></li>
</ol>
</div>
<div class="corollary">
<p><strong>Corolar 1.50</strong> (Hopkins). <em>Un inel artinian la
dreapta (respectiv la stÃ¢nga) este noetherian la dreapta (respectiv la
stÃ¢nga).</em></p>
</div>
<h1 id="submodule-esenÅ£iale">Submodule esenÅ£iale</h1>
<div id="def:submodul-esential" class="definition">
<p><strong>DefiniÅ£ie 2.1</strong>. Fie <span
class="math inline">\(M\)</span> un <span
class="math inline">\(R\)</span>-modul drept. Un submodul <span
class="math inline">\(N\)</span> al lui <span
class="math inline">\(M\)</span> se numeÅŸte <em>esenÅ£ial</em> (sau
spunem cÄƒ <span class="math inline">\(M\)</span> este o extensie
esenÅ£ialÄƒ a lui <span class="math inline">\(N\)</span>) dacÄƒ <span
class="math inline">\(N \cap N&#39; \neq 0\)</span> pentru orice
submodul nenul <span class="math inline">\(N&#39;\)</span> al lui <span
class="math inline">\(M\)</span>. Ãn acest caz vom folosi notaÅ£ia <span
class="math inline">\(N \trianglelefteq M_R\)</span>.</p>
<p>Un monomorfism de <span class="math inline">\(R\)</span>-module la
dreapta <span class="math inline">\(f : M \to N\)</span> se numeÅŸte
<em>esenÅ£ial</em> dacÄƒ <span class="math inline">\(\operatorname{Im}
f\)</span> este submodul esenÅ£ial Ã®n <span
class="math inline">\(N\)</span> (adicÄƒ <span
class="math inline">\(\operatorname{Im} f \trianglelefteq
N_R\)</span>).</p>
</div>
<div class="example*">
<p><strong>Exemplu 2.1</strong>. </p>
<ol>
<li><p><span class="math inline">\(n\mathbb{Z}
\trianglelefteq\mathbb{Z}_\mathbb{Z}\)</span> pentru orice <span
class="math inline">\(n \geq 1\)</span>.</p></li>
<li><p>Orice submodul al lui <span
class="math inline">\(\mathbb{Z}_{p^\infty}\)</span> este
esenÅ£ial.</p></li>
</ol>
</div>
<div class="remark">
<p><em>ObservaÅ£ie 2.2</em>. Fie <span class="math inline">\(M\)</span>
un <span class="math inline">\(R\)</span>-modul drept ÅŸi <span
class="math inline">\(N\)</span> un submodul al lui <span
class="math inline">\(M\)</span>. Atunci <span class="math inline">\(N
\trianglelefteq M_R\)</span> dacÄƒ ÅŸi numai dacÄƒ pentru orice <span
class="math inline">\(x \in M\)</span>, <span class="math inline">\(x
\neq 0\)</span>, existÄƒ <span class="math inline">\(r \in R\)</span>
astfel Ã®ncÃ¢t <span class="math inline">\(xr \in N \setminus
\{0\}\)</span>.</p>
</div>
<div class="proof">
<p><em>Proof.</em> â€<span class="math inline">\(\Rightarrow\)</span>â€
Fie <span class="math inline">\(x \in M \setminus \{0\}\)</span>. Cum
<span class="math inline">\(0 \neq xR \subseteq M_R\)</span> ÅŸi <span
class="math inline">\(N \trianglelefteq M_R\)</span>, rezultÄƒ cÄƒ <span
class="math inline">\(xR \cap N \neq 0\)</span>, deci existÄƒ <span
class="math inline">\(xr \in xR \cap N \setminus \{0\}\)</span>.</p>
<p>â€<span class="math inline">\(\Leftarrow\)</span>â€ Fie <span
class="math inline">\(N&#39; \leq M_R\)</span>, <span
class="math inline">\(N&#39; \neq 0\)</span>. Pentru <span
class="math inline">\(x \in N&#39; \setminus \{0\}\)</span> existÄƒ <span
class="math inline">\(r \in R\)</span> astfel Ã®ncÃ¢t <span
class="math inline">\(xr \in N \setminus \{0\}\)</span>, deci <span
class="math inline">\(N \cap N&#39; \neq 0\)</span>.Â â—»</p>
</div>
<div class="definition">
<p><strong>DefiniÅ£ie 2.3</strong>. Un monomorfism de <span
class="math inline">\(R\)</span>-module la dreapta <span
class="math inline">\(f : N_R \to M_R\)</span> se numeÅŸte esenÅ£ial dacÄƒ
<span class="math inline">\(\operatorname{Im} f \trianglelefteq
M_R\)</span>. Se observÄƒ imediat cÄƒ dacÄƒ <span
class="math inline">\(N\)</span> este un submodul al lui <span
class="math inline">\(M\)</span> atunci incluziunea canonicÄƒ <span
class="math inline">\(i_N : N \to M\)</span> este monomorfism esenÅ£ial
dacÄƒ ÅŸi numai dacÄƒ <span class="math inline">\(N \trianglelefteq
M_R\)</span>.</p>
</div>
<div class="proposition">
<p><strong>PropoziÅ£ie 2.4</strong>. <em>Un monomorfism <span
class="math inline">\(f : N_R \to M_R\)</span> este esenÅ£ial dacÄƒ ÅŸi
numai dacÄƒ pentru orice <span class="math inline">\(R\)</span>-modul
drept <span class="math inline">\(M&#39;\)</span> ÅŸi orice <span
class="math inline">\(g \in \mathop{\mathrm{Hom}}(M,M&#39;)\)</span>,
faptul cÄƒ <span class="math inline">\(g \circ f\)</span> este
monomorfism implicÄƒ <span class="math inline">\(g\)</span>
monomorfism.</em></p>
</div>
<div class="proof">
<p><em>Proof.</em> <br />
â€<span class="math inline">\(\Rightarrow\)</span>â€ Fie <span
class="math inline">\(g\)</span> ca Ã®n enunÅ£ astfel Ã®ncÃ¢t <span
class="math inline">\(g \circ f\)</span> este monomorfism. Presupunem
<span class="math inline">\(g \neq 0\)</span>. Fie <span
class="math inline">\(x \in \mathop{\mathrm{Ker}}g \cap
\operatorname{Im} f \setminus \{0\}\)</span>. ExistÄƒ <span
class="math inline">\(x&#39; \in N\)</span> astfel Ã®ncÃ¢t <span
class="math inline">\(x = f(x&#39;)\)</span> ÅŸi <span
class="math inline">\(g(x) = 0\)</span>, de unde <span
class="math inline">\(g(f(x&#39;)) = 0\)</span>. Cum <span
class="math inline">\(g \circ f\)</span> este monomorfism, rezultÄƒ <span
class="math inline">\(x&#39; = 0\)</span> ÅŸi deci <span
class="math inline">\(x = 0\)</span>, contradicÅ£ie.</p>
<p>â€<span class="math inline">\(\Leftarrow\)</span>â€ DacÄƒ <span
class="math inline">\(f\)</span> nu este monomorfism esenÅ£ial atunci
existÄƒ <span class="math inline">\(N&#39; \leq M_R\)</span>, <span
class="math inline">\(N&#39; \neq 0\)</span>, astfel Ã®ncÃ¢t <span
class="math inline">\(N&#39; \cap \operatorname{Im} f = 0\)</span>.
ConsiderÄƒm proiecÅ£ia canonicÄƒ <span class="math inline">\(\pi_{N&#39;} :
M \to M/N&#39;\)</span>. DacÄƒ <span class="math inline">\(x \in
\mathop{\mathrm{Ker}}(\pi_{N&#39;} \circ f)\)</span>, atunci <span
class="math inline">\(f(x) \in N&#39;\)</span>, deci <span
class="math inline">\(f(x) = 0\)</span>, adicÄƒ <span
class="math inline">\(x = 0\)</span>. ObÅ£inem astfel cÄƒ <span
class="math inline">\(\pi_{N&#39;} \circ f\)</span> este injectiv, de
unde rezultÄƒ cÄƒ <span class="math inline">\(\pi_{N&#39;}\)</span> este
injectiv, ceea ce implicÄƒ <span class="math inline">\(N&#39; =
0\)</span>, contradicÅ£ie.Â â—»</p>
</div>
<div class="corollary">
<p><strong>Corolar 2.5</strong>. <em>Fie <span
class="math inline">\(M\)</span> un <span
class="math inline">\(R\)</span>-modul la dreapta ÅŸi <span
class="math inline">\(N \leq M_R\)</span>. Atunci urmÄƒtoarele afirmaÅ£ii
sunt echivalente:</em></p>
<ol>
<li><p><em><span class="math inline">\(N \trianglelefteq
M_R\)</span>;</em></p></li>
<li><p><em>incluziunea <span class="math inline">\(i_N : N \to
M\)</span> este monomorfism esenÅ£ial;</em></p></li>
<li><p><em>pentru orice <span class="math inline">\(f \in
\mathop{\mathrm{Hom}}(M,M&#39;)\)</span> cu <span
class="math inline">\(M&#39;\)</span> <span
class="math inline">\(R\)</span>-modul arbitrar, faptul cÄƒ <span
class="math inline">\(f \circ i_N\)</span> este monomorfism implicÄƒ
<span class="math inline">\(f\)</span> monomorfism.</em></p></li>
</ol>
</div>
<div class="proposition">
<p><strong>PropoziÅ£ie 2.6</strong>. <em>Fie <span
class="math inline">\(f : N_R \to M_R\)</span> ÅŸi <span
class="math inline">\(g : M_R \to P_R\)</span> douÄƒ monomorfisme. Atunci
<span class="math inline">\(g \circ f\)</span> este esenÅ£ial dacÄƒ ÅŸi
numai dacÄƒ <span class="math inline">\(g\)</span> ÅŸi <span
class="math inline">\(f\)</span> sunt esenÅ£iale.</em></p>
</div>
<div class="proof">
<p><em>Proof.</em> <br />
â€<span class="math inline">\(\Leftarrow\)</span>â€ Fie <span
class="math inline">\(z \in P \setminus \{0\}\)</span>. Cum <span
class="math inline">\(g\)</span> este esenÅ£ial, existÄƒ <span
class="math inline">\(r \in R\)</span> astfel Ã®ncÃ¢t <span
class="math inline">\(zr \in \operatorname{Im} g \setminus
\{0\}\)</span>. ExistÄƒ <span class="math inline">\(y \in M \setminus
\{0\}\)</span> astfel Ã®ncÃ¢t <span class="math inline">\(zr =
g(y)\)</span>.</p>
<p>Cum <span class="math inline">\(f\)</span> este esenÅ£ial, existÄƒ
<span class="math inline">\(r&#39; \in R\)</span> astfel Ã®ncÃ¢t <span
class="math inline">\(y r&#39; \in \mathrm{Im}\, f \setminus
\{0\}\)</span>. De aici existÄƒ <span class="math inline">\(x \in N
\setminus \{0\}\)</span> astfel Ã®ncÃ¢t <span class="math inline">\(y
r&#39; = f(x)\)</span>. Dar <span class="math inline">\(zr&#39; = g(y)
r&#39; = g(y r&#39;) = g(f(x))\)</span>. DacÄƒ <span
class="math inline">\(zr&#39; = 0\)</span>, atunci <span
class="math inline">\(g(f(x)) = 0\)</span> ÅŸi deci <span
class="math inline">\(x = 0\)</span>, contradicÅ£ie. ObÅ£inem astfel cÄƒ
<span class="math inline">\(zr&#39; \in \mathrm{Im}(g \circ f)\)</span>
ÅŸi cÄƒ <span class="math inline">\(zr&#39; \neq 0\)</span>, ceea ce ne
aratÄƒ cÄƒ <span class="math inline">\(g \circ f\)</span> este
esenÅ£ial.</p>
<p>â€<span class="math inline">\(\Rightarrow\)</span>â€ Fie <span
class="math inline">\(y \in M \setminus \{0\}\)</span>. Cum <span
class="math inline">\(g\)</span> este monomorfism, <span
class="math inline">\(g(y) \neq 0\)</span>. Deci existÄƒ <span
class="math inline">\(r \in R\)</span> astfel Ã®ncÃ¢t <span
class="math inline">\(g(yr) \in \mathrm{Im}\, g \setminus \{0\}\)</span>
ÅŸi <span class="math inline">\(g(yr) \neq 0\)</span>. RezultÄƒ cÄƒ existÄƒ
<span class="math inline">\(x \in N \setminus \{0\}\)</span> astfel
Ã®ncÃ¢t <span class="math inline">\(g(yr) = g(f(x))\)</span> de unde <span
class="math inline">\(yr = f(x) \in \mathrm{Im}\, f\)</span>, ceea ce ne
aratÄƒ cÄƒ <span class="math inline">\(f\)</span> este monomorfism
esenÅ£ial.</p>
<p>DacÄƒ <span class="math inline">\(z \in P \setminus \{0\}\)</span>
existÄƒ <span class="math inline">\(r \in R\)</span> astfel Ã®ncÃ¢t <span
class="math inline">\(zr \in \mathrm{Im}(g \circ f)\)</span> ÅŸi <span
class="math inline">\(zr \neq 0\)</span>. Cum <span
class="math inline">\(\mathrm{Im}(g \circ f) \subseteq \mathrm{Im}
g\)</span>, rezultÄƒ cÄƒ <span class="math inline">\(zr \in \mathrm{Im}
g\)</span>, ÅŸi deci <span class="math inline">\(g\)</span> este
monomorfism esenÅ£ial.Â â—»</p>
</div>
<div class="proposition">
<p><strong>PropoziÅ£ie 2.7</strong>. <em>Fie <span
class="math inline">\(M\)</span> un <span
class="math inline">\(R\)</span>-modul la dreapta ÅŸi <span
class="math inline">\(L_1, L_2, \ldots, L_n\)</span> submodule ale lui
<span class="math inline">\(M\)</span>. Atunci:</em></p>
<p><em>1) <span class="math inline">\(\displaystyle \bigcap_{i=1}^n
L_i\)</span> este esenÅ£ial Ã®n <span class="math inline">\(M\)</span>
dacÄƒ ÅŸi numai dacÄƒ <span class="math inline">\(L_i\)</span> este
esenÅ£ial Ã®n <span class="math inline">\(M\)</span> pentru orice <span
class="math inline">\(i = 1,\ldots,n\)</span>.</em></p>
<p><em>2) DacÄƒ <span class="math inline">\(L_1 \subseteq L_2\)</span> ÅŸi
<span class="math inline">\(L_1\)</span> este esenÅ£ial Ã®n <span
class="math inline">\(M\)</span>, atunci <span
class="math inline">\(L_2\)</span> este esenÅ£ial Ã®n <span
class="math inline">\(M\)</span>.</em></p>
<p><em>DemonstraÅ£ia este evidentÄƒ.</em></p>
</div>
<div class="proposition">
<p><strong>PropoziÅ£ie 2.8</strong>. <em>Fie <span
class="math inline">\(K\)</span> ÅŸi <span
class="math inline">\(L\)</span> douÄƒ submodule ale lui <span
class="math inline">\(M\)</span>. 1) DacÄƒ <span class="math inline">\(K
\subseteq L \subseteq M\)</span>, atunci <span class="math inline">\(K
\, \trianglelefteq\, M\)</span> dacÄƒ ÅŸi numai dacÄƒ <span
class="math inline">\(K \, \trianglelefteq\, L\)</span> ÅŸi <span
class="math inline">\(L \, \trianglelefteq\, M\)</span>.</em></p>
<p><em>2) DacÄƒ <span class="math inline">\(h : K_R \to M_R\)</span> este
morfism de module ÅŸi <span class="math inline">\(L \, \trianglelefteq\,
M\)</span>, atunci <span class="math inline">\(h^{-1}(L) \,
\trianglelefteq\, K\)</span>.</em></p>
<p><em>3) DacÄƒ <span class="math inline">\(L_1, L_2 \leq M_R\)</span> ÅŸi
<span class="math inline">\(K_1 \, \trianglelefteq\, L_1\)</span>, <span
class="math inline">\(K_2 \, \trianglelefteq\, L_2\)</span>, atunci
<span class="math inline">\(K_1 \cap K_2 \, \trianglelefteq\, L_1 \cap
L_2\)</span>.</em></p>
</div>
<div class="proof">
<p><em>Proof.</em> <br />
1) Se aplicÄƒ 1.5 ÅŸi 1.6.</p>
<p>2) Fie <span class="math inline">\(U\)</span> submodul nenul al lui
<span class="math inline">\(K\)</span>. (i) DacÄƒ <span
class="math inline">\(h(U) = 0\)</span>, atunci <span
class="math inline">\(U \subseteq \ker h \subseteq h^{-1}(L)\)</span>,
ceea ce implicÄƒ <span class="math inline">\(U \cap h^{-1}(L) \neq
0\)</span>. (ii) DacÄƒ <span class="math inline">\(h(U) \neq 0\)</span>,
atunci <span class="math inline">\(h(U) \cap L \neq 0\)</span> ÅŸi deci
existÄƒ <span class="math inline">\(u \in U\)</span> astfel Ã®ncÃ¢t <span
class="math inline">\(h(u) \in L\)</span>, <span
class="math inline">\(h(u) \neq 0\)</span>, de unde <span
class="math inline">\(u \in U \cap h^{-1}(L)\)</span> ÅŸi <span
class="math inline">\(u \neq 0\)</span>. Din (i) ÅŸi (ii) rezultÄƒ cÄƒ
<span class="math inline">\(h^{-1}(L) \, \trianglelefteq\,
K\)</span>.</p>
<p>3) DacÄƒ <span class="math inline">\(0 \neq X \leq L_1 \cap
L_2\)</span> atunci <span class="math inline">\(X \subseteq L_1\)</span>
ceea ce implicÄƒ <span class="math inline">\(0 \neq X \cap K_1 \leq
L_1\)</span>. Dar cum <span class="math inline">\(X \subseteq
L_2\)</span>, rezultÄƒ <span class="math inline">\(0 \neq (X \cap K_1)
\cap L_2 = X \cap (K_1 \cap K_2)\)</span>, ÅŸi deci <span
class="math inline">\(K_1 \cap K_2 \, \trianglelefteq\, L_1 \cap
L_2\)</span>.Â â—»</p>
</div>
<div class="proposition">
<p><strong>PropoziÅ£ie 2.9</strong>. <em>Fie <span
class="math inline">\((K_\lambda)_{\lambda \in \Lambda}\)</span>, <span
class="math inline">\((L_\lambda)_{\lambda \in \Lambda}\)</span> douÄƒ
familii de submodule ale lui <span class="math inline">\(M\)</span>.
DacÄƒ <span class="math inline">\((K_\lambda)_{\lambda \in
\Lambda}\)</span> este familie independentÄƒ Ã®n <span
class="math inline">\(M\)</span> ÅŸi <span
class="math inline">\(K_\lambda \, \trianglelefteq\, L_\lambda\)</span>
pentru orice <span class="math inline">\(\lambda \in \Lambda\)</span>,
atunci <span class="math inline">\((L_\lambda)_{\lambda \in
\Lambda}\)</span> este familie independentÄƒ Ã®n <span
class="math inline">\(M\)</span> ÅŸi <span
class="math inline">\((\oplus_{\lambda \in \Lambda} K_\lambda) \,
\trianglelefteq\,
(\oplus_{\lambda \in \Lambda} L_\lambda)\)</span>.</em></p>
</div>
<div class="proof">
<p><em>Proof.</em> <br />
Fie <span class="math inline">\(K_1 \, \trianglelefteq\, L_1\)</span>,
<span class="math inline">\(K_2 \, \trianglelefteq\, L_2\)</span> astfel
Ã®ncÃ¢t <span class="math inline">\(K_1 \cap K_2 = 0\)</span>. Din 1.8(3)
rezultÄƒ cÄƒ <span class="math inline">\(0 \, \trianglelefteq\, L_1 \cap
L_2\)</span>, adicÄƒ <span class="math inline">\(L_1 \cap L_2 =
0\)</span>.</p>
<p>Fie proiecÅ£iile canonice <span class="math inline">\(\pi_1 : L_1
\oplus L_2 \to L_1\)</span>, <span class="math inline">\(\pi_2 : L_1
\oplus L_2 \to L_2\)</span>. Cum <span class="math inline">\(K_1 \,
\trianglelefteq\, L_1\)</span>, <span class="math inline">\(K_2 \,
\trianglelefteq\, L_2\)</span> rezultÄƒ cÄƒ</p>
<p><span class="math display">\[\pi_1^{-1}(K_1)
  = K_1 \oplus 0 \, \trianglelefteq\, L_1 \oplus L_2,\]</span> ÅŸi <span
class="math display">\[\pi_2^{-1}(K_2)
  = 0 \oplus K_2 \, \trianglelefteq\, L_1 \oplus L_2.\]</span></p>
<p>Deci <span class="math display">\[K_1 \oplus K_2
  = (\pi_1^{-1}(K_1)) \cap (\pi_2^{-1}(K_2))
  \, \trianglelefteq\, L_1 \oplus L_2.\]</span></p>
<p>Prin inducÅ£ie se obÅ£ine afirmaÅ£ia pentru mulÅ£imi finite. Ãn cazul
general, fie <span class="math inline">\(0 \neq m \in \oplus_{\lambda
\in \Lambda} L_\lambda\)</span>. Atunci existÄƒ o mulÅ£ime finitÄƒ <span
class="math inline">\(\Lambda_0 \subseteq \Lambda\)</span> cu <span
class="math inline">\(m \in \oplus_{\lambda \in \Lambda_0}
L_\lambda\)</span>. Cum <span class="math inline">\((\oplus_{\lambda \in
\Lambda_0} K_\lambda) \, \trianglelefteq\,
(\oplus_{\lambda \in \Lambda_0} L_\lambda)\)</span>, existÄƒ <span
class="math inline">\(r \in R\)</span> astfel Ã®ncÃ¢t <span
class="math inline">\(rm \in (\oplus_{\lambda \in \Lambda_0} K_\lambda)
\setminus \{0\}
\subseteq (\oplus_{\lambda \in \Lambda} K_\lambda) \setminus
\{0\}\)</span>. RezultÄƒ cÄƒ <span class="math inline">\((\oplus_{\lambda
\in \Lambda} K_\lambda) \, \trianglelefteq\,
(\oplus_{\lambda \in \Lambda} L_\lambda)\)</span>.Â â—»</p>
</div>
<div class="proposition">
<p><strong>PropoziÅ£ie 2.10</strong>. <em>Fie <span
class="math inline">\(N\)</span> un submodul al lui <span
class="math inline">\(M\)</span>. Atunci existÄƒ un submodul <span
class="math inline">\(Q\)</span>, <span class="math inline">\(N
\subseteq Q \subseteq M\)</span>, astfel Ã®ncÃ¢t <span
class="math inline">\(Q\)</span> este o extensie esenÅ£ialÄƒ maximalÄƒ a
lui <span class="math inline">\(N\)</span> conÅ£inutÄƒ Ã®n <span
class="math inline">\(M\)</span>.</em></p>
</div>
<div class="proof">
<p><em>Proof.</em> <br />
Fie <span class="math inline">\(\mathfrak{S} = \{ L \leq M ; \; N
\subseteq L \subseteq M, \; N \, \ulcorner \, L \}\)</span>, <span
class="math inline">\(\mathfrak{S}\)</span> cu relaÅ£ia de ordine
incluziunea. <span class="math inline">\(\mathfrak{S} \neq
\varnothing\)</span> deoarece <span class="math inline">\(N \in
\mathfrak{S}\)</span>. Fie <span
class="math inline">\((L_\lambda)_{\lambda \in \Lambda}\)</span> o
familie total ordonatÄƒ de elemente din <span
class="math inline">\(\mathfrak{S}\)</span> ÅŸi <span
class="math display">\[L := \bigcup_{\lambda \in \Lambda}
L_\lambda.\]</span> Evident <span class="math inline">\(L \leq
M_R\)</span>.</p>
<p>Fie <span class="math inline">\(x \in L \setminus \{0\}\)</span>.
Atunci existÄƒ <span class="math inline">\(\lambda_0 \in \Lambda\)</span>
cu <span class="math inline">\(x \in L_{\lambda_0}\)</span>. Cum <span
class="math inline">\(N\)</span> este esenÅ£ial Ã®n <span
class="math inline">\(L_{\lambda_0}\)</span>, rezultÄƒ cÄƒ existÄƒ <span
class="math inline">\(r \in R\)</span> astfel Ã®ncÃ¢t <span
class="math inline">\(xr \in N\)</span> ÅŸi <span
class="math inline">\(xr \neq 0\)</span>, de unde obÅ£inem cÄƒ <span
class="math inline">\(L\)</span> este extensie esenÅ£ialÄƒ a lui <span
class="math inline">\(N\)</span>. Deci <span
class="math inline">\(\mathfrak{S}\)</span> este inductivÄƒ ÅŸi, conform
lemei lui Zorn, <span class="math inline">\(\mathfrak{S}\)</span> admite
un element maximal <span class="math inline">\(Q\)</span> care satisface
condiÅ£iile cerute.Â â—»</p>
</div>
<div class="definition">
<p><strong>DefiniÅ£ie 2.11</strong>. Fie <span
class="math inline">\(M\)</span> un <span
class="math inline">\(R\)</span>-modul la dreapta ÅŸi <span
class="math inline">\(N \leq M_R\)</span>. Un submodul <span
class="math inline">\(K \leq M_R\)</span> se numeÅŸte <em>complement</em>
al lui <span class="math inline">\(N\)</span> Ã®n <span
class="math inline">\(M\)</span> dacÄƒ <span
class="math inline">\(K\)</span> este un submodul maximal al lui <span
class="math inline">\(M\)</span> cu proprietatea cÄƒ <span
class="math inline">\(K \cap N = 0\)</span>. Un submodul <span
class="math inline">\(K \leq M_R\)</span> se numeÅŸte <em>submodul
complement al lui <span class="math inline">\(M\)</span></em> dacÄƒ
existÄƒ <span class="math inline">\(N \leq M_R\)</span> astfel Ã®ncÃ¢t
<span class="math inline">\(K\)</span> este complement al lui <span
class="math inline">\(N\)</span> Ã®n <span
class="math inline">\(M\)</span>.</p>
</div>
<div class="remark">
<p><em>ObservaÅ£ie 2.12</em>. MulÅ£imea <span
class="math display">\[\widetilde{\mathfrak{S}}
  = \{\,L \leq M_R \mid N \cap L = 0\,\}\]</span> este inductivÄƒ ÅŸi,
aplicÃ¢nd lema lui Zorn, rezultÄƒ cÄƒ existÄƒ un complement al lui <span
class="math inline">\(N\)</span> Ã®n <span
class="math inline">\(M\)</span>. Ãn particular, <span
class="math inline">\(0\)</span> ÅŸi <span
class="math inline">\(M\)</span> sunt submodule complement ale lui <span
class="math inline">\(M\)</span>.</p>
</div>
<div class="proposition">
<p><strong>PropoziÅ£ie 2.13</strong>. <em>Fie <span
class="math inline">\(M_R\)</span>, <span class="math inline">\(N \leq
M_R\)</span> ÅŸi <span class="math inline">\(K \leq M_R\)</span>, <span
class="math inline">\(K\)</span> un complement al lui <span
class="math inline">\(N\)</span> Ã®n <span
class="math inline">\(M\)</span>. ExistÄƒ un complement <span
class="math inline">\(Q\)</span> al lui <span
class="math inline">\(K\)</span> Ã®n <span
class="math inline">\(M\)</span> astfel Ã®ncÃ¢t <span
class="math inline">\(N \subseteq Q\)</span>. Mai mult, <span
class="math inline">\(Q\)</span> este o extensie esenÅ£ialÄƒ maximalÄƒ a
lui <span class="math inline">\(N\)</span> Ã®n <span
class="math inline">\(M\)</span>.</em></p>
</div>
<div class="proof">
<p><em>Proof.</em> Se observÄƒ uÅŸor cÄƒ mulÅ£imea <span
class="math display">\[\widetilde{\mathfrak{S}}
  = \{\,L \leq M_R \mid K \cap L = 0,\; N \subseteq L\,\}\]</span> este
inductivÄƒ ÅŸi lema lui Zorn asigurÄƒ existenÅ£a lui <span
class="math inline">\(Q\)</span>.</p>
<p>Fie <span class="math inline">\(L\)</span> un submodul nenul al lui
<span class="math inline">\(Q\)</span> astfel Ã®ncÃ¢t <span
class="math inline">\(L \cap N = 0\)</span>. Fie <span
class="math inline">\(K_1 = L + K\)</span>. Este clar cÄƒ <span
class="math inline">\(K \subseteq K_1\)</span>. DacÄƒ <span
class="math inline">\(x \in N \cap (L + K)\)</span>, atunci <span
class="math inline">\(x = y + z\)</span> cu <span
class="math inline">\(y \in L\)</span>, <span class="math inline">\(z
\in K\)</span>. Dar <span class="math inline">\(z = x - y \in
Q\)</span>. Cum <span class="math inline">\(Q \cap K = 0\)</span>,
rezultÄƒ <span class="math inline">\(z = 0\)</span> ÅŸi deci <span
class="math inline">\(x = y\)</span>. Din egalitatea <span
class="math inline">\(L \cap N = 0\)</span> deducem <span
class="math inline">\(x = y = 0\)</span> ÅŸi deci <span
class="math inline">\(N \cap (L + K) = 0\)</span>, ceea ce contrazice
faptul cÄƒ <span class="math inline">\(K\)</span> este un complement al
lui <span class="math inline">\(N\)</span> Ã®n <span
class="math inline">\(M\)</span>. ObÅ£inem <span class="math inline">\(L
\cap N \neq 0\)</span> pentru orice <span class="math inline">\(0 \neq L
\leq Q\)</span>, de unde <span class="math inline">\(Q\)</span> este
extensie esenÅ£ialÄƒ a lui <span class="math inline">\(N\)</span>.</p>
<p>Presupunem cÄƒ existÄƒ <span class="math inline">\(Q&#39; \leq
M_R\)</span> cu <span class="math inline">\(N \trianglelefteq
Q&#39;\)</span> ÅŸi <span class="math inline">\(Q \subsetneq
Q&#39;\)</span>. Cum <span class="math inline">\(Q&#39;\)</span> este
complement al lui <span class="math inline">\(K\)</span>, rezultÄƒ <span
class="math inline">\(Q&#39; \cap K \neq 0\)</span>. Dar <span
class="math inline">\(N \cap (Q&#39; \cap K) = 0\)</span> ÅŸi <span
class="math inline">\(0 \neq Q&#39; \cap K \leq Q&#39;\)</span>,
contradicÅ£ie cu <span class="math inline">\(N \trianglelefteq
Q&#39;\)</span>. RezultÄƒ cÄƒ <span class="math inline">\(Q\)</span> este
extensie esenÅ£ialÄƒ maximalÄƒ a lui <span class="math inline">\(N\)</span>
Ã®n <span class="math inline">\(M\)</span>.Â â—»</p>
</div>
<div class="definition">
<p><strong>DefiniÅ£ie 2.14</strong>. Un submodul <span
class="math inline">\(N\)</span> al lui <span
class="math inline">\(M_R\)</span> se numeÅŸte <em>Ã®nchis</em> dacÄƒ <span
class="math inline">\(N\)</span> nu are nicio extensie esenÅ£ialÄƒ Ã®n
<span class="math inline">\(M\)</span> proprie (diferitÄƒ de <span
class="math inline">\(N\)</span>).</p>
</div>
<div class="corollary">
<p><strong>Corolar 2.15</strong>. <em>Fie <span
class="math inline">\(M_R\)</span> un <span
class="math inline">\(R\)</span>-modul. Submodulele complement ale lui
<span class="math inline">\(M\)</span> coincid cu submodulele Ã®nchise
ale lui <span class="math inline">\(M\)</span>.</em></p>
</div>
<div class="proof">
<p><em>Proof.</em> Din 1.13 rezultÄƒ imediat cÄƒ orice submodul Ã®nchis al
lui <span class="math inline">\(M\)</span> este un submodul complement
al lui <span class="math inline">\(M\)</span>.</p>
<p>Invers, fie <span class="math inline">\(K\)</span> un submodul
complement al lui <span class="math inline">\(M_R\)</span>. RezultÄƒ cÄƒ
existÄƒ <span class="math inline">\(N \leq M_R\)</span> astfel Ã®ncÃ¢t
<span class="math inline">\(K\)</span> este un complement al lui <span
class="math inline">\(N\)</span> Ã®n <span
class="math inline">\(M\)</span>. Presupunem cÄƒ <span
class="math inline">\(K\)</span> are o extensie esenÅ£ialÄƒ Ã®n <span
class="math inline">\(M\)</span> proprie, adicÄƒ existÄƒ <span
class="math inline">\(K&#39; \leq M_R\)</span> cu <span
class="math inline">\(K \trianglelefteq K&#39;\)</span> ÅŸi <span
class="math inline">\(K \subsetneq K&#39;\)</span>. Atunci <span
class="math inline">\(K&#39; \cap N \neq 0\)</span>, din maximalitatea
lui <span class="math inline">\(K\)</span>, iar cum <span
class="math inline">\(K \trianglelefteq K&#39;\)</span>, rezultÄƒ cÄƒ
<span class="math display">\[K \cap K&#39; \cap N \neq 0,\]</span>
contradicÅ£ie.Â â—»</p>
</div>
<div class="corollary">
<p><strong>Corolar 2.16</strong>. <em>Fie <span
class="math inline">\(N\)</span> un submodul al lui <span
class="math inline">\(M_R\)</span>. DacÄƒ <span
class="math inline">\(K\)</span> este un complement al lui <span
class="math inline">\(N\)</span> Ã®n <span
class="math inline">\(M\)</span>, atunci:</em></p>
<ol>
<li><p><em><span class="math inline">\((N + K) \trianglelefteq
M_R\)</span>.</em></p></li>
<li><p><em>Morfismul canonic <span class="math inline">\(\pi_K \circ i_N
: N \to M/K\)</span> este monomorfism esenÅ£ial.</em></p></li>
</ol>
</div>
<div class="proof">
<p><em>Proof.</em> (1) Fie <span class="math inline">\(x \in M \setminus
\{0\}\)</span>. DacÄƒ <span class="math inline">\(x \notin K\)</span>,
atunci <span class="math inline">\(K + Rx \neq K\)</span> ÅŸi deci <span
class="math inline">\(N \cap (K + Rx) \neq 0\)</span>. Fie <span
class="math inline">\(y \in N \cap (K + Rx)\)</span>, <span
class="math inline">\(y \neq 0\)</span>. ExistÄƒ <span
class="math inline">\(z \in K\)</span>, <span class="math inline">\(r
\in R\)</span> cu <span class="math inline">\(y = z + rx\)</span>. DacÄƒ
<span class="math inline">\(rx = 0\)</span>, atunci <span
class="math inline">\(y = z\)</span> ÅŸi cum <span
class="math inline">\(N \cap K = 0\)</span> rezultÄƒ <span
class="math inline">\(y = 0\)</span>, contradicÅ£ie. Deci <span
class="math inline">\(rx \neq 0\)</span> ÅŸi, cum <span
class="math inline">\(rx = y - z\)</span>, obÅ£inem <span
class="math inline">\(rx \in N + K\)</span>, ceea ce ne aratÄƒ cÄƒ <span
class="math inline">\((N + K) \trianglelefteq M_R\)</span>.</p>
<p>(2) <span class="math inline">\(\mathrm{Im}(\pi_K \circ i_N) = (N +
K)/K\)</span>. Fie <span class="math inline">\(L/K\)</span> un submodul
nenul al lui <span class="math inline">\(M/K\)</span>. Atunci <span
class="math display">\[\frac{N + K}{K} \cap \frac{L}{K}
   = \frac{(N + K) \cap L}{K}
   = \frac{N \cap L + K}{K}.\]</span> Cum <span
class="math inline">\(K\)</span> este un complement al lui <span
class="math inline">\(N\)</span>, rezultÄƒ cÄƒ <span
class="math inline">\(N \cap L \neq 0\)</span> ÅŸi deci <span
class="math display">\[\frac{N \cap L + K}{K} \neq 0,\]</span> ceea ce
ne aratÄƒ cÄƒ <span class="math inline">\(\pi_K \circ i_N\)</span> este
monomorfism esenÅ£ial.Â â—»</p>
</div>
<h1 id="module-injective">Module injective</h1>
<h2 id="module-injective-1">Module injective</h2>
<p>Fie <span class="math inline">\(Q\)</span> ÅŸi <span
class="math inline">\(M\)</span> douÄƒ <span
class="math inline">\(R\)</span>-module drepte. <span
class="math inline">\(Q\)</span> se numeÅŸte <em><span
class="math inline">\(M\)</span>-injectiv</em> dacÄƒ pentru orice
monomorfism <span class="math inline">\(u : M&#39; \to M\)</span> ÅŸi
orice morfism <span class="math inline">\(f : M&#39; \to Q\)</span>,
existÄƒ <span class="math inline">\(g : M \to Q\)</span> astfel Ã®ncÃ¢t
<span class="math inline">\(g \circ u = f\)</span>, adicÄƒ diagrama</p>
<p><img src="diagrams/diagram_0.svg" alt="Commutative diagram" style="max-width: 100%; height: auto; display: block; margin: 1em auto;"></p>
<p>este comutativÄƒ.</p>
<p>AceastÄƒ proprietate este echivalentÄƒ cu condiÅ£ia ca aplicaÅ£ia <span
class="math display">\[\mathop{\mathrm{Hom}}(u,Q) :
\mathop{\mathrm{Hom}}(M,Q) \longrightarrow
\mathop{\mathrm{Hom}}(M&#39;,Q)\]</span> sÄƒ fie surjectivÄƒ pentru orice
monomorfism <span class="math inline">\(u : M&#39; \to M\)</span>. Cum
functorul <span
class="math inline">\(\mathop{\mathrm{Hom}}(-,Q)\)</span> este exact la
stÃ¢nga, rezultÄƒ cÄƒ <span class="math inline">\(Q\)</span> este <span
class="math inline">\(M\)</span>-injectiv dacÄƒ ÅŸi numai dacÄƒ <span
class="math inline">\(\mathop{\mathrm{Hom}}(-,Q)\)</span> este exact Ã®n
raport cu orice ÅŸir exact de forma <span class="math display">\[0
\longrightarrow M&#39; \longrightarrow M \longrightarrow M&#39;&#39;
\longrightarrow 0.\]</span></p>
<p><span class="math inline">\(R\)</span>-modulul <span
class="math inline">\(Q\)</span> se numeÅŸte <em>quasi-injectiv</em> (sau
<em>self-injectiv</em>) dacÄƒ este <span
class="math inline">\(Q\)</span>-injectiv. DacÄƒ <span
class="math inline">\(Q\)</span> este <span
class="math inline">\(M\)</span>-injectiv pentru orice <span
class="math inline">\(R\)</span>-modul <span
class="math inline">\(M\)</span>, atunci <span
class="math inline">\(Q\)</span> se numeÅŸte <em>injectiv</em>.</p>
<p>2.1.1 PropoziÅ£ie</p>
<div class="proposition">
<p><strong>PropoziÅ£ie 3.1</strong>. <em>Fie <span
class="math inline">\(Q\)</span> ÅŸi <span
class="math inline">\(M\)</span> douÄƒ <span
class="math inline">\(R\)</span>-module. UrmÄƒtoarele afirmaÅ£ii sunt
echivalente:</em></p>
<ol>
<li><p><em><span class="math inline">\(Q\)</span> este <span
class="math inline">\(M\)</span>-injectiv.</em></p></li>
<li><p><em>Pentru orice submodul <span class="math inline">\(N\)</span>
al lui <span class="math inline">\(M\)</span> ÅŸi orice morfism <span
class="math inline">\(f : N \to Q\)</span>, existÄƒ <span
class="math inline">\(g : M \to Q\)</span> astfel Ã®ncÃ¢t <span
class="math inline">\(g_{\mid N} = f\)</span>.</em></p></li>
<li><p><em>Pentru orice submodul esenÅ£ial <span
class="math inline">\(N\)</span> al lui <span
class="math inline">\(M\)</span> ÅŸi orice morfism <span
class="math inline">\(f : N \to Q\)</span>, existÄƒ <span
class="math inline">\(g : M \to Q\)</span> astfel Ã®ncÃ¢t <span
class="math inline">\(g_{\mid N} = f\)</span>.</em></p></li>
</ol>
</div>
<div class="proof">
<p><em>Proof.</em> ImplicaÅ£iile <span class="math inline">\((1)
\Rightarrow (2)\)</span> ÅŸi <span class="math inline">\((2) \Rightarrow
(3)\)</span> sunt evidente.</p>
<p><span class="math inline">\((2) \Rightarrow (1)\)</span>. Fie <span
class="math inline">\(M&#39;_R\)</span>, <span class="math inline">\(0
\longrightarrow M&#39; \xrightarrow{u} M\)</span> ÅŸi <span
class="math inline">\(f : M&#39; \to Q\)</span>. Atunci <span
class="math inline">\(u(M&#39;) \leq M\)</span>. ConsiderÄƒm <span
class="math inline">\(i : u(M&#39;) \to M\)</span> injecÅ£ia canonicÄƒ ÅŸi
<span class="math inline">\(\bar{u} : M&#39; \to u(M&#39;)\)</span>
izomorfismul indus de <span class="math inline">\(u\)</span>. ExistÄƒ
<span class="math inline">\(g : M \to Q\)</span> astfel Ã®ncÃ¢t <span
class="math inline">\(g \circ i = f \circ \bar{u}^{-1}\)</span>. Atunci
<span class="math display">\[g \circ i \circ \bar{u} = f
\quad\text{ÅŸi deci}\quad
g \circ u = f.\]</span></p>
<p>Diagrama corespunzÄƒtoare este</p>
<p><img src="diagrams/diagram_1.svg" alt="Commutative diagram" style="max-width: 100%; height: auto; display: block; margin: 1em auto;"></p>
<p><span class="math inline">\((3) \Rightarrow (2)\)</span>. Fie <span
class="math inline">\(N\)</span> un submodul al lui <span
class="math inline">\(M\)</span> ÅŸi <span
class="math inline">\(K\)</span> un complement al lui <span
class="math inline">\(N\)</span> Ã®n <span
class="math inline">\(M\)</span>. Atunci <span class="math inline">\((N
\oplus K) \trianglelefteq M\)</span>. Fie <span class="math inline">\(h
: N \oplus K \to Q\)</span>, definit prin <span
class="math inline">\(h(n+k) = f(n)\)</span> pentru orice <span
class="math inline">\(n \in N\)</span>, <span class="math inline">\(k
\in K\)</span>. Cum <span class="math inline">\(N \cap K = 0\)</span>,
aplicaÅ£ia <span class="math inline">\(h\)</span> este bine definitÄƒ.
ExistÄƒ <span class="math inline">\(g : M \to Q\)</span> astfel Ã®ncÃ¢t
<span class="math inline">\(g_{\mid N \oplus K} = h\)</span> ÅŸi deci
<span class="math inline">\(g_{\mid N} = h_{\mid N} = f\)</span>.</p>
<p>Aceasta se poate reprezenta prin diagrama
<img src="diagrams/diagram_2.svg" alt="Commutative diagram" style="max-width: 100%; height: auto; display: block; margin: 1em auto;">Â â—»</p>
</div>
<div class="proposition">
<p><strong>PropoziÅ£ie 3.2</strong>. <em>Fie <span
class="math inline">\((M_\alpha)_{\alpha \in \Lambda}\)</span> o familie
de <span class="math inline">\(R\)</span>-module ÅŸi <span
class="math inline">\(M\)</span> un <span
class="math inline">\(R\)</span>-modul. Atunci <span
class="math inline">\(\displaystyle \prod_{\alpha \in \Lambda}
M_\alpha\)</span> este <span class="math inline">\(M\)</span>-injectiv
dacÄƒ ÅŸi numai dacÄƒ <span class="math inline">\(M_\alpha\)</span> este
<span class="math inline">\(M\)</span>-injectiv pentru orice <span
class="math inline">\(\alpha \in \Lambda\)</span>.</em></p>
</div>
<div class="proof">
<p><em>Proof.</em> Fie <span class="math inline">\(N\)</span> un
submodul al lui <span class="math inline">\(M\)</span>. NotÄƒm <span
class="math inline">\(P = \displaystyle\prod_{\alpha \in \Lambda}
M_\alpha\)</span> ÅŸi <span class="math inline">\(\pi_\alpha : P \to
M_\alpha\)</span> proiecÅ£iile canonice, pentru orice <span
class="math inline">\(\alpha \in \Lambda\)</span>.</p>
<p><span class="math inline">\(&quot;\Leftarrow&quot;\)</span>
ConsiderÃ¢nd un morfism <span class="math inline">\(f : N \to P\)</span>,
avem cÄƒ morfismele <span class="math inline">\(\pi_\alpha \circ f : N
\to M_\alpha\)</span> pot fi extinse la <span
class="math inline">\(g_\alpha : M \to M_\alpha\)</span>. ExistÄƒ <span
class="math inline">\(g : M \to P\)</span> astfel Ã®ncÃ¢t <span
class="math inline">\(g_{\mid N} = f\)</span>.</p>
<p><img src="diagrams/diagram_3.svg" alt="Commutative diagram" style="max-width: 100%; height: auto; display: block; margin: 1em auto;"></p>
<p><span class="math inline">\(&quot;\Rightarrow&quot;\)</span> Fie
<span class="math inline">\(\forall \alpha \in \Lambda\)</span> ÅŸi <span
class="math inline">\(f : N \to M_\alpha\)</span>. ConsiderÃ¢nd
incluziunea canonicÄƒ <span class="math inline">\(\varepsilon_\alpha :
M_\alpha \to P\)</span>, cum <span class="math inline">\(P\)</span> este
<span class="math inline">\(M\)</span>-injectiv, existÄƒ <span
class="math inline">\(g : M \to P\)</span> care Ã®l extinde pe <span
class="math inline">\(\varepsilon_\alpha \circ f : N \to P\)</span>.
Atunci <span class="math inline">\(\varepsilon_\alpha : M_\alpha \to
P\)</span> Ã®l extinde pe <span class="math inline">\(f\)</span> ÅŸi deci
<span class="math inline">\(M_\alpha\)</span> este <span
class="math inline">\(M\)</span>-injectiv.</p>
<p><img src="diagrams/diagram_4.svg" alt="Commutative diagram" style="max-width: 100%; height: auto; display: block; margin: 1em auto;">Â â—»</p>
</div>
<div class="corollary">
<p><strong>Corolar 3.3</strong>. </p>
<ol>
<li><p><em>Fie <span class="math inline">\((Q_\alpha)_{\alpha \in
\Lambda}\)</span> o familie de <span
class="math inline">\(R\)</span>-module. Atunci <span
class="math inline">\(\prod_{\alpha \in \Lambda} Q_\alpha\)</span> este
injectiv dacÄƒ ÅŸi numai dacÄƒ <span
class="math inline">\(Q_\alpha\)</span> este injectiv pentru orice <span
class="math inline">\(\alpha\in\Lambda\)</span>.</em></p></li>
<li><p><em><span class="math inline">\(Q_1 \oplus Q_2\)</span> este
<span class="math inline">\(R\)</span>-modul injectiv dacÄƒ ÅŸi numai dacÄƒ
<span class="math inline">\(Q_i\)</span> este injectiv pentru <span
class="math inline">\(i=1,2\)</span>. Ãn particular, un sumand direct al
unui modul injectiv este injectiv.</em></p></li>
</ol>
</div>
<div class="proposition">
<p><strong>PropoziÅ£ie 3.4</strong>. <em>Fie <span
class="math inline">\(Q\)</span> un <span
class="math inline">\(R\)</span>-modul.</em></p>
<ol>
<li><p><em>DacÄƒ <span class="math inline">\(0 \to M&#39; \xrightarrow{f}
M \xrightarrow{g} M&#39;&#39; \to 0\)</span> este un ÅŸir exact de <span
class="math inline">\(R\)</span>-module ÅŸi <span
class="math inline">\(Q\)</span> este <span
class="math inline">\(M\)</span>-injectiv, atunci <span
class="math inline">\(Q\)</span> este <span
class="math inline">\(M&#39;\)</span>-injectiv ÅŸi <span
class="math inline">\(M&#39;&#39;\)</span>-injectiv.</em></p></li>
<li><p><em>DacÄƒ <span class="math inline">\((M_\alpha)_{\alpha \in
\Lambda}\)</span> este o familie de submodule ale lui <span
class="math inline">\(M\)</span> astfel Ã®ncÃ¢t <span
class="math inline">\(M = \sum_{\alpha\in\Lambda} M_\alpha\)</span> ÅŸi
<span class="math inline">\(Q\)</span> este <span
class="math inline">\(M_\alpha\)</span>-injectiv pentru orice <span
class="math inline">\(\alpha\)</span>, atunci <span
class="math inline">\(Q\)</span> este <span
class="math inline">\(M\)</span>-injectiv.</em></p></li>
<li><p><em>Fie <span
class="math inline">\((N_\alpha)_{\alpha\in\Lambda}\)</span> o familie
de <span class="math inline">\(R\)</span>-module. Atunci <span
class="math inline">\(Q\)</span> este <span
class="math inline">\(\bigoplus_{\alpha\in\Lambda}
N_\alpha\)</span>-injectiv dacÄƒ ÅŸi numai dacÄƒ <span
class="math inline">\(Q\)</span> este <span
class="math inline">\(N_\alpha\)</span>-injectiv pentru orice <span
class="math inline">\(\alpha\in\Lambda\)</span>.</em></p></li>
</ol>
</div>
<div class="proof">
<p><em>Proof.</em> Pentru a arÄƒta cÄƒ <span
class="math inline">\(Q\)</span> este <span
class="math inline">\(M&#39;\)</span>-injectiv, considerÄƒm <span
class="math inline">\(N\)</span> un submodul al lui <span
class="math inline">\(M&#39;\)</span> È™i <span
class="math inline">\(\varphi : N \rightarrow Q\)</span> un morfism de
<span class="math inline">\(R\)</span>-module. Cum <span
class="math inline">\(Q\)</span> este <span
class="math inline">\(M\)</span>-injectiv, existÄƒ <span
class="math inline">\(\phi : M \to Q\)</span> astfel Ã®ncÃ¢t <span
class="math inline">\(g \circ f\!\mid_{N} = \varphi\)</span> È™i deci
<span class="math inline">\(\psi \circ f : M&#39; \to Q\)</span> este un
morfism care Ã®l extinde pe <span class="math inline">\(\varphi\)</span>.
<img src="diagrams/diagram_5.svg" alt="Commutative diagram" style="max-width: 100%; height: auto; display: block; margin: 1em auto;"></p>
<p>Fie <span class="math inline">\(h : L \to M&#39;&#39;\)</span> un
monomorfism. Putem presupune, fÄƒrÄƒ a restrÃ¢nge generalitatea, cÄƒ <span
class="math inline">\(M&#39; \le M\)</span> È™i <span
class="math inline">\(M&#39;&#39; = M / M&#39;\)</span>. Cum <span
class="math inline">\(L \cong h(L) \le M&#39;&#39;\)</span>, existÄƒ
<span class="math inline">\(P \le M\)</span>, <span
class="math inline">\(M&#39; \subseteq P\)</span> astfel Ã®ncÃ¢t <span
class="math inline">\(h(L) = P / M&#39;\)</span> È™i deci <span
class="math inline">\(L \cong P/M&#39;\)</span>. ObÈ›inem diagrama
comutativÄƒ:</p>
<p><img src="diagrams/diagram_6.svg" alt="Commutative diagram" style="max-width: 100%; height: auto; display: block; margin: 1em auto;"></p>
<p>Cum <span class="math inline">\(Q\)</span> este <span
class="math inline">\(M\)</span>-injectiv, aplicÃ¢nd functorul <span
class="math inline">\(\mathop{\mathrm{Hom}}(-,Q)\)</span> obÈ›inem
diagrama comutativÄƒ:</p>
<p><img src="diagrams/diagram_7.svg" alt="Commutative diagram" style="max-width: 100%; height: auto; display: block; margin: 1em auto;"></p>
<p>ObÈ›inem cÄƒ <span class="math inline">\(h^{*} =
\mathop{\mathrm{Hom}}(h,Q)\)</span> este epimorfism, ceea ce aratÄƒ cÄƒ
<span class="math inline">\(Q\)</span> este <span
class="math inline">\(M&#39;&#39;\)</span>-injectiv.</p>
<p>2) Fie <span class="math inline">\(N\)</span> un submodul al lui
<span class="math inline">\(M\)</span> ÅŸi <span class="math inline">\(f
: N \to Q\)</span> un morfism de <span
class="math inline">\(R\)</span>-module. ConsiderÄƒm mulÅ£imea <span
class="math display">\[\mathfrak{S} = \{(L,h) \mid N \le L \le M,\; h :
L \to Q,\; h\!\mid_{N} = f\}.\]</span> Cum <span
class="math inline">\((N,f) \in \mathfrak{S}\)</span>, avem <span
class="math inline">\(\mathfrak{S} \ne \varnothing\)</span>. Definim pe
<span class="math inline">\(\mathfrak{S}\)</span> relaÅ£ia de ordine
<span class="math inline">\((L_1,h_1) \preccurlyeq (L_2,h_2)\)</span>
dacÄƒ ÅŸi numai dacÄƒ <span class="math inline">\(L_1 \le L_2\)</span> ÅŸi
<span class="math inline">\(h_2\!\mid_{L_1} = h_1\)</span>. Se observÄƒ
cÄƒ <span class="math inline">\(\mathfrak{S}\)</span> este inductivÄƒ ÅŸi,
din lema lui Zorn, rezultÄƒ cÄƒ existÄƒ <span
class="math inline">\((L_0,g_0)\)</span> element maximal al lui <span
class="math inline">\(\mathfrak{S}\)</span>. Pentru a arÄƒta cÄƒ <span
class="math inline">\(L_0 = M\)</span> este suficient sÄƒ arÄƒtÄƒm cÄƒ <span
class="math inline">\(M_\alpha \le L_0\)</span> pentru orice <span
class="math inline">\(\alpha \in \Lambda\)</span>.</p>
<p>ConsiderÃ¢nd diagrama</p>
<p><img src="diagrams/diagram_8.svg" alt="Commutative diagram" style="max-width: 100%; height: auto; display: block; margin: 1em auto;"></p>
<p>rezultÄƒ cÄƒ existÄƒ <span class="math inline">\(h_\alpha : M_\alpha \to
Q\)</span> astfel Ã®ncÃ¢t <span class="math inline">\(h_\alpha \circ
i_\alpha = g_0 \circ i_\alpha\)</span>. Definim <span
class="math inline">\(h^{*} : L_0 + M_\alpha \to Q\)</span>, <span
class="math inline">\(h^{*}(l + m_\alpha) = g_0(l) +
h_\alpha(m_\alpha)\)</span>, pentru orice <span class="math inline">\(l
\in L_0\)</span>, <span class="math inline">\(m_\alpha \in
M_\alpha\)</span>. DacÄƒ <span class="math inline">\(l + m_\alpha =
0\)</span>, atunci <span class="math inline">\(l = -m_\alpha \in L_0
\cap M_\alpha\)</span> ÅŸi deci <span class="math inline">\(h^{*}(l +
m_\alpha) = g_0(l) + h_\alpha(l)\)</span>, ceea ce aratÄƒ cÄƒ <span
class="math inline">\(h^{*}\)</span> este bine definitÄƒ. Atunci <span
class="math inline">\((L_0 + M_\alpha, h^{*}) \in \mathfrak{S}\)</span>
ÅŸi, cum <span class="math inline">\((L_0,g_0) \preccurlyeq (L_0 +
M_\alpha, h^{*})\)</span>, din maximalitatea lui <span
class="math inline">\((L_0,g_0)\)</span> rezultÄƒ cÄƒ <span
class="math inline">\(L_0 = L_0 + M_\alpha\)</span>, adicÄƒ <span
class="math inline">\(M_\alpha \le L_0\)</span> pentru orice <span
class="math inline">\(\alpha \in \Lambda\)</span>.</p>
<p>3) â€<span class="math inline">\(\Rightarrow\)</span>â€ Cum <span
class="math inline">\(N_\alpha \le N\)</span> ÅŸi <span
class="math inline">\(Q\)</span> este <span
class="math inline">\(N\)</span>-injectiv, avem cÄƒ <span
class="math inline">\(Q\)</span> este <span
class="math inline">\(N_\alpha\)</span>-injectiv pentru orice <span
class="math inline">\(\alpha \in \Lambda\)</span>.</p>
<p>â€<span class="math inline">\(\Leftarrow\)</span>â€ Fie <span
class="math inline">\(N&#39;_\alpha = i_\alpha(N_\alpha)\)</span>. Cum
<span class="math inline">\(Q\)</span> este <span
class="math inline">\(N_\alpha\)</span>-injectiv ÅŸi <span
class="math inline">\(N&#39;_\alpha \cong N_\alpha\)</span>, rezultÄƒ cÄƒ
<span class="math inline">\(Q\)</span> este <span
class="math inline">\(N&#39;_\alpha\)</span>-injectiv. Apoi aplicÄƒm
(2).Â â—»</p>
</div>
<div class="corollary">
<p><strong>Corolar 3.5</strong>. </p>
<ol>
<li><p><em><span class="math inline">\(Q_1 \oplus Q_2\)</span> este
<span class="math inline">\(R\)</span>-modul quasi-injectiv dacÄƒ ÅŸi
numai dacÄƒ <span class="math inline">\(Q_i\)</span> este <span
class="math inline">\(Q_j\)</span>-injectiv pentru orice <span
class="math inline">\(i,j = 1,2\)</span>. Ãn particular, un sumand
direct al unui modul quasi-injectiv este quasi-injectiv.</em></p></li>
<li><p><em><span class="math inline">\(Q^{n}\)</span> este <span
class="math inline">\(R\)</span>-modul quasi-injectiv dacÄƒ ÅŸi numai dacÄƒ
<span class="math inline">\(Q\)</span> este
quasi-injectiv.</em></p></li>
</ol>
</div>
<div class="corollary">
<p><strong>Corolar 3.6</strong>. <em>Fie <span
class="math inline">\(Q\)</span> ÅŸi <span
class="math inline">\(M\)</span> douÄƒ <span
class="math inline">\(R\)</span>-module. Atunci <span
class="math inline">\(Q\)</span> este <span
class="math inline">\(M\)</span>-injectiv dacÄƒ ÅŸi numai dacÄƒ <span
class="math inline">\(Q\)</span> este <span
class="math inline">\(mR\)</span>-injectiv pentru orice <span
class="math inline">\(m \in M\)</span>.</em></p>
</div>
<div class="proof">
<p><em>Proof.</em> â€<span class="math inline">\(\Rightarrow\)</span>â€
este evident.</p>
<p>â€<span class="math inline">\(\Leftarrow\)</span>â€ Cum <span
class="math inline">\(M = \sum_{m \in M} mR\)</span>, din 2.1.4(2)
rezultÄƒ cÄƒ <span class="math inline">\(Q\)</span> este <span
class="math inline">\(M\)</span>-injectiv.Â â—»</p>
</div>
<div id="thm:Baer-ro" class="theorem">
<p><strong>TeoremÄƒ 3.7</strong> (Criteriul lui Baer). <em>Pentru un
<span class="math inline">\(R\)</span>-modul <span
class="math inline">\(Q\)</span> urmÄƒtoarele afirmaÅ£ii sunt
echivalente:</em></p>
<ol>
<li><p><em><span class="math inline">\(Q\)</span> este
injectiv.</em></p></li>
<li><p><em><span class="math inline">\(Q\)</span> este <span
class="math inline">\(R\)</span>-injectiv.</em></p></li>
<li><p><em>Pentru orice ideal drept <span
class="math inline">\(I\)</span> al lui <span
class="math inline">\(R\)</span> ÅŸi orice morfism <span
class="math inline">\(f : I \to Q\)</span> existÄƒ <span
class="math inline">\(x \in Q\)</span> astfel Ã®ncÃ¢t <span
class="math inline">\(f(a) = xa\)</span> pentru orice <span
class="math inline">\(a \in I\)</span>.</em></p></li>
</ol>
</div>
<div class="proof">
<p><em>Proof.</em> ImplicaÅ£ia <span class="math inline">\((1)
\Rightarrow (2)\)</span> este evidentÄƒ.</p>
<p><span class="math inline">\((2) \Rightarrow (1)\)</span>. Fie <span
class="math inline">\(M\)</span> un <span
class="math inline">\(R\)</span>-modul ÅŸi <span class="math inline">\(x
\in M\)</span>. Cum <span class="math inline">\(\varphi_x : R \to
xR\)</span>, <span class="math inline">\(\varphi_x(a) = xa\)</span>
pentru orice <span class="math inline">\(a \in R\)</span>, este morfism
surjectiv de <span class="math inline">\(R\)</span>-module, rezultÄƒ cÄƒ
<span class="math inline">\(R / \mathop{\mathrm{Ker}}\varphi_x \cong
xR\)</span>. Cum <span class="math inline">\(Q\)</span> este <span
class="math inline">\(R\)</span>-injectiv, din 2.1.4(1) rezultÄƒ cÄƒ <span
class="math inline">\(Q\)</span> este <span class="math inline">\(R /
\mathop{\mathrm{Ker}}\varphi_x\)</span>-injectiv ÅŸi deci <span
class="math inline">\(Q\)</span> este <span
class="math inline">\(xR\)</span>-injectiv pentru orice <span
class="math inline">\(x \in M\)</span>. Atunci, din 2.1.6 obÅ£inem cÄƒ
<span class="math inline">\(Q\)</span> este <span
class="math inline">\(M\)</span>-injectiv.</p>
<p><span class="math inline">\((2) \Rightarrow (3)\)</span>. Fie <span
class="math inline">\(I\)</span> un ideal drept al lui <span
class="math inline">\(R\)</span> ÅŸi <span class="math inline">\(f : I
\to Q\)</span>. ExistÄƒ <span class="math inline">\(g : R \to Q\)</span>
astfel Ã®ncÃ¢t <span class="math inline">\(g\!\mid_{I} = f\)</span>. Fie
<span class="math inline">\(x = g(1) \in Q\)</span>. Atunci <span
class="math inline">\(f(a) = g(a) = ag(1) = xa\)</span> pentru orice
<span class="math inline">\(a \in I\)</span>.</p>
<p><span class="math inline">\((3) \Rightarrow (2)\)</span>. DacÄƒ pentru
un morfism <span class="math inline">\(f : I \to Q\)</span> existÄƒ <span
class="math inline">\(x \in Q\)</span> cu <span
class="math inline">\(f(a) = xa\)</span> pentru orice <span
class="math inline">\(a \in I\)</span>, atunci, definind <span
class="math inline">\(g : R \to Q\)</span> prin <span
class="math inline">\(g(r) = xr\)</span> pentru orice <span
class="math inline">\(r \in R\)</span>, rezultÄƒ cÄƒ <span
class="math inline">\(g\!\mid_{I} = f\)</span>.Â â—»</p>
</div>
<div class="definition">
<p><strong>DefiniÅ£ie 3.8</strong>. </p>
<ol>
<li><p>Un <span class="math inline">\(R\)</span>-modul <span
class="math inline">\(Q\)</span> se numeÅŸte <em>divizibil</em> dacÄƒ
pentru orice <span class="math inline">\(y \in Q\)</span> ÅŸi orice <span
class="math inline">\(a \in R\)</span> nendivizor al lui zero, existÄƒ
<span class="math inline">\(x \in Q\)</span> astfel Ã®ncÃ¢t <span
class="math inline">\(ax = y\)</span>. Se verificÄƒ uÅŸor cÄƒ orice modul
factor al unui modul divizibil este divizibil.</p></li>
<li><p>Un domeniu de integritate comutativ se numeÅŸte <em>PID-inel</em>
dacÄƒ orice ideal al sÄƒu este principal.</p></li>
</ol>
</div>
<div class="proposition">
<p><strong>PropoziÅ£ie 3.9</strong>. </p>
<ol>
<li><p><em>Orice modul injectiv este divizibil.</em></p></li>
<li><p><em>Fie <span class="math inline">\(R\)</span> un
PID-inel.</em></p>
<ol>
<li><p><em>DacÄƒ <span class="math inline">\(Q\)</span> este un <span
class="math inline">\(R\)</span>-modul, atunci <span
class="math inline">\(Q\)</span> este injectiv dacÄƒ ÅŸi numai dacÄƒ este
divizibil.</em></p></li>
<li><p><em>DacÄƒ <span class="math inline">\(I\)</span> este un ideal
nenul al lui <span class="math inline">\(R\)</span>, atunci <span
class="math inline">\(R/I\)</span> este <span
class="math inline">\(R\)</span>-modul quasi-injectiv. Ãn particular,
<span class="math inline">\(\mathbb{Z}_n\)</span> este <span
class="math inline">\(\mathbb{Z}\)</span>-modul quasi-injectiv, <span
class="math inline">\(\forall n \ge 1\)</span>.</em></p></li>
</ol></li>
</ol>
</div>
<div class="proof">
<p><em>Proof.</em> 1) Fie <span class="math inline">\(Q\)</span> un
<span class="math inline">\(R\)</span>-modul divizibil, <span
class="math inline">\(y \in Q\)</span> ÅŸi <span class="math inline">\(a
\in R\)</span> nendivizor al lui zero. Definim <span
class="math inline">\(f : aR \to Q\)</span> prin <span
class="math inline">\(f(ax) = yx\)</span> pentru orice <span
class="math inline">\(x \in R\)</span>. Cum <span
class="math inline">\(a\)</span> este nendivizor al lui zero, <span
class="math inline">\(f\)</span> este bine definitÄƒ. Folosind criteriul
lui Baer rezultÄƒ cÄƒ existÄƒ <span class="math inline">\(x \in Q\)</span>
astfel Ã®ncÃ¢t <span class="math inline">\(f(\lambda) = x\lambda\)</span>,
pentru orice <span class="math inline">\(\lambda \in I\)</span>. Deci
<span class="math inline">\(y = f(a) = f(a \cdot 1) = xa\)</span>.</p>
<p>2) <span class="math inline">\((i)\)</span> ImplicaÅ£ia â€<span
class="math inline">\(\Rightarrow\)</span>â€ este evidentÄƒ din (1).</p>
<p>â€<span class="math inline">\(\Leftarrow\)</span>â€ Fie <span
class="math inline">\(Q\)</span> un <span
class="math inline">\(R\)</span>-modul divizibil ÅŸi <span
class="math inline">\(I\)</span> un ideal drept al lui <span
class="math inline">\(R\)</span>. Atunci existÄƒ <span
class="math inline">\(a \in R\)</span> astfel Ã®ncÃ¢t <span
class="math inline">\(I = aR\)</span>. ConsiderÄƒm <span
class="math inline">\(f : I \to Q\)</span> un morfism de <span
class="math inline">\(R\)</span>-module. ExistÄƒ <span
class="math inline">\(x \in Q\)</span> astfel Ã®ncÃ¢t <span
class="math inline">\(f(a) = xa\)</span>. Atunci <span
class="math inline">\(f(ar) = xar\)</span> pentru orice <span
class="math inline">\(r \in R\)</span> ÅŸi deci, conform criteriului lui
Baer, <span class="math inline">\(Q\)</span> este injectiv.</p>
<p>(ii) Fie <span class="math inline">\(I = aR\)</span> ÅŸi <span
class="math inline">\(J = bR\)</span> ideale nenule ale lui <span
class="math inline">\(R\)</span> astfel Ã®ncÃ¢t <span
class="math inline">\(I \subseteq J\)</span> ÅŸi <span
class="math inline">\(f : J/I \to R/I\)</span> un morfism de <span
class="math inline">\(R\)</span>-module. ExistÄƒ <span
class="math inline">\(c \in R\)</span> astfel Ã®ncÃ¢t <span
class="math inline">\(a = bc\)</span>. DacÄƒ <span
class="math inline">\(f(\bar{b}) = \hat{x} \in R/I\)</span>, atunci
<span class="math inline">\(x \in I\)</span> ÅŸi deci existÄƒ <span
class="math inline">\(a_1 \in R\)</span> astfel Ã®ncÃ¢t <span
class="math inline">\(x = aa_1\)</span>. RezultÄƒ cÄƒ <span
class="math inline">\(x = ba_1\)</span>. Definim <span
class="math inline">\(g : R/I \to R/I\)</span>, <span
class="math inline">\(g(\bar{r}) = \widehat{ar_1}\)</span> pentru orice
<span class="math inline">\(r \in R\)</span>. Atunci <span
class="math inline">\(g\)</span> este morfism de <span
class="math inline">\(R\)</span>-module ÅŸi <span
class="math inline">\(g(\bar{b}) = \hat{x}\)</span>, deci <span
class="math inline">\(g\!\mid_{J/I} = f\)</span>, ceea ce aratÄƒ cÄƒ <span
class="math inline">\(R/I\)</span> este quasi-injectiv.Â â—»</p>
</div>
<div class="corollary">
<p><strong>Corolar 3.10</strong>. <em>Un grup abelian <span
class="math inline">\(G\)</span> este <span
class="math inline">\(\mathbb{Z}\)</span>-modul injectiv dacÄƒ ÅŸi numai
dacÄƒ <span class="math inline">\(G\)</span> este divizibil.</em></p>
</div>
<div class="corollary">
<p><strong>Corolar 3.11</strong>. </p>
<ol>
<li><p><em><span class="math inline">\(\mathbb{Q}\)</span> ÅŸi <span
class="math inline">\(\mathbb{Z}_{p^\infty}\)</span> sunt <span
class="math inline">\(\mathbb{Z}\)</span>-module
injective.</em></p></li>
<li><p><em>Orice sumÄƒ directÄƒ de <span
class="math inline">\(\mathbb{Z}\)</span>-module injective este <span
class="math inline">\(\mathbb{Z}\)</span>-modul injectiv.</em></p></li>
<li><p><em>Orice grup factor al unui <span
class="math inline">\(\mathbb{Z}\)</span>-modul injectiv este
injectiv.</em></p></li>
</ol>
</div>
<div class="lemma">
<p><strong>LemÄƒ 3.12</strong>. <em>Fie inelele <span
class="math inline">\(A, S, T\)</span> ÅŸi bimodulele <span
class="math inline">\({}_S M_A\)</span>, <span
class="math inline">\({}_A N_T\)</span>. Atunci <span
class="math inline">\(\mathop{\mathrm{Hom}}_A(M,N)\)</span> are o
structurÄƒ de bimodul <span class="math inline">\(S\)</span>-stÃ¢ng ÅŸi
<span class="math inline">\(T\)</span>-drept prin operaÅ£iile: <span
class="math display">\[(s \cdot f)(x) = f(xs), \qquad (f \cdot t)(x) =
f(x)t,\]</span> unde <span class="math inline">\(s \in S\)</span>, <span
class="math inline">\(t \in T\)</span>, <span class="math inline">\(x
\in M\)</span>, <span class="math inline">\(f \in
\mathop{\mathrm{Hom}}_A(M,N)\)</span>.</em></p>
</div>
<div class="proof">
<p><em>Proof.</em> Fie <span class="math inline">\(a,b \in A\)</span> ÅŸi
<span class="math inline">\(x,y \in M\)</span>. Atunci: <span
class="math display">\[(s \cdot f)(ax + by)
= f((ax+by)s)
= f(a(xs)) + f(b(ys)) = a f(xs) + b f(ys)
= a (s \cdot f)(x) + b (s \cdot f)(y),\]</span> ÅŸi deci <span
class="math inline">\(s \cdot f \in
\mathop{\mathrm{Hom}}_A(M,N)\)</span>. Analog <span
class="math inline">\(f \cdot t \in
\mathop{\mathrm{Hom}}_A(M,N)\)</span>.</p>
<p>Pentru <span class="math inline">\(s,s&#39; \in S\)</span> ÅŸi <span
class="math inline">\(f,g \in \mathop{\mathrm{Hom}}_A(M,N)\)</span>:
<span class="math display">\[(s \cdot (f+g))(x) = (f+g)(xs) = f(xs) +
g(xs) = (s\cdot f)(x) + (s \cdot g)(x).
\tag{1}\]</span></p>
<p><span class="math display">\[((s+s&#39;) \cdot f)(x) = f(x(s+s&#39;))
= f(xs + xs&#39;) = f(xs) + f(xs&#39;) = (s\cdot f)(x) + (s&#39; \cdot
f)(x).
\tag{2}\]</span></p>
<p><span class="math display">\[((ss&#39;) \cdot f)(x) = f(x(ss&#39;)) =
f((xs)s&#39;) = (s&#39; \cdot f)(xs) = (s \cdot (s&#39; \cdot f))(x).
\tag{3}\]</span></p>
<p><span class="math display">\[(1_S \cdot f)(x) = f(x1_S) = f(x).
\tag{4}\]</span></p>
<p>Din (1)â€“(4) avem cÄƒ <span
class="math inline">\(\mathop{\mathrm{Hom}}_A(M,N)\)</span> este <span
class="math inline">\(S\)</span>-modul stÃ¢ng. La fel se aratÄƒ cÄƒ este ÅŸi
<span class="math inline">\(T\)</span>-modul drept. Prin urmare <span
class="math inline">\(\mathop{\mathrm{Hom}}_A(M,N)\)</span> este un
bimodul <span class="math inline">\(S\)</span>-stÃ¢ng ÅŸi <span
class="math inline">\(T\)</span>-drept.Â â—»</p>
</div>
<div class="proposition">
<p><strong>PropoziÅ£ie 3.13</strong> (Eckmannâ€“Schopf). <em>Fie <span
class="math inline">\(Q\)</span> un grup abelian divizibil. Atunci <span
class="math inline">\(R\)</span>-modulul stÃ¢ng <span
class="math inline">\(\mathop{\mathrm{Hom}}_\mathbb{Z}(R,Q)\)</span>
este injectiv.</em></p>
</div>
<div class="proof">
<p><em>Proof.</em> Conform lemei precedente, <span
class="math inline">\(\mathop{\mathrm{Hom}}_{\mathbb{Z}}(R,Q)\)</span>
are o structurÄƒ de <span class="math inline">\(R\)</span>-modul stÃ¢ng
datÄƒ de operaÅ£ia <span class="math display">\[(r \cdot f)(a) = f(ar),
\qquad \forall a,r \in R,\ f \in
\mathop{\mathrm{Hom}}_{\mathbb{Z}}(R,Q).\]</span> Fie <span
class="math inline">\(I\)</span> un ideal stÃ¢ng al lui <span
class="math inline">\(R\)</span> ÅŸi <span class="math inline">\(h : I
\to \mathop{\mathrm{Hom}}_{\mathbb{Z}}(R,Q)\)</span> un morfism de <span
class="math inline">\(R\)</span>-module stÃ¢ngi. Atunci aplicaÅ£ia <span
class="math display">\[\gamma : \mathbb{Z}I \longrightarrow \mathbb{Z}Q,
\qquad
\gamma(a) = h(a)(1)\]</span> defineÅŸte un morfism de <span
class="math inline">\(\mathbb{Z}\)</span>â€“module. Cum <span
class="math inline">\(Q\)</span> este <span
class="math inline">\(\mathbb{Z}\)</span>â€“injectiv, existÄƒ <span
class="math inline">\(\widetilde{\gamma} : \mathbb{Z}R \to
\mathbb{Z}Q\)</span> astfel Ã®ncÃ¢t <span
class="math inline">\(\widetilde{\gamma}_{\mid I} = \gamma\)</span>.
Pentru <span class="math inline">\(a \in I\)</span> ÅŸi <span
class="math inline">\(r \in R\)</span> avem <span
class="math display">\[(a \cdot \widetilde{\gamma})(r)
  = \widetilde{\gamma}(ra)
  = h(ra)(1)
  = (r \cdot h(a))(1)
  = h(a)(r),\]</span> deci <span class="math inline">\(h(a) = a \cdot
\widetilde{\gamma}\)</span> pentru orice <span class="math inline">\(a
\in I\)</span>. Conform criteriului lui Baer, <span
class="math inline">\(\mathop{\mathrm{Hom}}_{\mathbb{Z}}(R,Q)\)</span>
este <span class="math inline">\(R\)</span>â€“modul stÃ¢ng injectiv.Â â—»</p>
</div>
<div class="proposition">
<p><strong>PropoziÅ£ie 3.14</strong>. <em>Orice <span
class="math inline">\(R\)</span>-modul stÃ¢ng <span
class="math inline">\(M\)</span> poate fi scufundat Ã®ntr-un <span
class="math inline">\(R\)</span>-modul stÃ¢ng injectiv.</em></p>
</div>
<div class="proof">
<p><em>Proof.</em> ExistÄƒ un <span
class="math inline">\(\mathbb{Z}\)</span>-modul liber de forma <span
class="math inline">\(\mathbb{Z}^{(A)}\)</span> ÅŸi un <span
class="math inline">\(\mathbb{Z}\)</span>-morfism surjectiv <span
class="math inline">\(f : \mathbb{Z}^{(A)} \to M\)</span>. Atunci <span
class="math display">\[\mathbb{Z}M \cong \mathbb{Z}^{(A)} / \ker f
  \subseteq \mathbb{Q}^{(A)} / \ker f,\]</span> ÅŸi deci existÄƒ un grup
abelian divizibil <span class="math inline">\(G\)</span> astfel Ã®ncÃ¢t
<span class="math inline">\(\mathbb{Z}M \subseteq \mathbb{Z}G\)</span>.
AplicÃ¢nd functorul <span
class="math inline">\(\mathop{\mathrm{Hom}}_{\mathbb{Z}}(R,-)\)</span>
obÅ£inem un monomorfism <span class="math display">\[{}_R M \cong
\mathop{\mathrm{Hom}}_{\mathbb{Z}}(R,M)
   \hookrightarrow \mathop{\mathrm{Hom}}_{\mathbb{Z}}(R,G).\]</span> Cum
<span class="math inline">\(G\)</span> este divizibil, din
PropoziÅ£iaÂ 2.1.13 rezultÄƒ cÄƒ <span
class="math inline">\(\mathop{\mathrm{Hom}}_{\mathbb{Z}}(R,G)\)</span>
este <span class="math inline">\(R\)</span>-modul stÃ¢ng injectiv. Prin
urmare <span class="math inline">\(M\)</span> se scufundÄƒ Ã®ntr-un <span
class="math inline">\(R\)</span>-modul stÃ¢ng injectiv.Â â—»</p>
</div>
<div class="proposition">
<p><strong>PropoziÅ£ie 3.15</strong>. <em>Fie <span
class="math inline">\(Q\)</span> un <span
class="math inline">\(R\)</span>-modul. Atunci <span
class="math inline">\(Q\)</span> este injectiv dacÄƒ ÅŸi numai dacÄƒ orice
ÅŸir exact de forma <span class="math display">\[0 \longrightarrow Q
\xrightarrow{f} M \xrightarrow{g} M&#39; \longrightarrow 0\]</span> este
scindat.</em></p>
</div>
<div class="proof">
<p><em>Proof.</em> â€<span class="math inline">\(\Rightarrow\)</span>â€
Presupunem cÄƒ <span class="math inline">\(Q\)</span> este injectiv. Din
exactitatea ÅŸirului avem cÄƒ <span class="math inline">\(f\)</span> este
monomorfism. Prin injectivitatea lui <span
class="math inline">\(Q\)</span> existÄƒ <span class="math inline">\(h :
M \to Q\)</span> astfel Ã®ncÃ¢t <span class="math inline">\(h f =
\mathrm{id}_Q\)</span>, ceea ce aratÄƒ cÄƒ ÅŸirul este scindat.</p>
<p>â€<span class="math inline">\(\Leftarrow\)</span>â€ Folosind
PropoziÅ£iaÂ 2.1.14, existÄƒ un <span
class="math inline">\(R\)</span>-modul injectiv <span
class="math inline">\(Q&#39;\)</span> ÅŸi un monomorfism <span
class="math inline">\(i : Q \to Q&#39;\)</span>. Avem un ÅŸir exact <span
class="math display">\[0 \longrightarrow Q \xrightarrow{i} Q&#39;
\longrightarrow Q&#39;/i(Q) \longrightarrow 0.\]</span> Prin ipotezÄƒ
acest ÅŸir este scindat, deci <span class="math inline">\(Q\)</span> este
sumand direct Ã®n <span class="math inline">\(Q&#39;\)</span>. Un sumand
direct al unui modul injectiv este injectiv, aÅŸadar <span
class="math inline">\(Q\)</span> este injectiv.Â â—»</p>
</div>
<h2 id="anvelope-injective">Anvelope injective</h2>
<div class="definition">
<p><strong>DefiniÅ£ie 3.16</strong>. Fie <span
class="math inline">\(M\)</span> un <span
class="math inline">\(R\)</span>-modul. O pereche <span
class="math inline">\((E,i)\)</span> se numeÅŸte <em>anvelopÄƒ
injectivÄƒ</em> a lui <span class="math inline">\(M\)</span> dacÄƒ <span
class="math inline">\(E\)</span> este modul injectiv ÅŸi <span
class="math inline">\(i : M \to E\)</span> este un monomorfism
esenÅ£ial.</p>
</div>
<div class="proposition">
<p><strong>PropoziÅ£ie 3.17</strong>. <em>Fie <span
class="math inline">\(Q\)</span> un <span
class="math inline">\(R\)</span>-modul injectiv. Atunci orice submodul
complement al lui <span class="math inline">\(Q\)</span> este sumand
direct Ã®n <span class="math inline">\(Q\)</span>.</em></p>
</div>
<div class="proof">
<p><em>Proof.</em> Fie <span class="math inline">\(K\)</span> un
submodul al lui <span class="math inline">\(Q\)</span> ÅŸi <span
class="math inline">\(N\)</span> un complement al lui <span
class="math inline">\(K\)</span> Ã®n <span
class="math inline">\(Q\)</span>, adicÄƒ <span class="math inline">\(K
\cap N = 0\)</span> ÅŸi <span class="math inline">\(K+N\)</span> este
submodul esenÅ£ial Ã®n <span class="math inline">\(Q\)</span>. Atunci
<span class="math inline">\((K+N)/N \cong Q/N\)</span>. Definim <span
class="math inline">\(g : (K+N)/N \to Q\)</span> prin <span
class="math display">\[g((x+y)+N) = x, \qquad x \in K,\ y \in
N.\]</span> Cum <span class="math inline">\(K \cap N = 0\)</span>,
aplicaÅ£ia <span class="math inline">\(g\)</span> este bine definitÄƒ ÅŸi
este monomorfism. Injectivitatea lui <span
class="math inline">\(Q\)</span> asigurÄƒ existenÅ£a unui morfism <span
class="math inline">\(h : Q/N \to Q\)</span> astfel Ã®ncÃ¢t <span
class="math inline">\(h_{\mid (K+N)/N} = g\)</span>. Deoarece <span
class="math inline">\((K+N)/N \cong Q/N\)</span> ÅŸi <span
class="math inline">\(g\)</span> este monomorfism, ÅŸi <span
class="math inline">\(h\)</span> este monomorfism. Avem <span
class="math inline">\(K = \operatorname{Im} g = h((K+N)/N) \subseteq
h(Q/N)\)</span>. Cum <span class="math inline">\(K\)</span> este
submodul Ã®nchis, rezultÄƒ <span class="math inline">\(K =
h(Q/N)\)</span>. Din <span class="math inline">\(h\)</span> monomorfism
obÅ£inem <span class="math inline">\((K+N)/N = Q/N\)</span>, deci <span
class="math inline">\(K+N = Q\)</span>. Prin urmare <span
class="math inline">\(K\)</span> este un sumand direct Ã®n <span
class="math inline">\(Q\)</span>.Â â—»</p>
</div>
<div class="theorem">
<p><strong>TeoremÄƒ 3.18</strong> (Eckmannâ€“Schopf). <em>Orice <span
class="math inline">\(R\)</span>-modul <span
class="math inline">\(M\)</span> are o anvelopÄƒ injectivÄƒ unicÄƒ pÃ¢nÄƒ la
un izomorfism.</em></p>
</div>
<div class="proof">
<p><em>Proof.</em> Din PropoziÅ£iaÂ 2.1.14 existÄƒ un <span
class="math inline">\(R\)</span>-modul injectiv <span
class="math inline">\(Q\)</span> astfel Ã®ncÃ¢t <span
class="math inline">\(M \leq Q\)</span>. Fie <span
class="math inline">\(E\)</span> o extensie esenÅ£ialÄƒ maximalÄƒ a lui
<span class="math inline">\(M\)</span> Ã®n <span
class="math inline">\(Q\)</span>. Atunci <span
class="math inline">\(E\)</span> este un submodul complement Ã®n <span
class="math inline">\(Q\)</span>, iar din propoziÅ£ia precedentÄƒ rezultÄƒ
cÄƒ <span class="math inline">\(E\)</span> este injectiv. Astfel <span
class="math inline">\((E,i)\)</span>, cu <span class="math inline">\(i :
M \hookrightarrow E\)</span> incluziunea, este o anvelopÄƒ injectivÄƒ a
lui <span class="math inline">\(M\)</span>.</p>
<p>Pentru unicitate, fie <span class="math inline">\((E_1,i_1)\)</span>
ÅŸi <span class="math inline">\((E_2,i_2)\)</span> douÄƒ anvelope
injective ale lui <span class="math inline">\(M\)</span>. Cum <span
class="math inline">\(E_2\)</span> este injectiv, existÄƒ <span
class="math inline">\(f : E_1 \to E_2\)</span> astfel Ã®ncÃ¢t <span
class="math inline">\(f i_1 = i_2\)</span>. Morfismul <span
class="math inline">\(i_2\)</span> este monomorfism, iar <span
class="math inline">\(i_1\)</span> este monomorfism esenÅ£ial, deci
(folosind 1.4) rezultÄƒ cÄƒ <span class="math inline">\(f\)</span> este
monomorfism. Avem <span class="math inline">\(E_1 \cong f(E_1)\)</span>
ÅŸi <span class="math inline">\(E_2 = f(E_1) \oplus E_3\)</span> pentru
un anumit submodul <span class="math inline">\(E_3\)</span>. Dar <span
class="math inline">\(i_2(M) \subseteq f(E_1)\)</span>, deci <span
class="math inline">\(i_2(M) \cap E_3 = 0\)</span>. Cum <span
class="math inline">\(i_2\)</span> este monomorfism esenÅ£ial, rezultÄƒ
<span class="math inline">\(E_3 = 0\)</span>, deci <span
class="math inline">\(E_2 = f(E_1)\)</span> ÅŸi <span
class="math inline">\(f\)</span> este izomorfism.Â â—»</p>
</div>
<p>Ãn practicÄƒ vom considera un reprezentant al acestei clase pe care Ã®l
vom nota <span class="math inline">\(E(M)\)</span> astfel Ã®ncÃ¢t <span
class="math inline">\(M \trianglelefteq E(M)\)</span>.</p>
<div class="proposition">
<p><strong>PropoziÅ£ie 3.19</strong>. <em>Fie <span
class="math inline">\(M\)</span> un <span
class="math inline">\(R\)</span>-modul ÅŸi <span class="math inline">\(i
: M \to Q\)</span> un monomorfism cu <span
class="math inline">\(Q_R\)</span> injectiv. UrmÄƒtoarele afirmaÅ£ii sunt
echivalente:</em></p>
<ol>
<li><p><em><span class="math inline">\((Q,i)\)</span> este o anvelopÄƒ
injectivÄƒ a lui <span class="math inline">\(M\)</span>;</em></p></li>
<li><p><em>pentru orice monomorfism <span class="math inline">\(f : M
\to Q&#39;\)</span> cu <span class="math inline">\(Q&#39;\)</span>
injectiv, existÄƒ un monomorfism <span class="math inline">\(g : Q \to
Q&#39;\)</span> astfel Ã®ncÃ¢t <span class="math inline">\(g i =
f\)</span>.</em></p></li>
</ol>
</div>
<div class="proof">
<p><em>Proof.</em> <span class="math inline">\((1) \Rightarrow
(2)\)</span>. Fie <span class="math inline">\(f : M \to Q&#39;\)</span>
un monomorfism cu <span class="math inline">\(Q&#39;\)</span> injectiv.
Prin injectivitatea lui <span class="math inline">\(Q&#39;\)</span>
existÄƒ <span class="math inline">\(u : Q \to Q&#39;\)</span> astfel
Ã®ncÃ¢t <span class="math inline">\(u i = f\)</span>. Cum <span
class="math inline">\(i\)</span> este monomorfism esenÅ£ial ÅŸi <span
class="math inline">\(Q&#39;\)</span> este injectiv, imaginea <span
class="math inline">\(u(Q)\)</span> este un complement al lui <span
class="math inline">\(f(M)\)</span>, iar din definiÅ£ia anvelopei
injective rezultÄƒ cÄƒ <span class="math inline">\(u\)</span> este
monomorfism; punem <span class="math inline">\(g=u\)</span>.</p>
<p><span class="math inline">\((2) \Rightarrow (1)\)</span>. Fie <span
class="math inline">\((E(M),j)\)</span> o anvelopÄƒ injectivÄƒ a lui <span
class="math inline">\(M\)</span>. AplicÃ¢nd (2) la <span
class="math inline">\(f=j\)</span> obÅ£inem un monomorfism <span
class="math inline">\(g : Q \to E(M)\)</span> cu <span
class="math inline">\(g i = j\)</span>. Cum <span
class="math inline">\(j\)</span> este monomorfism esenÅ£ial, rezultÄƒ cÄƒ
ÅŸi <span class="math inline">\(i\)</span> este monomorfism esenÅ£ial,
deci <span class="math inline">\((Q,i)\)</span> este o anvelopÄƒ
injectivÄƒ a lui <span class="math inline">\(M\)</span>.Â â—»</p>
</div>
<div class="proposition">
<p><strong>PropoziÅ£ie 3.20</strong>. <em>Oricare ar fi <span
class="math inline">\(R\)</span>-modulele drepte <span
class="math inline">\(M_1,M_2,\dots,M_n\)</span> avem <span
class="math display">\[E\!\left(\bigoplus_{i=1}^{n} M_i\right)
  \cong \bigoplus_{i=1}^{n} E(M_i).\]</span></em></p>
</div>
<div class="proof">
<p><em>Proof.</em> Din 1.9, <span
class="math inline">\(\bigoplus_{i=1}^{n} E(M_i)\)</span> este o
extensie esenÅ£ialÄƒ a lui <span class="math inline">\(\bigoplus_{i=1}^{n}
M_i\)</span>. Cum <span class="math display">\[\bigoplus_{i=1}^{n}
E(M_i) \cong \prod_{i=1}^{n} E(M_i),\]</span> din 2.1.3 rezultÄƒ cÄƒ <span
class="math inline">\(\bigoplus_{i=1}^{n} E(M_i)\)</span> este injectiv.
Prin unicitatea anvelopei injective obÅ£inem <span
class="math display">\[E\!\left(\bigoplus_{i=1}^{n} M_i\right)
  \cong \bigoplus_{i=1}^{n} E(M_i).\]</span>Â â—»</p>
</div>
<div class="theorem">
<p><strong>TeoremÄƒ 3.21</strong>. <em>Fie <span
class="math inline">\(Q\)</span> ÅŸi <span
class="math inline">\(M\)</span> douÄƒ <span
class="math inline">\(R\)</span>-module. Atunci <span
class="math inline">\(Q\)</span> este <span
class="math inline">\(M\)</span>-injectiv dacÄƒ ÅŸi numai dacÄƒ <span
class="math inline">\(f(M) \leq Q\)</span>, oricare ar fi <span
class="math inline">\(f \in
\mathop{\mathrm{Hom}}(E(M),E(Q))\)</span>.</em></p>
</div>
<div class="proof">
<p><em>Proof.</em> â€<span class="math inline">\(\Rightarrow\)</span>â€
Fie <span class="math inline">\(f \in
\mathop{\mathrm{Hom}}(E(M),E(Q))\)</span> ÅŸi notÄƒm <span
class="math display">\[K := \{\,m \in M \mid f(m) \in Q\,\}.\]</span>
Cum <span class="math inline">\(Q\)</span> este <span
class="math inline">\(M\)</span>-injectiv, existÄƒ un morfism <span
class="math inline">\(\bar{f} : M \to Q\)</span> astfel Ã®ncÃ¢t <span
class="math inline">\(\bar{f}\!\mid_{K} = f\!\mid_{K}\)</span>. ArÄƒtÄƒm
cÄƒ <span class="math display">\[Q \cap (\bar{f}-f)(M) = 0.\]</span> Fie
<span class="math inline">\(x \in Q\)</span> ÅŸi <span
class="math inline">\(m \in M\)</span> cu <span class="math inline">\(x
= (\bar{f}-f)(m)\)</span>. Atunci <span class="math display">\[f(m) =
\bar{f}(m) - x \in Q,\]</span> deci <span class="math inline">\(m \in
K\)</span>. UrmeazÄƒ cÄƒ <span class="math display">\[x = \bar{f}(m) -
f(m) = f(m) - f(m) = 0.\]</span> Prin urmare <span
class="math inline">\(Q \cap (\bar{f}-f)(M) = 0\)</span> ÅŸi, cum <span
class="math inline">\(Q \trianglelefteq E(Q)\)</span>, rezultÄƒ cÄƒ <span
class="math inline">\((\bar{f}-f)(M) = 0\)</span>. AÅŸadar <span
class="math inline">\(f(M) = \bar{f}(M) \leq Q\)</span>.</p>
<p>â€<span class="math inline">\(\Leftarrow\)</span>â€ ÃntrucÃ¢t <span
class="math inline">\(E(Q)\)</span> este injectiv, este suficient sÄƒ
considerÄƒm <span class="math inline">\(f \in
\mathop{\mathrm{Hom}}(M,E(Q))\)</span>. Fie <span
class="math inline">\(N\)</span> un submodul al lui <span
class="math inline">\(M\)</span> ÅŸi <span class="math inline">\(g : N
\to Q\)</span> un morfism de <span
class="math inline">\(R\)</span>-module. Cum <span
class="math inline">\(E(Q)\)</span> este injectiv, existÄƒ un morfism
<span class="math inline">\(\tilde{g} : M \to E(Q)\)</span> astfel Ã®ncÃ¢t
<span class="math inline">\(\tilde{g}\!\mid_{N} = i \circ g\)</span>,
unde <span class="math inline">\(i : Q \to E(Q)\)</span> este injecÅ£ia
canonicÄƒ. Prin ipotezÄƒ avem <span class="math inline">\(\tilde{g}(M)
\leq Q\)</span>, astfel Ã®ncÃ¢t, identificÃ¢nd <span
class="math inline">\(\tilde{g}\)</span> cu corestricÅ£ia sa la <span
class="math inline">\(Q\)</span>, obÅ£inem un morfism <span
class="math inline">\(h : M \to Q\)</span> cu <span
class="math inline">\(h\!\mid_{N} = g\)</span>. Prin urmare <span
class="math inline">\(Q\)</span> este <span
class="math inline">\(M\)</span>-injectiv.Â â—»</p>
</div>
<div class="corollary">
<p><strong>Corolar 3.22</strong>. <em>Un <span
class="math inline">\(R\)</span>-modul <span
class="math inline">\(Q\)</span> este quasi-injectiv dacÄƒ ÅŸi numai dacÄƒ
<span class="math inline">\(f(Q) \leq Q\)</span> pentru orice <span
class="math inline">\(f \in
\mathop{\mathrm{End}}(E(Q))\)</span>.</em></p>
</div>
<div class="theorem">
<p><strong>TeoremÄƒ 3.23</strong> (Matlisâ€“Bass). <em>Fie <span
class="math inline">\(R\)</span> un inel. Atunci <span
class="math inline">\(R\)</span> este noetherian la dreapta dacÄƒ ÅŸi
numai dacÄƒ, pentru orice <span class="math inline">\(R\)</span>-modul
simplu <span class="math inline">\(S_i\)</span> (<span
class="math inline">\(i \geq 1\)</span>), <span class="math display">\[Q
:= \bigoplus_{i=1}^{\infty} E(S_i)\]</span> este un <span
class="math inline">\(R\)</span>-modul injectiv.</em></p>
</div>
<div class="proof">
<p><em>Proof.</em> â€<span class="math inline">\(\Rightarrow\)</span>â€
Fie <span class="math inline">\(L\)</span> un ideal drept al lui <span
class="math inline">\(R\)</span>, <span class="math display">\[Q =
\bigoplus_{i=1}^{\infty} E(S_i)\]</span> ÅŸi <span
class="math inline">\(f : L \to Q\)</span> un morfism de <span
class="math inline">\(R\)</span>-module. ExistÄƒ elemente <span
class="math inline">\(a_1,\dots,a_n \in L\)</span> astfel Ã®ncÃ¢t <span
class="math display">\[L = a_1 R + a_2 R + \cdots + a_n R.\]</span> Ãn
mod evident existÄƒ <span class="math inline">\(m \geq 1\)</span> astfel
Ã®ncÃ¢t <span class="math inline">\(f(a_k) \in \bigoplus_{j=1}^{m}
E(S_j)\)</span> pentru orice <span class="math inline">\(k =
1,\dots,n\)</span>, deci <span class="math display">\[\Im f \subseteq
\bigoplus_{j=1}^{m} E(S_j).\]</span> Cum <span
class="math inline">\(\bigoplus_{j=1}^{m} E(S_j)\)</span> este injectiv,
existÄƒ <span class="math inline">\(g : R \to \bigoplus_{j=1}^{m}
E(S_j)\)</span> astfel Ã®ncÃ¢t <span class="math inline">\(g\!\mid_{L} =
f\)</span>. NotÄƒm <span class="math inline">\(\bar{f} = i \circ
g\)</span>, unde <span class="math inline">\(i : \bigoplus_{j=1}^{m}
E(S_j) \to Q\)</span> este injecÅ£ia canonicÄƒ. Atunci <span
class="math inline">\(\bar{f}\!\mid_{L} = f\)</span>, deci <span
class="math inline">\(Q\)</span> este injectiv.</p>
<p>â€<span class="math inline">\(\Leftarrow\)</span>â€ Presupunem cÄƒ <span
class="math inline">\(R\)</span> nu este noetherian la dreapta. Atunci
existÄƒ un ÅŸir strict ascendent de ideale la dreapta, finit generate:
<span class="math display">\[L_1 \subsetneq L_2 \subsetneq \cdots
\subsetneq L_n \subsetneq \cdots .\]</span> Din lema lui Krull rezultÄƒ
cÄƒ, pentru orice <span class="math inline">\(n \geq 1\)</span>, existÄƒ
un submodul maximal <span class="math inline">\(M_n \subsetneq
L_n\)</span> astfel Ã®ncÃ¢t <span class="math display">\[L_{n-1} \subseteq
M_n \quad \text{pentru orice } n \geq 2.\]</span> Fie <span
class="math display">\[L := \bigcup_{k=1}^{\infty} L_k, \qquad
\pi_k : L_k \longrightarrow L_k/M_k\]</span> proiecÅ£iile canonice ÅŸi
<span class="math display">\[E_k := E(L_k/M_k) \quad \text{pentru orice
} k \geq 1.\]</span> Atunci <span class="math display">\[E :=
\bigoplus_{k=1}^{\infty} E_k\]</span> este injectiv ÅŸi <span
class="math display">\[f : L \longrightarrow E, \qquad
f(a) = \sum_{k=1}^{\infty} \pi_k(a)\]</span> este bine definit. ExistÄƒ
un element <span class="math inline">\(x \in E_1 \oplus \cdots \oplus
E_n\)</span> astfel Ã®ncÃ¢t <span class="math inline">\(f(a) = x
a\)</span> pentru orice <span class="math inline">\(a \in L\)</span>.
RezultÄƒ cÄƒ <span class="math inline">\(\pi_k(a) = 0\)</span> pentru
orice <span class="math inline">\(k \geq n+1\)</span>, adicÄƒ <span
class="math inline">\(a \in M_k\)</span> pentru orice <span
class="math inline">\(k \geq n+1\)</span>. Prin urmare <span
class="math display">\[L \subseteq M_{n+1} \subsetneq L_{n+1} \subseteq
M_{n+2} \subsetneq L_{n+2}
\subseteq \cdots \subseteq L,\]</span> contradicÅ£ie. ObÅ£inem cÄƒ <span
class="math inline">\(R\)</span> este noetherian la dreapta.Â â—»</p>
</div>
<h1 id="sume-directe-de-module-coireductibile">Sume directe de module
coireductibile</h1>
<div class="proposition">
<p><strong>PropoziÅ£ie 4.1</strong>. <em>Fie <span
class="math inline">\(M\)</span> un <span
class="math inline">\(R\)</span>-modul ÅŸi <span
class="math inline">\(E(M)\)</span> anvelopa sa injectivÄƒ. Atunci
urmÄƒtoarele afirmaÅ£ii sunt echivalente:</em></p>
<ol>
<li><p><em><span class="math inline">\(E(M)\)</span> este
indecompozabil.</em></p></li>
<li><p><em>DacÄƒ <span class="math inline">\(L\)</span> ÅŸi <span
class="math inline">\(K\)</span> sunt submodule nenule ale lui <span
class="math inline">\(M\)</span>, atunci <span class="math inline">\(L
\cap K \neq 0\)</span>.</em></p></li>
<li><p><em>DacÄƒ <span class="math inline">\(x,y \in
M\setminus\{0\}\)</span>, atunci existÄƒ <span class="math inline">\(a,b
\in R\)</span> astfel Ã®ncÃ¢t <span class="math inline">\(0 \neq xa =
yb\)</span>.</em></p></li>
<li><p><em><span class="math inline">\(M\)</span> este o extensie
esenÅ£ialÄƒ a oricÄƒrui submodul nenul al sÄƒu.</em></p></li>
</ol>
</div>
<div class="proof">
<p><em>Proof.</em> <span class="math inline">\((2) \Rightarrow
(1)\)</span>. Presupunem cÄƒ <span class="math inline">\(E(M) = L&#39;
\oplus K&#39;\)</span> cu <span class="math inline">\(L&#39;\)</span> ÅŸi
<span class="math inline">\(K&#39;\)</span> submodule nenule ale lui
<span class="math inline">\(E(M)\)</span>. Cum <span
class="math inline">\(M \trianglelefteq E(M)\)</span>, avem cÄƒ <span
class="math inline">\(L = L&#39; \cap M \neq 0\)</span> ÅŸi <span
class="math inline">\(K = K&#39; \cap M \neq 0\)</span>, deci <span
class="math display">\[L \cap K = (L&#39; \cap K&#39;) \cap M =
0,\]</span> ceea ce contrazice ipoteza (2).</p>
<p><span class="math inline">\((1) \Rightarrow (2)\)</span>. Presupunem
cÄƒ existÄƒ <span class="math inline">\(L,K\)</span> submodule nenule ale
lui <span class="math inline">\(M\)</span> astfel Ã®ncÃ¢t <span
class="math inline">\(L \cap K = 0\)</span>. Atunci <span
class="math inline">\(E(L) \leq E(M)\)</span> ÅŸi <span
class="math inline">\(K \cap E(L) = 0\)</span> (altfel, cum <span
class="math inline">\(L \subseteq E(L)\)</span>, am avea <span
class="math inline">\(L \cap K \neq 0\)</span>). Dar ÅŸirul exact scurt
<span class="math display">\[0 \longrightarrow E(L) \longrightarrow E(M)
\longrightarrow E(M)/E(L)
\longrightarrow 0\]</span> este scindat deoarece <span
class="math inline">\(E(L)\)</span> este injectiv ÅŸi deci <span
class="math inline">\(E(M) \cong E(L) \oplus E(M)/E(L)\)</span>. ObÅ£inem
astfel <span class="math display">\[0 = K \cap E(L) = K \cap E(M) =
K,\]</span> contradicÅ£ie.</p>
<p>EchivalenÅ£ele <span class="math inline">\((2) \Leftrightarrow
(3)\)</span> ÅŸi <span class="math inline">\((2) \Leftrightarrow
(4)\)</span> sunt evidente.Â â—»</p>
</div>
<div class="definition">
<p><strong>DefiniÅ£ie 4.2</strong>. Un modul <span
class="math inline">\(M\)</span> care satisface una din condiÅ£iile
echivalente de mai sus se numeÅŸte <em>coireductibil</em> (sau
<em>uniform</em>). Fie <span class="math inline">\(M\)</span> un <span
class="math inline">\(R\)</span>-modul ÅŸi <span
class="math inline">\(N\)</span> un submodul propriu al sÄƒu. DacÄƒ <span
class="math inline">\(M/N\)</span> este coireductibil, atunci spunem cÄƒ
<span class="math inline">\(N\)</span> este <em>ireductibil</em> Ã®n
<span class="math inline">\(M\)</span>. Este clar cÄƒ <span
class="math inline">\(N\)</span> este ireductibil Ã®n <span
class="math inline">\(M\)</span> dacÄƒ ÅŸi numai dacÄƒ din egalitatea <span
class="math inline">\(N = P \cap Q\)</span>, unde <span
class="math inline">\(P,Q \le M\)</span>, rezultÄƒ <span
class="math inline">\(N = P\)</span> sau <span class="math inline">\(N =
Q\)</span>.</p>
</div>
<div class="example*">
<p><strong>Exemplu 4.1</strong>. </p>
<ol>
<li><p>Este clar cÄƒ orice modul simplu este coireductibil.</p></li>
<li><p><span class="math inline">\(\mathbb{Z}\)</span> este <span
class="math inline">\(\mathbb{Z}\)</span>-modul coireductibil.</p></li>
<li><p>Din PropoziÅ£iaÂ 3.1 rezultÄƒ cÄƒ un modul injectiv este
indecompozabil dacÄƒ ÅŸi numai dacÄƒ este coireductibil. Ãn particular,
dacÄƒ <span class="math inline">\(M\)</span> este un <span
class="math inline">\(R\)</span>-modul coireductibil, atunci <span
class="math inline">\(E(M)\)</span> este coireductibil. RezultÄƒ cÄƒ <span
class="math inline">\(\mathbb{Q}\)</span> ÅŸi <span
class="math inline">\(\mathbb{Z}_{p^\infty}\)</span> sunt <span
class="math inline">\(\mathbb{Z}\)</span>-module
coireductibile.</p></li>
<li><p><span class="math inline">\(\mathbb{Z}_n\)</span> este <span
class="math inline">\(\mathbb{Z}\)</span>-modul coireductibil dacÄƒ ÅŸi
numai dacÄƒ <span class="math inline">\(n\)</span> este puterea unui
numÄƒr prim. DacÄƒ <span class="math inline">\(n = p^k\)</span> cu <span
class="math inline">\(p \ge 2\)</span> ÅŸi <span class="math inline">\(k
\ge 1\)</span>, atunci <span class="math inline">\(\langle p^m \rangle
\subseteq \langle p^i \rangle \cap \langle p^j \rangle\)</span> pentru
orice <span class="math inline">\(i,j \in \{1,\dots,k-1\}\)</span>, unde
<span class="math inline">\(m = \min(i,j)\)</span>, ÅŸi deci <span
class="math inline">\(\mathbb{Z}_{p^k}\)</span> este coireductibil.
Reciproc, presupunem cÄƒ <span
class="math inline">\(\mathbb{Z}_n\)</span> este coireductibil ÅŸi <span
class="math inline">\(n = p_1^{\alpha_1}\cdots p_s^{\alpha_s}\)</span>
este descompunerea lui <span class="math inline">\(n\)</span> Ã®n factori
primi. DacÄƒ <span class="math inline">\(s \ge 2\)</span>, atunci avem
<span class="math display">\[\langle p_1^{\alpha_1}\cdots
p_{s-1}^{\alpha_{s-1}} \rangle
          + \mathbb{Z}
          \quad\text{ÅŸi}\quad
          \langle p_s^{\alpha_s} \rangle + \mathbb{Z}\]</span> submodule
nenule a cÄƒror intersecÅ£ie este zero, contradicÅ£ie. ObÅ£inem cÄƒ <span
class="math inline">\(s = 1\)</span>, deci <span
class="math inline">\(n\)</span> este o putere a unui numÄƒr
prim.</p></li>
</ol>
</div>
<div class="proposition">
<p><strong>PropoziÅ£ie 4.3</strong>. <em>Fie <span
class="math inline">\(M\)</span> un <span
class="math inline">\(R\)</span>-modul ÅŸi <span
class="math inline">\(N\)</span> un submodul propriu al lui <span
class="math inline">\(M\)</span>. DacÄƒ <span class="math inline">\(x \in
M \setminus N\)</span>, atunci existÄƒ un submodul ireductibil <span
class="math inline">\(P\)</span> al lui <span
class="math inline">\(M\)</span> astfel Ã®ncÃ¢t <span
class="math inline">\(N \subseteq P\)</span> ÅŸi <span
class="math inline">\(x \notin P\)</span>.</em></p>
</div>
<div class="proof">
<p><em>Proof.</em> Fie <span class="math display">\[\mathfrak{S} =
\{\,N&#39; \le M \mid N \subseteq N&#39; \text{ ÅŸi } x \notin
N&#39;\,\}.\]</span> MulÅ£imea <span
class="math inline">\(\mathfrak{S}\)</span>, ordonatÄƒ prin incluziune,
este inductivÄƒ, deci, prin lema lui Zorn, admite un element maximal
<span class="math inline">\(P\)</span>. ArÄƒtÄƒm cÄƒ <span
class="math inline">\(P\)</span> este ireductibil Ã®n <span
class="math inline">\(M\)</span>. Presupunem cÄƒ <span
class="math inline">\(P = U \cap V\)</span> cu <span
class="math inline">\(U,V \le M\)</span> ÅŸi <span
class="math inline">\(P \subsetneq U\)</span>, <span
class="math inline">\(P \subsetneq V\)</span>. Cum <span
class="math inline">\(x \notin P\)</span>, avem <span
class="math inline">\(x \notin U\)</span> sau <span
class="math inline">\(x \notin V\)</span>; sÄƒ spunem <span
class="math inline">\(x \notin U\)</span>. Atunci <span
class="math inline">\(U \in \mathfrak{S}\)</span> ÅŸi <span
class="math inline">\(P \subsetneq U\)</span>, ceea ce contrazice
maximalitatea lui <span class="math inline">\(P\)</span>. RezultÄƒ cÄƒ
<span class="math inline">\(P\)</span> este ireductibil.Â â—»</p>
</div>
<div class="corollary">
<p><strong>Corolar 4.4</strong>. <em>Fie <span
class="math inline">\(M\)</span> un <span
class="math inline">\(R\)</span>-modul ÅŸi <span
class="math inline">\(N\)</span> un submodul propriu al lui <span
class="math inline">\(M\)</span>. Atunci <span
class="math inline">\(N\)</span> este intersecÅ£ie de submodule
ireductibile Ã®n <span class="math inline">\(M\)</span>.</em></p>
</div>
<div class="proof">
<p><em>Proof.</em> RezultÄƒ imediat din propoziÅ£ia anterioarÄƒ.Â â—»</p>
</div>
<div class="corollary">
<p><strong>Corolar 4.5</strong>. <em>Let <span
class="math inline">\(M\)</span> be an <span
class="math inline">\(R\)</span>-module and <span
class="math inline">\(N\)</span> a proper submodule of <span
class="math inline">\(M\)</span>. Then <span
class="math inline">\(N\)</span> is the intersection of irreducible
submodules of <span class="math inline">\(M\)</span>.</em></p>
</div>
<div class="proof">
<p><em>Proof.</em> This follows immediately from PropositionÂ 3.3,
applied to each <span class="math inline">\(x \in M \setminus
N\)</span>.Â â—»</p>
</div>
<div class="proof">
<p><em>Proof.</em> 1) RezultÄƒ imediat din 3.1.</p>
<p>2) Fie <span class="math inline">\(M \trianglelefteq E\)</span> o
extensie esenÅ£ialÄƒ a lui <span class="math inline">\(M\)</span>. DacÄƒ
<span class="math inline">\(E_1,E_2\)</span> sunt submodule nenule ale
lui <span class="math inline">\(E\)</span>, atunci <span
class="math inline">\(M \cap E_1 \neq 0\)</span> ÅŸi <span
class="math inline">\(M \cap E_2 \neq 0\)</span>, de unde rezultÄƒ cÄƒ
<span class="math display">\[(M \cap E_1) \cap (M \cap E_2) \neq
0\]</span> ÅŸi deci <span class="math inline">\(E_1 \cap E_2 \neq
0\)</span>, adicÄƒ <span class="math inline">\(E\)</span> este
coireductibil.Â â—»</p>
</div>
<div class="lemma">
<p><strong>LemÄƒ 4.6</strong>. <em>Fie <span
class="math inline">\(M\)</span> un <span
class="math inline">\(R\)</span>-modul ÅŸi <span
class="math inline">\((M_\alpha)_{\alpha \in \Lambda}\)</span> o familie
de submodule independente. DacÄƒ <span class="math inline">\(N\)</span>
este un submodul al lui <span class="math inline">\(M\)</span> astfel
Ã®ncÃ¢t <span class="math display">\[N \cap \Bigl(\sum_{\alpha \in
\Lambda} M_\alpha\Bigr) \neq 0,\]</span> existÄƒ un submodul nenul
Ã®ntr-un <span class="math inline">\(M_\alpha\)</span> izomorf cu un
submodul din <span class="math inline">\(N\)</span>.</em></p>
</div>
<div class="proof">
<p><em>Proof.</em> DacÄƒ <span
class="math inline">\(\operatorname{Card}\Lambda = 1\)</span>, afirmaÅ£ia
este evidentÄƒ.</p>
<p>DacÄƒ <span class="math inline">\(\operatorname{Card}\Lambda =
2\)</span>, punem <span class="math inline">\(P = N \cap (M_1 +
M_2)\)</span>. DacÄƒ <span class="math inline">\(N \cap M_1 = 0\)</span>,
atunci <span class="math inline">\(P \cong (P + M_1)/M_1\)</span> ÅŸi
<span class="math display">\[(P + M_1)/M_1 \leq (M_1 + M_2)/M_1 \cong
M_2.\]</span> Deci <span class="math inline">\(P\)</span> este izomorf
cu un submodul din <span class="math inline">\(M_2\)</span>. DacÄƒ <span
class="math inline">\(\Lambda\)</span> este mulÅ£ime finitÄƒ, procedÃ¢nd
prin inducÅ£ie, demonstraÅ£ia se reduce la cazul precedent.</p>
<p>DacÄƒ <span class="math inline">\(\Lambda\)</span> este infinitÄƒ,
considerÄƒm <span class="math inline">\(x \in N \cap \bigl(\sum_{\alpha
\in \Lambda} M_\alpha\bigr)\)</span>, <span class="math inline">\(x \neq
0\)</span>. Atunci existÄƒ <span
class="math inline">\(\alpha_1,\ldots,\alpha_n \in \Lambda\)</span>
astfel Ã®ncÃ¢t <span class="math display">\[xR \cap (M_{\alpha_1} +
M_{\alpha_2} + \cdots + M_{\alpha_n}) \neq 0\]</span> ÅŸi ne reducem la
cazul Ã®n care <span class="math inline">\(\Lambda\)</span> este
finitÄƒ.Â â—»</p>
</div>
<div class="remark">
<p><em>ObservaÅ£ie 4.7</em>. Fie <span class="math inline">\(M\)</span>
un <span class="math inline">\(R\)</span>-modul drept ÅŸi <span
class="math inline">\(\Omega\)</span> mulÅ£imea de submodule
coireductibile din <span class="math inline">\(M\)</span>. Este posibil
ca <span class="math inline">\(\Omega = \emptyset\)</span>. Fie <span
class="math display">\[\mathcal{S} = \bigl\{\Omega&#39; \subseteq \Omega
\,\bigm|\, \sum_{N \in \Omega&#39;}
N \text{ este directÄƒ} \bigr\}.\]</span> Perechea <span
class="math inline">\((\mathcal{S},\subseteq)\)</span> este inductivÄƒ
ÅŸi, din lema lui Zorn, <span class="math inline">\(\mathcal{S}\)</span>
are un element maximal <span class="math inline">\(\Omega_0\)</span>.
Punem <span class="math inline">\(S = \bigoplus_{N \in \Omega_0}
N\)</span>. Spunem cÄƒ <span class="math inline">\(S\)</span> este o sumÄƒ
directÄƒ maximalÄƒ de submodule coireductibile din <span
class="math inline">\(M\)</span>.</p>
</div>
<div class="proposition">
<p><strong>PropoziÅ£ie 4.8</strong>. <em>Fie <span
class="math inline">\(M\)</span> un <span
class="math inline">\(R\)</span>-modul ÅŸi <span
class="math inline">\(S\)</span> o sumÄƒ directÄƒ maximalÄƒ de submodule
coireductibile din <span class="math inline">\(M\)</span>. DacÄƒ <span
class="math inline">\(N\)</span> este un submodul nenul al lui <span
class="math inline">\(M\)</span>, atunci urmÄƒtoarele afirmaÅ£ii sunt
echivalente:</em></p>
<ol>
<li><p><em><span class="math inline">\(S \cap N \neq
0\)</span>;</em></p></li>
<li><p><em><span class="math inline">\(N\)</span> conÅ£ine un submodul
coireductibil.</em></p></li>
</ol>
</div>
<div class="proof">
<p><em>Proof.</em> ImplicaÅ£ia <span
class="math inline">\((1)\Rightarrow(2)\)</span> rezultÄƒ din
lemaÂ 3.6.</p>
<p>ImplicaÅ£ia <span class="math inline">\((2)\Rightarrow(1)\)</span>
rezultÄƒ din maximalitatea lui <span
class="math inline">\(S\)</span>.Â â—»</p>
</div>
<div class="theorem">
<p><strong>TeoremÄƒ 4.9</strong>. <em>Fie <span
class="math inline">\(M\)</span> un <span
class="math inline">\(R\)</span>-modul ÅŸi <span
class="math inline">\(S\)</span> o sumÄƒ directÄƒ maximalÄƒ de submodule
coireductibile din <span class="math inline">\(M\)</span>. ExistÄƒ un
submodul <span class="math inline">\(K\)</span> maximal printre
submodulele lui <span class="math inline">\(M\)</span> care nu conÅ£in
nici un coireductibil, cu proprietÄƒÅ£ile:</em></p>
<ol>
<li><p><em><span class="math inline">\(S + K\)</span> este
directÄƒ;</em></p></li>
<li><p><em><span class="math inline">\((S \oplus K) \trianglelefteq
M\)</span>.</em></p></li>
</ol>
</div>
<div class="proof">
<p><em>Proof.</em></p>
<ol>
<li><p>Fie <span class="math display">\[\mathcal{S} = \{\,L \leq M \mid
\forall L&#39; \leq L,\; L&#39; \text{ nu este
coireductibil}\,\}.\]</span> Avem <span
class="math inline">\(\mathcal{S} \neq \emptyset\)</span> deoarece <span
class="math inline">\(0 \in \mathcal{S}\)</span> ÅŸi <span
class="math inline">\(\mathcal{S}\)</span> este inductivÄƒ. Din lema lui
Zorn, <span class="math inline">\(\mathcal{S}\)</span> are un element
maximal <span class="math inline">\(K\)</span>. Din PropoziÅ£iaÂ 3.8
rezultÄƒ cÄƒ <span class="math inline">\(S \cap K = 0\)</span>.</p></li>
<li><p>Presupunem cÄƒ <span class="math inline">\(N \cap (S \oplus K) =
0\)</span>, unde <span class="math inline">\(N\)</span> este un submodul
nenul al lui <span class="math inline">\(M\)</span>. Atunci <span
class="math inline">\((N + K) \cap S = 0\)</span> ÅŸi din PropoziÅ£iaÂ 3.8
rezultÄƒ cÄƒ <span class="math inline">\(N + K\)</span> nu conÅ£ine nici un
submodul coireductibil, ceea ce contrazice maximalitatea lui <span
class="math inline">\(K\)</span>. ObÅ£inem cÄƒ <span
class="math inline">\((S \oplus K) \trianglelefteq M\)</span>.</p></li>
</ol>
<p>Â â—»</p>
</div>
<div class="definition">
<p><strong>DefiniÅ£ie 4.10</strong>. Fie <span
class="math inline">\(M\)</span> un <span
class="math inline">\(R\)</span>-modul. O intersecÅ£ie finitÄƒ de
submodule <span class="math display">\[\bigcap_{i \in I} N_i \qquad (I
\text{ finit})\]</span> se numeÅŸte <em>redusÄƒ</em> dacÄƒ, oricare ar fi
<span class="math inline">\(i \in I\)</span>, avem <span
class="math display">\[\bigcap_{i \in I} N_i \neq
\bigcap_{\substack{j \in I \\ j \neq i}} N_j .\]</span></p>
<p>Este clar cÄƒ, dacÄƒ avem o intersecÅ£ie finitÄƒ <span
class="math inline">\(N = \bigcap_{i \in I} N_i\)</span> de submodule
ireductibile, ea poate fi adusÄƒ Ã®ntotdeauna la o intersecÅ£ie redusÄƒ de
submodule ireductibile.</p>
</div>
<div class="theorem">
<p><strong>TeoremÄƒ 4.11</strong> (Teorema (Kurosâ€“Ore)). <em>Fie <span
class="math inline">\(M\)</span> un <span
class="math inline">\(R\)</span>-modul ÅŸi <span
class="math inline">\(N\)</span> un submodul al lui <span
class="math inline">\(M\)</span>. Presupunem cÄƒ avem intersecÅ£iile
finite reduse pentru <span class="math inline">\(N\)</span>: <span
class="math display">\[N = N_1 \cap N_2 \cap \dots \cap N_m = L_1 \cap
L_2 \cap \dots \cap L_n ,\]</span> unde <span
class="math inline">\(N_i\)</span> ÅŸi <span
class="math inline">\(L_j\)</span> sunt submodule ireductibile din <span
class="math inline">\(M\)</span>. Atunci <span class="math inline">\(m =
n\)</span>.</em></p>
</div>
<div class="proof">
<p><em>Proof.</em> NotÄƒm <span class="math inline">\(N_i&#39; = N_1 \cap
\dots \cap N_{i-1} \cap N_{i+1} \cap \dots \cap N_m\)</span>. Avem cÄƒ
<span class="math inline">\(N \subseteq N_i&#39;\)</span> ÅŸi <span
class="math inline">\(N = N_i \cap N_i&#39;\)</span>. Fie <span
class="math inline">\(P_j = N_i \cap L_j\)</span>, <span
class="math inline">\(\forall j = 1,\dots,n\)</span>. Atunci <span
class="math inline">\(N \subseteq P_j \subseteq N_i&#39;\)</span> ÅŸi
<span class="math inline">\(P_j \subseteq L_j\)</span>, de unde rezultÄƒ
cÄƒ <span class="math display">\[N \subseteq \bigcap_{j=1}^n P_j
\subseteq \bigcap_{j=1}^n L_j = N,\]</span> ÅŸi deci <span
class="math inline">\(\bigcap_{j=1}^n P_j = N\)</span>.</p>
<p>Cum <span class="math inline">\(N_i\)</span> este ireductibil Ã®n
<span class="math inline">\(M\)</span>, rezultÄƒ cÄƒ <span
class="math inline">\(N_i\)</span> este ireductibil Ã®n <span
class="math inline">\(N_i + N_i&#39;\)</span>, ÅŸi deci <span
class="math display">\[\frac{N_i&#39;}{N_i&#39; \cap N_i} \cong
\frac{N_i + N_i&#39;}{N_i}\]</span> este coirreductibil, ceea ce aratÄƒ
cÄƒ <span class="math inline">\(N\)</span> este ireductibil Ã®n <span
class="math inline">\(N_i&#39;\)</span>.</p>
<p>Atunci, din egalitatea <span class="math inline">\(N =
\bigcap_{j=1}^n P_j\)</span>, existÄƒ un <span
class="math inline">\(j\)</span> astfel Ã®ncÃ¢t <span
class="math inline">\(N = P_j\)</span>. Deci <span
class="math inline">\(N = N_i \cap L_j\)</span>, adicÄƒ <span
class="math display">\[N = N_i \cap \dots \cap N_{i-1} \cap L_j \cap
N_{i+1} \cap \dots \cap N_m.\]</span></p>
<p>NotÄƒm <span class="math inline">\(I = \{1,2,\dots,m\}\)</span>, <span
class="math inline">\(J = \{1,2,\dots,n\}\)</span> ÅŸi fie <span
class="math inline">\(i_1 \in I\)</span>. ExistÄƒ <span
class="math inline">\(j_1 \in J\)</span> astfel Ã®ncÃ¢t <span
class="math display">\[N = L_{j_1} \cap \left(\bigcap_{i \ne i_1}
N_i\right).\]</span></p>
<p>Deoarece intersecÅ£ia este finitÄƒ, putem sÄƒ o reducem: din reducerea
succesivÄƒ ÅŸi prin faptul cÄƒ nu dispare niciun <span
class="math inline">\(L_{j_k}\)</span>, obÅ£inem un ÅŸir strict
descrescÄƒtor <span class="math display">\[J \supseteq J_1 \supseteq J_2
\supseteq \dots \supseteq J_r,\]</span> cu cel mult <span
class="math inline">\(r\le m\)</span> elemente, astfel Ã®ncÃ¢t pentru un
anumit set final <span class="math inline">\(J&#39;\subseteq J\)</span>,
<span class="math display">\[N = \bigcap_{j\in J&#39;} L_j.\]</span></p>
<p>Este clar cÄƒ <span class="math inline">\(r\le m\)</span>. Cum
intersecÅ£ia <span class="math inline">\(N = L_1 \cap \dots \cap
L_n\)</span> este redusÄƒ, avem <span class="math inline">\(J&#39; =
J\)</span>. Pe de altÄƒ parte, <span
class="math inline">\(J&#39;\)</span> are cel mult <span
class="math inline">\(r\)</span> elemente, deci <span
class="math inline">\(n \le r \le m\)</span>, iar simetric <span
class="math inline">\(m \le n\)</span>.Â â—»</p>
</div>
<div class="theorem">
<p><strong>TeoremÄƒ 4.12</strong>. <em>Fie <span
class="math inline">\(M\)</span> un <span
class="math inline">\(R\)</span>-modul ÅŸi <span
class="math inline">\((N_i)_{i=1}^m\)</span> ÅŸi <span
class="math inline">\((L_j)_{j=1}^n\)</span> douÄƒ familii independente
de submodule coirreductibile astfel Ã®ncÃ¢t <span
class="math display">\[\bigoplus_{i=1}^m N_i \subseteq M
\quad\text{ÅŸi}\quad
\bigoplus_{j=1}^n L_j \subseteq M\]</span> sunt esenÅ£iale Ã®n <span
class="math inline">\(M\)</span>. Atunci <span class="math inline">\(m =
n\)</span>.</em></p>
</div>
<div class="proof">
<p><em>Proof.</em> NotÄƒm <span class="math inline">\(N_k&#39; =
\bigoplus_{i\ne k} N_i\)</span>, pentru fiecare <span
class="math inline">\(k=1,\dots,m\)</span>. Atunci <span
class="math inline">\(N_k \cap N_k&#39; = 0\)</span>.</p>
<p>Se verificÄƒ uÅŸor cÄƒ mulÅ£imea <span
class="math display">\[\mathfrak{S}_k = \{P \le M \mid N_k \cap P = 0
\text{ ÅŸi } N_k \subseteq P\}\]</span> este inductivÄƒ. Din lema lui
Zorn, are un element maximal <span class="math inline">\(P_k\)</span>.
DacÄƒ <span class="math inline">\(Q,Q&#39; \le M\)</span> sunt astfel
Ã®ncÃ¢t <span class="math inline">\(P_k \subseteq Q \subseteq
Q&#39;\)</span>, atunci <span class="math inline">\(N_k \cap Q \ne
0\)</span> ÅŸi <span class="math inline">\(N_k \cap Q&#39; \ne
0\)</span>, iar ireductibilitatea lui <span
class="math inline">\(N_k\)</span> aratÄƒ cÄƒ <span
class="math inline">\(P_k = Q = Q&#39;\)</span>. Deci <span
class="math inline">\(P_k\)</span> este coirreductibil pentru fiecare
<span class="math inline">\(k\)</span>.</p>
<p>Fie <span class="math inline">\(k\in\{1,\dots,m\}\)</span>. Atunci
<span class="math display">\[N = \bigoplus_{k=1}^m N_k = N_k \oplus
N_k&#39;.\]</span> AplicÃ¢nd legea distributivitÄƒÅ£ii modulare, obÅ£inem
<span class="math display">\[N \cap P_k = (N_k \oplus N_k&#39;) \cap P_k
           = N_k + (N_k&#39; \cap P_k),\]</span> deci <span
class="math inline">\(N \cap P_k = N_k\)</span>. RezultÄƒ cÄƒ <span
class="math display">\[N \cap \bigcap_{k=1}^m P_k = \bigcap_{k=1}^m
(N\cap P_k) = \bigcap_{k=1}^m N_k = 0.\]</span></p>
<p>Dar <span class="math inline">\(NVM\)</span>, deci <span
class="math inline">\(\bigcap_{k=1}^m P_k = 0\)</span>.</p>
<p>Cum <span class="math inline">\(N_i = \bigcap_{k\ne i} P_k\)</span>,
avem cÄƒ fiecare intersecÅ£ie este redusÄƒ.</p>
<p>Analog, pentru familia <span class="math inline">\((L_j)\)</span>,
obÅ£inem submodule ireductibile <span
class="math inline">\((Q_j)\)</span> astfel Ã®ncÃ¢t <span
class="math inline">\(\bigcap_{j=1}^n Q_j = 0\)</span>, reducÃ¢nd
intersecÅ£ia.</p>
<p>Din teorema Kurosâ€“Ore, rezultÄƒ <span class="math inline">\(m =
n\)</span>.Â â—»</p>
</div>
<div class="definition">
<p><strong>DefiniÅ£ie 4.13</strong>. Spunem cÄƒ un <span
class="math inline">\(R\)</span>-modul <span
class="math inline">\(M\)</span> are <em>dimensiune coireductibilÄƒ
finitÄƒ</em> dacÄƒ existÄƒ o familie finitÄƒ independentÄƒ <span
class="math inline">\((N_i)_{i=1}^n\)</span> de submodule coireductibile
din <span class="math inline">\(M\)</span> astfel Ã®ncÃ¢t <span
class="math display">\[\bigoplus_{i=1}^n N_i \trianglelefteq M.\]</span>
Ãn acest caz numÄƒrul <span class="math inline">\(n\)</span> se numeÅŸte
<em>dimensiunea coireductibilÄƒ</em> a lui <span
class="math inline">\(M\)</span> ÅŸi scriem <span
class="math inline">\(\dim M = n\)</span>.</p>
</div>
<div class="theorem">
<p><strong>TeoremÄƒ 4.14</strong>. <em>Fie <span
class="math inline">\(M\)</span> un <span
class="math inline">\(R\)</span>-modul. UrmÄƒtoarele afirmaÅ£ii sunt
echivalente:</em></p>
<ol>
<li><p><em><span class="math inline">\(M\)</span> are dimensiune
coireductibilÄƒ finitÄƒ.</em></p></li>
<li><p><em><span class="math inline">\(M\)</span> satisface condiÅ£ia
lanÅ£urilor ascendente pentru sume directe.</em></p></li>
</ol>
</div>
<div class="proof">
<p><em>Proof.</em> <em><span class="math inline">\((2) \Rightarrow
(1)\)</span>.</em> Fie <span
class="math inline">\(\mathcal{S}&#39;\)</span> ÅŸi <span
class="math inline">\(\mathcal{S}\)</span> douÄƒ familii finite de
submodule independente din <span class="math inline">\(M\)</span>.
Spunem cÄƒ <span class="math inline">\(\mathcal{S}&#39;\)</span> este o
<em>rafinare</em> a lui <span class="math inline">\(\mathcal{S}\)</span>
dacÄƒ oricare submodul din <span
class="math inline">\(\mathcal{S}&#39;\)</span> este conÅ£inut Ã®ntr-un
submodul din <span class="math inline">\(\mathcal{S}\)</span>. Se
verificÄƒ uÅŸor cÄƒ relaÅ£ia de rafinare este o relaÅ£ie de ordine pe
mulÅ£imea familiilor de submodule ale lui <span
class="math inline">\(M\)</span>. Cum <span
class="math inline">\(M\)</span> satisface (2), existÄƒ o familie <span
class="math inline">\(\mathcal{S}_0\)</span> de submodule independente
ale lui <span class="math inline">\(M\)</span>, maximalÄƒ Ã®n raport cu
relaÅ£ia de rafinare.</p>
<p>Fie <span class="math inline">\(N \in \mathcal{S}_0\)</span>. DacÄƒ
<span class="math inline">\(N\)</span> nu este coireductibil, existÄƒ
douÄƒ submodule nenule <span class="math inline">\(P,Q \leq N\)</span>
astfel Ã®ncÃ¢t <span class="math inline">\(P \cap Q = 0\)</span>. Este
clar cÄƒ din <span class="math inline">\(\mathcal{S}_0\)</span> se obÅ£ine
o rafinare proprie a lui <span
class="math inline">\(\mathcal{S}_0\)</span>, contradicÅ£ie. RezultÄƒ cÄƒ
orice submodul din <span class="math inline">\(\mathcal{S}_0\)</span>
este coireductibil, deci <span class="math inline">\(M\)</span> conÅ£ine
un submodul coireductibil. DacÄƒ <span class="math inline">\(L\)</span>
este un submodul nenul al lui <span class="math inline">\(M\)</span>,
atunci ÅŸi <span class="math inline">\(L\)</span> satisface condiÅ£ia (2)
ÅŸi, prin acelaÅŸi raÅ£ionament, <span class="math inline">\(L\)</span>
conÅ£ine un submodul coireductibil.</p>
<p>Fie acum <span class="math display">\[S = \bigoplus_{i\in I}
N_i\]</span> o sumÄƒ directÄƒ maximalÄƒ de submodule coireductibile din
<span class="math inline">\(M\)</span> ÅŸi <span
class="math inline">\(N\)</span> un submodul nenul al lui <span
class="math inline">\(M\)</span>. Cum <span
class="math inline">\(M\)</span> satisface condiÅ£ia lanÅ£urilor
ascendente pentru sume directe, rezultÄƒ cÄƒ mulÅ£imea <span
class="math inline">\(I\)</span> este finitÄƒ. Din PropoziÅ£iaÂ 3.8 rezultÄƒ
cÄƒ <span class="math inline">\(S \cap N \neq 0\)</span>, ceea ce aratÄƒ
cÄƒ <span class="math inline">\(S \trianglelefteq M\)</span>. Prin
definiÅ£ie, <span class="math inline">\(M\)</span> are dimensiune
coireductibilÄƒ finitÄƒ.</p>
<p><em><span class="math inline">\((1) \Rightarrow (2)\)</span>.</em>
Fie <span class="math display">\[S = \bigoplus_{i=1}^n N_i\]</span> o
sumÄƒ directÄƒ de submodule coireductibile astfel Ã®ncÃ¢t <span
class="math inline">\(S \trianglelefteq M\)</span>. DacÄƒ <span
class="math inline">\(N\)</span> este un submodul nenul al lui <span
class="math inline">\(M\)</span>, atunci <span class="math inline">\(S
\cap N \neq 0\)</span>, iar din LemaÂ 3.6 rezultÄƒ cÄƒ <span
class="math inline">\(N\)</span> conÅ£ine un submodul coireductibil.</p>
<p>Fie <span class="math inline">\((L_j)_{j=1}^m\)</span> o familie
independentÄƒ de submodule ale lui <span
class="math inline">\(M\)</span>. Din paragraful precedent rezultÄƒ cÄƒ
fiecare <span class="math inline">\(L_j\)</span> conÅ£ine un submodul
coireductibil <span class="math inline">\(P_j\)</span>. Evident, familia
<span class="math inline">\((P_j)_{j=1}^m\)</span> este independentÄƒ.
Din TeoremaÂ 3.12 obÅ£inem cÄƒ <span class="math inline">\(m \leq
n\)</span>. Aceasta aratÄƒ cÄƒ orice familie independentÄƒ de submodule
poate fi extinsÄƒ numai pÃ¢nÄƒ la o familie finitÄƒ, ceea ce este echivalent
cu condiÅ£ia lanÅ£urilor ascendente pentru sume directe.Â â—»</p>
</div>
<div class="remark">
<p><em>ObservaÅ£ie 4.15</em>. Fie <span class="math inline">\(M\)</span>
un <span class="math inline">\(R\)</span>-modul. Atunci:</p>
<ol>
<li><p>DacÄƒ <span class="math inline">\(N \trianglelefteq M\)</span>,
atunci <span class="math inline">\(M\)</span> are dimensiune
coireductibilÄƒ finitÄƒ dacÄƒ ÅŸi numai dacÄƒ <span
class="math inline">\(N\)</span> are dimensiune coireductibilÄƒ finitÄƒ
ÅŸi, Ã®n acest caz, <span class="math inline">\(\dim M = \dim
N\)</span>.</p></li>
<li><p>DacÄƒ <span class="math inline">\(M = \bigoplus_{i=1}^n
N_i\)</span>, atunci <span class="math inline">\(M\)</span> are
dimensiune coireductibilÄƒ finitÄƒ dacÄƒ ÅŸi numai dacÄƒ fiecare <span
class="math inline">\(N_i\)</span> are dimensiune coireductibilÄƒ finitÄƒ
pentru orice <span class="math inline">\(i = 1,\dots,n\)</span>. Ãn plus
avem <span class="math display">\[\dim M = \sum_{i=1}^n \dim N_i
.\]</span></p></li>
</ol>
</div>
<h1 id="domenii-ore-ÅŸi-inele-goldie">Domenii Ore ÅŸi inele Goldie</h1>
<div class="definition">
<p><strong>DefiniÅ£ie 5.1</strong>. Un domeniu de integritate <span
class="math inline">\(D\)</span> se numeÅŸte <em>domeniu Ore la
dreapta</em> (respectiv la stÃ¢nga) dacÄƒ <span class="math inline">\(aD
\cap bD \neq 0\)</span> (respectiv <span class="math inline">\(Da \cap
Db \neq 0\)</span>) oricare ar fi <span class="math inline">\(a,b \in D
\setminus \{0\}\)</span>.</p>
</div>
<div class="proposition">
<p><strong>PropoziÅ£ie 5.2</strong>. <em>Fie <span
class="math inline">\(D\)</span> un domeniu de integritate. Atunci <span
class="math inline">\(D\)</span> este un domeniu Ore la dreapta dacÄƒ ÅŸi
numai dacÄƒ <span class="math inline">\(D\)</span> conÅ£ine un ideal drept
coireductibil. Ãn particular, aceastÄƒ condiÅ£ie este verificatÄƒ cÃ¢nd
<span class="math inline">\(D\)</span> satisface condiÅ£ia lanÅ£urilor
ascendente pentru sume directe de ideale drepte.</em></p>
</div>
<div class="proof">
<p><em>Proof.</em> â€<span class="math inline">\(\Rightarrow\)</span>â€
DacÄƒ <span class="math inline">\(D\)</span> este un domeniu Ore la
dreapta atunci <span class="math inline">\(D_D\)</span> este
coireductibil.</p>
<p>â€<span class="math inline">\(\Leftarrow\)</span>â€ Fie <span
class="math inline">\(X\)</span> un ideal drept coireductibil al lui
<span class="math inline">\(D\)</span> ÅŸi <span class="math inline">\(x
\in X \setminus \{0\}\)</span>. AplicaÅ£ia <span
class="math display">\[\varphi_x : D_D \longrightarrow X, \qquad
\varphi_x(a) = xa\]</span> este un morfism injectiv de <span
class="math inline">\(D\)</span>-module drepte. Atunci <span
class="math inline">\(D_D\)</span> este coireductibil ÅŸi deci <span
class="math inline">\(D\)</span> este domeniu Ore la dreapta.Â â—»</p>
</div>
<div class="example">
<p><strong>Exemplu 5.3</strong>. Fie <span
class="math inline">\(K\)</span> un corp comutativ ÅŸi <span
class="math inline">\(y\)</span> o nedeterminatÄƒ. ConsiderÄƒm <span
class="math inline">\(K(y)\)</span> corpul de fracÅ£ii al inelului de
polinoame <span class="math inline">\(K[y]\)</span>. DacÄƒ <span
class="math inline">\(x\)</span> este o altÄƒ nedeterminatÄƒ, considerÄƒm
<span class="math inline">\(K(y)[x]\)</span> mulÅ£imea polinoamelor cu
coeficienÅ£i Ã®n <span class="math inline">\(K(y)\)</span> ÅŸi Ã®n
nedeterminata <span class="math inline">\(x\)</span>. Pe aceastÄƒ mulÅ£ime
definim douÄƒ operaÅ£ii: operaÅ£ia de adunare fiind adunarea obiÅŸnuitÄƒ a
polinoamelor, iar operaÅ£ia de Ã®nmulÅ£ire Ã®n <span
class="math inline">\(K(y)[x]\)</span> o definim prin relaÅ£ia de
comutare <span class="math display">\[x f(y) = f(y^{2})x, \qquad f \in
K(y).\]</span> Se verificÄƒ imediat cÄƒ mulÅ£imea <span
class="math inline">\(K(y)[x]\)</span>, cu cele douÄƒ operaÅ£ii, este un
inel unitar. NotÄƒm <span class="math inline">\(A = K(y)[x]\)</span>.
<span class="math inline">\(A\)</span> este un domeniu de integritate
necomutativ.</p>
<p>Orice element din <span class="math inline">\(A\)</span> poate fi pus
sub formÄƒ unicÄƒ: <span class="math display">\[P(x) = f_{n}(y)x^{n} +
f_{n-1}(y)x^{n-1} + \dots + f_{1}(y)x + f_{0}(y),\]</span> unde <span
class="math inline">\(n\)</span> este un numÄƒr natural ÅŸi <span
class="math inline">\(f_{0}(y), f_{1}(y), \dots, f_{n}(y) \in
K(y)\)</span>, <span class="math inline">\(f_{n}(y) \neq 0\)</span>. Vom
nota <span class="math inline">\(\deg P(x) = n\)</span>.</p>
<p>ObservÄƒm cÄƒ, dacÄƒ <span class="math inline">\(P(x), Q(x) \in
A\)</span> cu <span class="math inline">\(Q(x) \neq 0\)</span>, existÄƒ
douÄƒ elemente <span class="math inline">\(S(x), R(x) \in A\)</span>
astfel Ã®ncÃ¢t <span class="math display">\[P(x) = S(x)Q(x) + R(x)
\tag{\(*\)}\]</span> cu <span class="math inline">\(R(x) = 0\)</span>
sau <span class="math inline">\(\deg R(x) &lt; \deg Q(x)\)</span>. Din
relaÅ£iile <span class="math inline">\((*)\)</span> rezultÄƒ cÄƒ <span
class="math inline">\(A\)</span> este inel principal la stÃ¢nga. RezultÄƒ
cÄƒ <span class="math inline">\(A\)</span> satisface condiÅ£ia lanÅ£urilor
ascendente pentru sume directe de ideale la stÃ¢nga ÅŸi deci <span
class="math inline">\(A\)</span> este domeniu Ore la stÃ¢nga.</p>
<p>SÄƒ arÄƒtÄƒm egalitatea <span class="math inline">\(xA \cap yA =
0\)</span>. Fie <span class="math inline">\(\alpha \in xA \cap
yA\)</span>. Atunci <span class="math display">\[\alpha =
x\bigl(f_{n}(y)x^{n} + \dots + f_{0}(y)\bigr)
       = yx\bigl(g_{m}(y)x^{m} + \dots + g_{0}(y)\bigr),\]</span> de
unde <span class="math display">\[f_{n}(y^{2})x^{n+1} + \dots +
f_{0}(y^{2})x
= y\bigl(g_{m}(y^{2})x^{m+1} + \dots + g_{0}(y^{2})x\bigr)\]</span> ÅŸi
deci <span class="math inline">\(m = n\)</span>. RezultÄƒ <span
class="math display">\[f_{n}(y^{2}) = y g_{m}(y^{2}), \dots,
f_{0}(y^{2}) = y g_{0}(y^{2}),\]</span> ceea ce are loc dacÄƒ ÅŸi numai
dacÄƒ <span class="math inline">\(f_{n}(y) = \dots = f_{1}(y) = f_{0}(y)
= 0\)</span> ÅŸi deci <span class="math inline">\(\alpha = 0\)</span>.
RezultÄƒ cÄƒ <span class="math inline">\(A\)</span> nu este domeniu Ore la
dreapta.</p>
</div>
<div class="center">
<p><strong>INELE GOLDIE</strong></p>
</div>
<div class="definition">
<p><strong>DefiniÅ£ie 5.4</strong>. Un ideal drept (respectiv stÃ¢ng)
<span class="math inline">\(I\)</span> se numeÅŸte <em>ideal anulator la
dreapta</em> (respectiv la stÃ¢nga) dacÄƒ existÄƒ o submulÅ£ime nevidÄƒ <span
class="math inline">\(X\)</span> a lui <span
class="math inline">\(R\)</span> astfel Ã®ncÃ¢t <span
class="math inline">\(I = \operatorname{ann}_{r}(X)\)</span> (respectiv
<span class="math inline">\(I = \operatorname{ann}_{l}(X)\)</span>).</p>
<p>Un inel <span class="math inline">\(R\)</span> se numeÅŸte <em>inel
Goldie la dreapta</em> dacÄƒ <span class="math inline">\(R\)</span>
satisface condiÅ£ia lanÅ£urilor ascendente pentru ideale anulatori la
dreapta ÅŸi nu existÄƒ Ã®n <span class="math inline">\(R\)</span> o sumÄƒ
directÄƒ infinitÄƒ de ideale drepte nenule.</p>
</div>
<div class="example">
<p><strong>Exemplu 5.5</strong>. </p>
<ol>
<li><p>DacÄƒ <span class="math inline">\(R\)</span> este inel noetherian
la dreapta, atunci <span class="math inline">\(R\)</span> este inel
Goldie la dreapta. Ãn particular, <span
class="math inline">\(\mathbb{Z}\)</span> este inel Goldie.</p></li>
<li><p>DacÄƒ <span class="math inline">\(R\)</span> este un domeniu de
integritate, atunci <span class="math inline">\(R\)</span> este inel
Goldie la dreapta dacÄƒ ÅŸi numai dacÄƒ <span
class="math inline">\(R\)</span> este domeniu Ore la dreapta.</p></li>
<li><p>Din exemplulÂ 4.3 rezultÄƒ cÄƒ existÄƒ inele Goldie la stÃ¢nga care nu
sunt Goldie la dreapta.</p></li>
</ol>
</div>
<div class="proposition">
<p><strong>PropoziÅ£ie 5.6</strong>. <em>Fie <span
class="math inline">\(R\)</span> un inel. Atunci <span
class="math inline">\(R\)</span> verificÄƒ condiÅ£ia lanÅ£urilor ascendente
pentru ideale anulatori la dreapta (respectiv la stÃ¢nga) dacÄƒ ÅŸi numai
dacÄƒ <span class="math inline">\(R\)</span> verificÄƒ condiÅ£ia lanÅ£urilor
descendente pentru ideale anulatori la stÃ¢nga (respectiv la
dreapta).</em></p>
</div>
<div class="proof">
<p><em>Proof.</em> â€œ<span class="math inline">\(\Rightarrow\)</span>â€
Fie <span class="math inline">\(I_1 \supseteq I_2 \supseteq \dots
\supseteq I_n \supseteq \dots\)</span> un ÅŸir descendent de ideale
anulatori la stÃ¢nga. Pentru orice <span class="math inline">\(j \geq
1\)</span> existÄƒ o mulÅ£ime nevidÄƒ <span class="math inline">\(X_j
\subseteq R\)</span> astfel Ã®ncÃ¢t <span class="math inline">\(I_j =
\operatorname{ann}_\ell(X_j)\)</span>.</p>
<p>Atunci obÅ£inem ÅŸirul ascendent de ideale anulatori la dreapta <span
class="math display">\[\operatorname{ann}_r(I_1) \subseteq
\operatorname{ann}_r(I_2) \subseteq
  \dots \subseteq \operatorname{ann}_r(I_n) \subseteq \dots\]</span> ÅŸi
deci existÄƒ <span class="math inline">\(m \geq 1\)</span> astfel Ã®ncÃ¢t
<span class="math inline">\(\operatorname{ann}_r(I_m) =
\operatorname{ann}_r(I_{m+k})\)</span> pentru orice <span
class="math inline">\(k \geq 1\)</span>. RezultÄƒ cÄƒ <span
class="math display">\[\operatorname{ann}_\ell(\operatorname{ann}_r(I_m))
  = \operatorname{ann}_\ell(\operatorname{ann}_r(I_{m+k}))
  \quad \text{pentru orice } k \geq 1,\]</span> adicÄƒ <span
class="math inline">\(I_m = I_{m+k}\)</span> pentru orice <span
class="math inline">\(k \geq 1\)</span>.</p>
<p>Folosind relaÅ£iile <span
class="math inline">\(\operatorname{ann}_\ell(\operatorname{ann}_r(\operatorname{ann}_\ell(X)))
= \operatorname{ann}_\ell(X)\)</span> ÅŸi <span
class="math inline">\(\operatorname{ann}_r(Y) \subseteq
\operatorname{ann}_r(X)\)</span> dacÄƒ <span class="math inline">\(X
\subseteq Y\)</span>, implicaÅ£ia â€œ<span
class="math inline">\(\Leftarrow\)</span>â€ se demonstreazÄƒ analog.Â â—»</p>
</div>
<div class="proposition">
<p><strong>PropoziÅ£ie 5.7</strong>. <em>Fie <span
class="math inline">\(R\)</span> un inel semiprim care satisface
condiÅ£ia lanÅ£urilor ascendente pentru ideale anulatori la dreapta. DacÄƒ
<span class="math inline">\(I\)</span> ÅŸi <span
class="math inline">\(J\)</span> sunt ideale drepte astfel Ã®ncÃ¢t <span
class="math inline">\(I \subseteq J\)</span>, atunci existÄƒ un element
<span class="math inline">\(b \in R\)</span> astfel Ã®ncÃ¢t <span
class="math inline">\(bJ \neq 0\)</span> ÅŸi <span
class="math inline">\(bJ \cap I = 0\)</span>.</em></p>
</div>
<div class="proof">
<p><em>Proof.</em> Din lema precedentÄƒ existÄƒ un element minimal <span
class="math inline">\(a\)</span> Ã®n mulÅ£imea idealelor anulatori la
stÃ¢nga astfel Ã®ncÃ¢t <span
class="math inline">\(\operatorname{ann}_\ell(J) \subseteq
\operatorname{ann}_\ell(I)\)</span>. Atunci <span
class="math inline">\(aJ \neq 0\)</span>, iar cum <span
class="math inline">\(R\)</span> este inel semiprim, obÅ£inem <span
class="math inline">\(aJ \cdot aJ \neq 0\)</span> ÅŸi deci existÄƒ <span
class="math inline">\(b = x a\)</span> cu <span class="math inline">\(x
\in J\)</span>, <span class="math inline">\(a \in aJ\)</span> astfel
Ã®ncÃ¢t <span class="math inline">\(x a J \neq 0\)</span>. Evident, <span
class="math inline">\(bJ \neq 0\)</span>.</p>
<p>RÄƒmÃ¢ne sÄƒ arÄƒtÄƒm cÄƒ <span class="math inline">\(bJ \cap I =
0\)</span>. Fie <span class="math inline">\(\lambda \in bJ \cap
I\)</span>, deci <span class="math inline">\(\lambda = b\mu = x a \mu
\in I\)</span> pentru un <span class="math inline">\(\mu \in J\)</span>.
Cum <span class="math inline">\(\operatorname{ann}_\ell(J) \subseteq
\operatorname{ann}_\ell(\lambda)\)</span>, obÅ£inem <span
class="math display">\[\operatorname{ann}_\ell(J) \subseteq
\operatorname{ann}_\ell(\lambda)
  \subseteq \operatorname{ann}_\ell(\mu).\]</span> Deoarece <span
class="math inline">\(a \in aJ \subseteq aR\)</span>, avem <span
class="math display">\[\begin{equation}
\label{eq:4.7-1}
  x a \in a \quad \text{ÅŸi deci} \quad x a J \subseteq aJ .
\end{equation}\]</span></p>
<p>Pe de altÄƒ parte, <span class="math inline">\(x a J \subseteq
I\)</span>, iar <span class="math inline">\(\lambda \in I\)</span> ÅŸi
<span class="math inline">\(a \subseteq
\operatorname{ann}_r(I)\)</span>, astfel Ã®ncÃ¢t <span
class="math display">\[\begin{equation}
\label{eq:4.7-2}
  a \subseteq \operatorname{ann}_\ell(\mu).
\end{equation}\]</span> Dar cum <span class="math inline">\(x a J \neq
0\)</span>, avem <span class="math display">\[\begin{equation}
\label{eq:4.7-3}
  a \nsubseteq \operatorname{ann}_\ell(J).
\end{equation}\]</span></p>
<p>Din <a href="#eq:4.7-1" data-reference-type="eqref"
data-reference="eq:4.7-1">[eq:4.7-1]</a>, <a href="#eq:4.7-2"
data-reference-type="eqref" data-reference="eq:4.7-2">[eq:4.7-2]</a> ÅŸi
<a href="#eq:4.7-3" data-reference-type="eqref"
data-reference="eq:4.7-3">[eq:4.7-3]</a> obÅ£inem cÄƒ <span
class="math inline">\(\operatorname{ann}_\ell(J) \subseteq
\operatorname{ann}_\ell(\mu) \cap a\)</span>. DacÄƒ <span
class="math inline">\(\lambda \neq 0\)</span>, atunci <span
class="math inline">\(x a \mu \notin
\operatorname{ann}_\ell(\mu)\)</span> ÅŸi, cum <span
class="math inline">\(x a \in a\)</span>, rezultÄƒ cÄƒ <span
class="math inline">\(x a \mu \neq 0\)</span>, ceea ce contrazice
alegerea lui <span class="math inline">\(a\)</span>. Deci <span
class="math inline">\(\lambda = 0\)</span>, ÅŸi atunci <span
class="math inline">\(bJ \cap I = 0\)</span>.Â â—»</p>
</div>
<div class="corollary">
<p><strong>Corolar 5.8</strong>. <em>DacÄƒ <span
class="math inline">\(R\)</span> este un inel Goldie la dreapta
semiprim, atunci <span class="math inline">\(R\)</span> satisface
condiÅ£ia lanÅ£urilor descendente pentru ideale anulatori la
dreapta.</em></p>
</div>
<div class="proof">
<p><em>Proof.</em> Presupunem cÄƒ existÄƒ un ÅŸir strict descrescÄƒtor de
ideale anulatori la dreapta <span class="math display">\[I_1 \supset I_2
\supset \dots \supset I_n \supset \dots .\]</span> Atunci pentru orice
<span class="math inline">\(n \geq 1\)</span> avem <span
class="math inline">\(\operatorname{ann}_\ell(I_n) \neq
\operatorname{ann}_\ell(I_{n+1})\)</span>. Din PropoziÅ£iaÂ 4.7 rezultÄƒ cÄƒ
pentru orice <span class="math inline">\(n \geq 1\)</span> existÄƒ un
ideal drept <span class="math inline">\(K_n\)</span> astfel Ã®ncÃ¢t <span
class="math inline">\(K_n \subseteq I_n\)</span> ÅŸi <span
class="math inline">\(K_n \cap I_{n+1} \neq 0\)</span>. Atunci suma
directÄƒ <span class="math inline">\(\sum_{n \geq 1} K_n\)</span> este o
sumÄƒ directÄƒ infinitÄƒ de ideale drepte nenule, Ã®n contradicÅ£ie cu faptul
cÄƒ <span class="math inline">\(R\)</span> este Goldie la dreapta.Â â—»</p>
</div>
<div class="proposition">
<p><strong>PropoziÅ£ie 5.9</strong>. <em>Fie <span
class="math inline">\(R\)</span> un inel semiprim care satisface
condiÅ£ia lanÅ£urilor ascendente pentru ideale anulatori la dreapta. DacÄƒ
<span class="math inline">\(x, y \in R\)</span> sunt astfel Ã®ncÃ¢t <span
class="math inline">\(xR\)</span> ÅŸi <span
class="math inline">\(yR\)</span> sunt esenÅ£iale Ã®n <span
class="math inline">\(R_R\)</span>, atunci <span
class="math inline">\(xyR\)</span> este esenÅ£ial.</em></p>
</div>
<div class="proof">
<p><em>Proof.</em> Fie <span class="math inline">\(I \leq R_R\)</span>
cu <span class="math inline">\(I \neq 0\)</span>. NotÄƒm <span
class="math display">\[J = \{ I : x \} = \{ a \in R \mid xa \in I
\}.\]</span> Atunci <span class="math inline">\(J\)</span> este un ideal
drept al lui <span class="math inline">\(R\)</span>, iar <span
class="math inline">\(xJ = xR \cap I \neq 0\)</span> deoarece <span
class="math inline">\(xR \unlhd R_R\)</span>. Cum <span
class="math inline">\(\operatorname{ann}_r(x) \subseteq J\)</span> ÅŸi
<span class="math inline">\(xJ \neq 0\)</span> iar <span
class="math inline">\(\operatorname{ann}_\ell(x) = 0\)</span>, obÅ£inem
<span class="math display">\[\operatorname{ann}_\ell(J) \subseteq
\operatorname{ann}_\ell(\operatorname{ann}_r(x)).\]</span> Din
PropoziÅ£iaÂ 4.7 rezultÄƒ cÄƒ existÄƒ un ideal drept <span
class="math inline">\(K \neq 0\)</span> astfel Ã®ncÃ¢t <span
class="math inline">\(K \subseteq J\)</span> ÅŸi <span
class="math inline">\(K \cap \operatorname{ann}_r(x) = 0\)</span>.</p>
<p>NotÄƒm apoi <span class="math display">\[L = \{ K : y \} = \{ a \in R
\mid ya \in K \}.\]</span> Deoarece <span class="math inline">\(yR
\unlhd R_R\)</span>, avem <span class="math inline">\(yL = yR \cap K
\neq 0\)</span>. DacÄƒ <span class="math inline">\(xyL = 0\)</span>,
atunci <span class="math inline">\(yL \subseteq
\operatorname{ann}_r(x)\)</span> ÅŸi deci <span class="math inline">\(yL
\subseteq \operatorname{ann}_r(x) \cap K = 0\)</span>, contradicÅ£ie.
Prin urmare <span class="math inline">\(xyL \neq 0\)</span>.</p>
<p>Cum <span class="math inline">\(xyL \subseteq xK \subseteq xJ
\subseteq xR \cap I\)</span>, rezultÄƒ cÄƒ <span class="math inline">\(0
\neq xyL \subseteq xyR \cap I\)</span>, ceea ce aratÄƒ cÄƒ <span
class="math inline">\(xyR \unlhd R_R\)</span>.Â â—»</p>
</div>
<div class="proposition">
<p><strong>PropoziÅ£ie 5.10</strong>. <em>Fie <span
class="math inline">\(R\)</span> un inel care verificÄƒ condiÅ£ia
lanÅ£urilor ascendente pentru ideale anulatori drepte. Atunci, pentru
orice <span class="math inline">\(a \in R\)</span> existÄƒ un numÄƒr <span
class="math inline">\(k \geq 0\)</span> astfel Ã®ncÃ¢t <span
class="math display">\[\operatorname{ann}_r(a^n) =
\operatorname{ann}_r(a^m)
  \quad \text{pentru orice } n \geq 0 \text{ ÅŸi } m \geq k
.\]</span></em></p>
</div>
<div class="proof">
<p><em>Proof.</em> Avem lanÅ£ul ascendent de ideale anulatori la dreapta:
<span class="math display">\[\mathop{\mathrm{ann}}_r(a) \subseteq
\mathop{\mathrm{ann}}_r(a^2) \subseteq \cdots \subseteq
\mathop{\mathrm{ann}}_r(a^n)
  \subseteq \cdots .\]</span> Fie <span class="math inline">\(k \geq
0\)</span> astfel Ã®ncÃ¢t <span
class="math inline">\(\mathop{\mathrm{ann}}_r(a^k) =
\mathop{\mathrm{ann}}_r(a^m)\)</span> pentru orice <span
class="math inline">\(m \geq k\)</span>. DacÄƒ <span
class="math inline">\(\lambda \in \mathop{\mathrm{ann}}_r(a^n) \cap
a^mR\)</span>, atunci <span class="math inline">\(a^n \lambda =
0\)</span> ÅŸi <span class="math inline">\(\lambda = a^m\mu\)</span>, de
unde <span class="math inline">\(a^{m+n}\mu = 0\)</span>. Cum <span
class="math inline">\(m+n \geq k\)</span>, obÅ£inem cÄƒ <span
class="math inline">\(\mu \in \mathop{\mathrm{ann}}_r(a^k)\)</span> ÅŸi
deci <span class="math inline">\(a^k\mu = 0\)</span>. Cum <span
class="math inline">\(m \geq k\)</span>, putem scrie <span
class="math inline">\(\lambda = a^{m-k}a^k\mu = 0\)</span> ÅŸi deci <span
class="math display">\[\mathop{\mathrm{ann}}_r(a^n) \cap a^mR = 0
.\]</span>Â â—»</p>
</div>
<div class="corollary">
<p><strong>Corolar 5.11</strong>. <em>Suntem Ã®n condiÅ£iile
propoziÅ£ieiÂ 4.10. DacÄƒ <span class="math inline">\(xR \trianglelefteq
R_R\)</span>, atunci <span class="math inline">\(x\)</span> este element
regulat Ã®n <span class="math inline">\(R\)</span>.</em></p>
</div>
<div class="proof">
<p><em>Proof.</em> DacÄƒ <span
class="math inline">\(\mathop{\mathrm{ann}}_r(x) \neq 0\)</span>, atunci
<span class="math inline">\(0 = \mathop{\mathrm{ann}}_r(R) \neq
\mathop{\mathrm{ann}}_r(xR)\)</span> ÅŸi deci existÄƒ un ideal drept <span
class="math inline">\(I \neq 0\)</span> astfel Ã®ncÃ¢t <span
class="math inline">\(I \cap xR = 0\)</span>, contradicÅ£ie. Deci <span
class="math inline">\(\mathop{\mathrm{ann}}_r(x) = 0\)</span>.</p>
<p>Din PropoziÅ£iaÂ 4.9 rezultÄƒ cÄƒ <span class="math inline">\(x^nR
\trianglelefteq R_R\)</span> pentru orice <span class="math inline">\(n
\geq 1\)</span>. AplicÃ¢nd PropoziÅ£iaÂ 4.10, gÄƒsim <span
class="math inline">\(k \geq 0\)</span> astfel Ã®ncÃ¢t <span
class="math inline">\(\mathop{\mathrm{ann}}_r(x^n) \cap x^mR =
0\)</span> pentru orice <span class="math inline">\(m \geq k\)</span>.
Ãn special <span class="math inline">\(\mathop{\mathrm{ann}}_r(x) =
0\)</span>, deci <span class="math inline">\(x\)</span> este element
regulat Ã®n <span class="math inline">\(R\)</span>.Â â—»</p>
</div>
<div class="corollary">
<p><strong>Corolar 5.12</strong>. <em>Fie <span
class="math inline">\(R\)</span> un inel Goldie la dreapta ÅŸi semiprime.
DacÄƒ <span class="math inline">\(\mathop{\mathrm{ann}}_r(x) =
0\)</span>, unde <span class="math inline">\(x \in R\)</span>, atunci
<span class="math inline">\(xR \trianglelefteq R_R\)</span> ÅŸi <span
class="math inline">\(x\)</span> este regulat.</em></p>
</div>
<div class="proof">
<p><em>Proof.</em> Fie <span class="math inline">\(I\)</span> un ideal
drept nenul al lui <span class="math inline">\(R\)</span>. Presupunem cÄƒ
<span class="math inline">\(I \cap xR = 0\)</span>. Atunci suma <span
class="math display">\[\sum_{n \geq 1} x^n I\]</span> este directÄƒ.
Ãntr-adevÄƒr, <span class="math inline">\(x^p I \cap \sum_{n \neq p} x^n
I\)</span> este egalÄƒ cu <span class="math inline">\(xI \cap x^p
I\)</span>, dacÄƒ <span class="math inline">\(p = 1\)</span>. DacÄƒ <span
class="math inline">\(y \in xI \cap x^p I\)</span>, atunci <span
class="math inline">\(y = x\lambda = x^2\mu\)</span>, unde <span
class="math inline">\(\lambda,\mu \in I\)</span>. Dar atunci <span
class="math inline">\(\lambda - x\mu \in
\mathop{\mathrm{ann}}_r(x)\)</span> ÅŸi deci <span
class="math inline">\(\lambda = x\mu\)</span>, de unde obÅ£inem cÄƒ <span
class="math inline">\(\lambda \in I \cap xR = 0\)</span>. RezultÄƒ cÄƒ
<span class="math inline">\(\lambda = 0\)</span> ÅŸi atunci <span
class="math inline">\(y = 0\)</span>. AÅŸadar <span
class="math inline">\(xI \cap x^2 I = 0\)</span> ÅŸi cu atÃ¢t mai mult
<span class="math inline">\(xI \cap x^p I = 0\)</span> dacÄƒ <span
class="math inline">\(p \neq 1\)</span>. Deci <span
class="math inline">\(x^p I \cap \sum_{n \neq p} x^n I = 0\)</span> ÅŸi
prin urmare suma <span class="math inline">\(\sum_{n \geq 1} x^n
I\)</span> este directÄƒ, contradicÅ£ie.</p>
<p>RezultÄƒ cÄƒ <span class="math inline">\(xR \trianglelefteq
R_R\)</span>. Din CorolarulÂ 4.11 deducem cÄƒ <span
class="math inline">\(x\)</span> este element regulat Ã®n <span
class="math inline">\(R\)</span>.Â â—»</p>
</div>
<div class="proposition">
<p><strong>PropoziÅ£ie 5.13</strong>. <em>Fie <span
class="math inline">\(R\)</span> un inel Goldie la dreapta ÅŸi semiprime.
Atunci:</em></p>
<ol>
<li><p><em>Orice ideal bilateral al lui <span
class="math inline">\(R\)</span> anulator la dreapta conÅ£ine un ideal
bilateral anulator la dreapta minimal.</em></p></li>
<li><p><em>ExistÄƒ o sumÄƒ directÄƒ finitÄƒ de ideale bilaterale nenule
anulatori la dreapta minimale ale lui <span
class="math inline">\(R\)</span>, care este esenÅ£ialÄƒ Ã®n <span
class="math inline">\(R\)</span>.</em></p></li>
</ol>
</div>
<div class="proof">
<p><em>Proof.</em> (a) RezultÄƒ din CorolarulÂ 4.8.</p>
<p>(b) Fie <span class="math inline">\(I = I_1 \oplus I_2 \oplus \cdots
\oplus I_n\)</span> o sumÄƒ directÄƒ maximalÄƒ, unde <span
class="math inline">\(I_1,\dots,I_n\)</span> sunt ideale nenule
bilaterale anulatori la dreapta minimale ale lui <span
class="math inline">\(R\)</span>. Fie <span class="math inline">\(K \leq
R_R\)</span>, <span class="math inline">\(K \neq 0\)</span> astfel Ã®ncÃ¢t
<span class="math inline">\(I \cap K = 0\)</span>. Cum <span
class="math inline">\(KI \subseteq I \cap K = 0\)</span>, rezultÄƒ cÄƒ
<span class="math inline">\(K \subseteq
\mathop{\mathrm{ann}}_r(I)\)</span>. Cum <span
class="math inline">\(R\)</span> este semiprime, avem <span
class="math inline">\(I \cap \mathop{\mathrm{ann}}_r(I) = 0\)</span>, de
unde <span class="math inline">\(I\mathop{\mathrm{ann}}_r(I) =
0\)</span>, deci <span class="math inline">\(\mathop{\mathrm{ann}}_l(I)
\subseteq \mathop{\mathrm{ann}}_r(I)\)</span> ÅŸi Ã®n special <span
class="math inline">\(\mathop{\mathrm{ann}}_r(I) \neq 0\)</span>. Cum
<span class="math inline">\(R\)</span> este semiprim, rezultÄƒ ÅŸi cÄƒ
<span class="math inline">\(I \cap \mathop{\mathrm{ann}}_l(I) =
0\)</span>, unde <span
class="math inline">\(\mathop{\mathrm{ann}}_l(I)\)</span> este un ideal
bilateral. Din (a) existÄƒ un ideal bilateral nenul <span
class="math inline">\(J\)</span> anulator la dreapta ÅŸi minimal astfel
Ã®ncÃ¢t <span class="math inline">\(J \subseteq
\mathop{\mathrm{ann}}_r(I)\)</span> ÅŸi <span class="math inline">\(J
\cap I = 0\)</span>, ceea ce contrazice alegerea lui <span
class="math inline">\(I\)</span> ca sumÄƒ directÄƒ maximalÄƒ. Prin urmare
<span class="math inline">\(I \trianglelefteq R\)</span>.Â â—»</p>
</div>
<div class="proposition">
<p><strong>PropoziÅ£ie 5.14</strong>. <em>Fie <span
class="math inline">\(R\)</span> un inel Goldie la dreapta ÅŸi prim. DacÄƒ
<span class="math inline">\(I\)</span> este un ideal drept esenÅ£ial Ã®n
<span class="math inline">\(R\)</span>, atunci <span
class="math inline">\(I\)</span> conÅ£ine un element regulat al lui <span
class="math inline">\(R\)</span>.</em></p>
</div>
<div class="proof">
<p><em>Proof.</em> Fie <span class="math inline">\(a \in I\)</span>
astfel Ã®ncÃ¢t <span
class="math inline">\(\mathop{\mathrm{ann}}_r(a)\)</span> este minimal
Ã®n mulÅ£imea <span class="math inline">\(\{\mathop{\mathrm{ann}}_r(x)
\mid x \in I\}\)</span>. Fie <span class="math inline">\(J \leq
R_R\)</span>, <span class="math inline">\(J \neq 0\)</span> pentru care
<span class="math inline">\(aR \cap J = 0\)</span>. Cum <span
class="math inline">\(I \trianglelefteq R_R\)</span>, avem <span
class="math inline">\(I \cap J \neq 0\)</span>; putem presupune cÄƒ <span
class="math inline">\(J\)</span> este un ideal drept nenul al lui <span
class="math inline">\(R\)</span> inclus Ã®n <span
class="math inline">\(I\)</span> ÅŸi pentru care <span
class="math inline">\(aR \cap J = 0\)</span>.</p>
<p>Fie <span class="math inline">\(x \in J\)</span>. DacÄƒ <span
class="math inline">\(\lambda \in \mathop{\mathrm{ann}}_r(a+x)\)</span>,
atunci <span class="math inline">\(a\lambda + x\lambda = 0\)</span> ÅŸi
deci <span class="math inline">\(x\lambda = -a\lambda \in aR \cap
J\)</span>, de unde <span class="math inline">\(x\lambda = 0\)</span> ÅŸi
apoi <span class="math inline">\(a\lambda = 0\)</span>. AÅŸadar <span
class="math inline">\(\lambda \in \mathop{\mathrm{ann}}_r(a) \cap
\mathop{\mathrm{ann}}_r(x)\)</span>. Cum incluziunea <span
class="math display">\[\mathop{\mathrm{ann}}_r(a) \cap
\mathop{\mathrm{ann}}_r(x) \subseteq
\mathop{\mathrm{ann}}_r(a+x)\]</span> este evidentÄƒ, obÅ£inem <span
class="math inline">\(\mathop{\mathrm{ann}}_r(a+x) =
\mathop{\mathrm{ann}}_r(a) \cap \mathop{\mathrm{ann}}_r(x)\)</span>. Cum
<span class="math inline">\(\mathop{\mathrm{ann}}_r(a)\)</span> este
minimal, rezultÄƒ cÄƒ <span
class="math inline">\(\mathop{\mathrm{ann}}_r(a) \subseteq
\mathop{\mathrm{ann}}_r(x)\)</span> ÅŸi deci <span
class="math inline">\(x\,\mathop{\mathrm{ann}}_r(a) = 0\)</span>, de
unde <span class="math inline">\(J \mathop{\mathrm{ann}}_r(a) =
0\)</span>. Cum <span class="math inline">\(R\)</span> este prim, avem
<span class="math inline">\(\mathop{\mathrm{ann}}_r(a) = 0\)</span>.</p>
<p>Din CorolarulÂ 4.12 rezultÄƒ cÄƒ <span class="math inline">\(J =
0\)</span>, contradicÅ£ie. Deci trebuie ca <span class="math inline">\(aR
\trianglelefteq R_R\)</span>, iar din CorolarulÂ 4.11 obÅ£inem cÄƒ <span
class="math inline">\(a\)</span> este regulat Ã®n <span
class="math inline">\(R\)</span>.Â â—»</p>
</div>
<h1 id="teorema-osofskysmith">Teorema Osofskyâ€“Smith</h1>
<div class="definition">
<p><strong>DefiniÅ£ie 6.1</strong>. Un <span
class="math inline">\(R\)</span>-modul <span
class="math inline">\(M\)</span> se numeÅŸte <em>CS-modul</em> dacÄƒ orice
submodul complement al lui <span class="math inline">\(M\)</span> este
sumand direct Ã®n <span class="math inline">\(M\)</span>. Modulul <span
class="math inline">\(M\)</span> se numeÅŸte <em>complet CS</em> dacÄƒ
<span class="math inline">\(M/N\)</span> este CS-modul, pentru orice
<span class="math inline">\(N \leq M\)</span>.</p>
</div>
<div class="remark">
<p><em>ObservaÅ£ie 6.2</em>. Din 2.2.2 rezultÄƒ cÄƒ orice modul injectiv
este CS-modul.</p>
</div>
<div class="proposition">
<p><strong>PropoziÅ£ie 6.3</strong>. <em>Pentru un <span
class="math inline">\(R\)</span>-modul <span
class="math inline">\(M\)</span> urmÄƒtoarele afirmaÅ£ii sunt
echivalente:</em></p>
<ol>
<li><p><em><span class="math inline">\(M\)</span> este
CS-modul.</em></p></li>
<li><p><em>Orice extensie esenÅ£ialÄƒ maximalÄƒ a unui submodul al lui
<span class="math inline">\(M\)</span> este sumand direct Ã®n <span
class="math inline">\(M\)</span>.</em></p></li>
<li><p><em>Orice submodul al lui <span class="math inline">\(M\)</span>
este esenÅ£ial Ã®ntr-un sumand direct al lui <span
class="math inline">\(M\)</span>.</em></p></li>
</ol>
</div>
<div class="proof">
<p><em>Proof.</em> <span class="math inline">\((1) \Rightarrow
(2)\)</span> Fie <span class="math inline">\(N\)</span> un submodul al
lui <span class="math inline">\(M\)</span> ÅŸi <span
class="math inline">\(Q\)</span> o extensie esenÅ£ialÄƒ maximalÄƒ a lui
<span class="math inline">\(N\)</span> Ã®n <span
class="math inline">\(M\)</span> (propoziÅ£iaÂ 1.13). Atunci <span
class="math inline">\(Q\)</span> este submodul Ã®nchis ÅŸi din 1.15
rezultÄƒ cÄƒ <span class="math inline">\(Q\)</span> este sumand direct Ã®n
<span class="math inline">\(M\)</span>.</p>
<p><span class="math inline">\((2) \Rightarrow (3)\)</span> este
evidentÄƒ din propoziÅ£iaÂ 1.13.</p>
<p><span class="math inline">\((3) \Rightarrow (1)\)</span> Fie <span
class="math inline">\(K\)</span> un submodul complement al lui <span
class="math inline">\(M\)</span>. ExistÄƒ un sumand direct <span
class="math inline">\(Q\)</span> Ã®n <span
class="math inline">\(M\)</span> astfel Ã®ncÃ¢t <span
class="math inline">\(K \trianglelefteq Q\)</span>. Cum <span
class="math inline">\(K\)</span> este submodul Ã®nchis, rezultÄƒ <span
class="math inline">\(K = Q\)</span> ÅŸi deci <span
class="math inline">\(K\)</span> este sumand direct Ã®n <span
class="math inline">\(M\)</span>.Â â—»</p>
</div>
<div class="proposition">
<p><strong>PropoziÅ£ie 6.4</strong>. <em>Orice modul quasi-injectiv este
CS-modul.</em></p>
</div>
<div class="proof">
<p><em>Proof.</em> Fie <span class="math inline">\(M\)</span> un <span
class="math inline">\(R\)</span>-modul quasi-injectiv ÅŸi <span
class="math inline">\(N\)</span> un submodul al sÄƒu. Atunci existÄƒ <span
class="math inline">\(E_2 \leq E(M)\)</span> astfel Ã®ncÃ¢t <span
class="math inline">\(E(M) = E_1 \oplus E_2\)</span>, unde <span
class="math inline">\(E_1 = E(N)\)</span>. Fie <span
class="math inline">\(\pi_i : E(M) \to E_i\)</span>, <span
class="math inline">\(i = 1,2\)</span>, proiecÅ£iile canonice. Cum <span
class="math inline">\(\pi_i(M) \leq M\)</span>, pentru orice <span
class="math inline">\(i = 1,2\)</span> (corolarulÂ 2.2.7), rezultÄƒ cÄƒ
<span class="math display">\[M = (M \cap E_1) \oplus (M \cap
E_2).\]</span> Evident, <span class="math inline">\(N \trianglelefteq(M
\cap E_1)\)</span> ÅŸi deci <span class="math inline">\(N\)</span> este
esenÅ£ial Ã®ntr-un sumand direct al lui <span
class="math inline">\(M\)</span>. Din propoziÅ£ia de mai sus rezultÄƒ cÄƒ
<span class="math inline">\(M\)</span> este CS-modul.Â â—»</p>
</div>
<div class="lemma">
<p><strong>LemÄƒ 6.5</strong>. <em>Fie <span
class="math inline">\(X\)</span> un CS-modul ciclic cu proprietatea cÄƒ
<span class="math inline">\(S = \mathop{\mathrm{soc}}(X) \trianglelefteq
X_R\)</span>, <span class="math inline">\(S\)</span> nu este finit
generat, dar orice submodul finit generat al lui <span
class="math inline">\(S\)</span> este sumand direct al lui <span
class="math inline">\(X\)</span>. DacÄƒ orice submodul ciclic al lui
<span class="math inline">\(X\)</span> este CS-modul, atunci <span
class="math inline">\(X/S\)</span> nu este CS-modul.</em></p>
</div>
<div class="proof">
<p><em>Proof.</em> Presupunem cÄƒ <span
class="math inline">\(X/S\)</span> este CS-modul. Cum <span
class="math inline">\(S\)</span> nu este finit generat, putem scrie
<span class="math display">\[S = \bigoplus_{i \geq 1} S_i,\]</span> cu
<span class="math inline">\(S_i \leq X\)</span> ÅŸi <span
class="math inline">\(S_i\)</span> ne-finit generat pentru orice <span
class="math inline">\(i \geq 1\)</span>.</p>
<p>Pentru orice <span class="math inline">\(i \geq 1\)</span> existÄƒ un
submodul complement <span class="math inline">\(D_i\)</span> al lui
<span class="math inline">\(X\)</span> astfel Ã®ncÃ¢t <span
class="math inline">\(S_i \trianglelefteq D_i\)</span>. Atunci <span
class="math inline">\(D_i\)</span> este sumand direct Ã®n <span
class="math inline">\(X\)</span> ÅŸi deci <span
class="math inline">\(D_i\)</span> este ciclic pentru orice <span
class="math inline">\(i \geq 1\)</span>; de unde <span
class="math inline">\(S_i \subsetneq D_i\)</span>.</p>
<p>Cum <span class="math inline">\(X/S\)</span> este CS-modul, existÄƒ
<span class="math inline">\(\overline{E}\)</span> un sumand direct Ã®n
<span class="math inline">\(X\)</span> astfel Ã®ncÃ¢t <span
class="math display">\[\sum_{i \geq 1} \frac{D_i + S}{S}
  = \frac{D}{S} \trianglelefteq\overline{E},\]</span> unde <span
class="math inline">\(D := \bigoplus_{i \geq 1} D_i\)</span>. Fie <span
class="math inline">\(E\)</span> un submodul ciclic al lui <span
class="math inline">\(X\)</span> astfel Ã®ncÃ¢t <span
class="math inline">\(\overline{E} = (E + S)/S\)</span>. ObÅ£inem cÄƒ
<span class="math display">\[\frac{D}{S} \trianglelefteq\frac{E +
S}{S}.\]</span></p>
<p>Cum <span class="math inline">\(E \cap S \leq S\)</span> ÅŸi <span
class="math inline">\(S\)</span> este semisimplu, existÄƒ <span
class="math inline">\(T \leq S\)</span> astfel Ã®ncÃ¢t <span
class="math display">\[S = (E \cap S) \oplus T\]</span> ÅŸi deci <span
class="math display">\[E + S = (E \cap S) \oplus T.\]</span></p>
<p>Presupunem cÄƒ existÄƒ <span class="math inline">\(i \geq 1\)</span>
astfel Ã®ncÃ¢t <span class="math inline">\(D_i \cap E = 0\)</span>.
ConsiderÃ¢nd proiecÅ£ia canonicÄƒ <span class="math inline">\(\pi : E
\oplus T \to T\)</span> avem cÄƒ <span class="math inline">\(D_i \cap
\ker \pi = 0\)</span>, ceea ce aratÄƒ cÄƒ <span
class="math inline">\(\pi_{\mid D_i}\)</span> este monomorfism ÅŸi deci
<span class="math inline">\(D_i\)</span> este semisimplu. Dar <span
class="math inline">\(S_i \trianglelefteq D_i\)</span>, ceea ce implicÄƒ
<span class="math inline">\(S_i = D_i\)</span>, contradicÅ£ie. RezultÄƒ cÄƒ
<span class="math inline">\(D_i \cap E \neq 0\)</span> pentru orice
<span class="math inline">\(i \geq 1\)</span> ÅŸi deci <span
class="math inline">\(S_i \cap E \neq 0\)</span> pentru orice <span
class="math inline">\(i \geq 1\)</span>.</p>
<p>Cum <span class="math inline">\(S \trianglelefteq X_R\)</span>,
existÄƒ <span class="math inline">\(V_i\)</span> simplu astfel Ã®ncÃ¢t
<span class="math inline">\(V_i \leq S_i \cap E\)</span> pentru orice
<span class="math inline">\(i \geq 1\)</span>. Fie <span
class="math inline">\(V := \bigoplus_{i \geq 1} V_i\)</span>. Modulul
<span class="math inline">\(E\)</span> este CS-modul deoarece <span
class="math inline">\(E\)</span> este ciclic. ExistÄƒ un sumand direct
<span class="math inline">\(L\)</span> al lui <span
class="math inline">\(X\)</span> astfel Ã®ncÃ¢t <span
class="math inline">\(V \trianglelefteq L\)</span>. ObservÄƒm cÄƒ <span
class="math inline">\(L\)</span> este ciclic ÅŸi deci <span
class="math inline">\(V \subsetneq L\)</span>. Fie <span
class="math inline">\(n \geq 1\)</span> ÅŸi notÄƒm <span
class="math display">\[P_n := \left( \bigoplus_{i=1}^n D_i \right) \cap
L.\]</span> Avem <span class="math display">\[P_n \cap S
  = L \cap \left( \bigoplus_{i=1}^n S_i \right)
  = V \cap \left( \bigoplus_{i=1}^n S_i \right)
  = \bigoplus_{i=1}^n V_i,\]</span> ÅŸi deci <span
class="math inline">\(P_n \cap S\)</span> este submodul finit generat al
lui <span class="math inline">\(S\)</span>.</p>
<p>RezultÄƒ cÄƒ <span class="math inline">\(P_n \cap S\)</span> este
sumand direct al lui <span class="math inline">\(X\)</span>. Dar <span
class="math inline">\(S \trianglelefteq X_R\)</span> ÅŸi deci <span
class="math display">\[P_n := \left(\bigoplus_{i=1}^n D_i\right) \cap L
\leq S
\quad \text{pentru orice } n \geq 1,\]</span> ceea ce aratÄƒ cÄƒ <span
class="math inline">\(D \cap L \leq S\)</span>.</p>
<p>Atunci, folosind legea distributivitÄƒÅ£ii modulare, avem <span
class="math display">\[\frac{D}{S} \cap \frac{L+S}{S}
   = \frac{D \cap (L+S)}{S}
   = \frac{S + D \cap L}{S}
   = 0.\]</span> Cum <span class="math inline">\(\dfrac{D}{S}
\trianglelefteq\dfrac{E+S}{S}\)</span>, rezultÄƒ cÄƒ <span
class="math inline">\(L+S = S\)</span>, adicÄƒ <span
class="math inline">\(L \leq S\)</span>. ObÅ£inem cÄƒ <span
class="math inline">\(L\)</span> este semisimplu ÅŸi, cum <span
class="math inline">\(V \trianglelefteq L\)</span>, rezultÄƒ <span
class="math inline">\(V = L\)</span>, contradicÅ£ie. Deci <span
class="math inline">\(X/S\)</span> nu este CS-modul.Â â—»</p>
</div>
<div id="thm:Osofsky-Smith" class="theorem">
<p><strong>TeoremÄƒ 6.6</strong> (Teorema Osofskyâ€“Smith). <em>Fie <span
class="math inline">\(R\)</span> un inel ÅŸi <span
class="math inline">\(M\)</span> un <span
class="math inline">\(R\)</span>-modul ciclic astfel Ã®ncÃ¢t <span
class="math inline">\(mR\)</span> este complet CS pentru orice <span
class="math inline">\(m \in M\)</span>. Atunci <span
class="math inline">\(M\)</span> este o sumÄƒ directÄƒ finitÄƒ de module
coireductibile.</em></p>
</div>
<div class="proof">
<p><em>Demonstratie.</em> Orice CS-modul indecompozabil este
coireductibil ÅŸi deci este suficient sÄƒ arÄƒtÄƒm cÄƒ <span
class="math inline">\(M\)</span> este o sumÄƒ directÄƒ finitÄƒ de module
indecompozabile.</p>
<p>Presupunem cÄƒ <span class="math inline">\(M\)</span> nu admite o
astfel de scriere. Atunci existÄƒ <span class="math display">\[M = A_1
\oplus B_1,
\quad
0 \neq A_1, B_1 \leq M,\]</span> unde <span
class="math inline">\(B_1\)</span> nu este o sumÄƒ directÄƒ de module
indecompozabile. RezultÄƒ cÄƒ putem scrie <span class="math display">\[B_1
= A_2 \oplus B_2,
\quad
0 \neq A_2, B_2 \leq B_1,\]</span> unde <span
class="math inline">\(B_2\)</span> nu este sumÄƒ directÄƒ de module
indecompozabile.</p>
<p>RepetÃ¢nd procedeul, obÅ£inem <span class="math display">\[0 \neq A_i,
B_i \leq M \quad (i \geq 1)\]</span> cu <span class="math display">\[M =
A_1 \oplus \cdots \oplus A_n \oplus B_n
\quad (n \geq 1)\]</span> ÅŸi <span class="math display">\[A_{n+1} \oplus
A_{n+2} \oplus \cdots \leq B_n
\quad (n \geq 1).\]</span></p>
<p>Cum fiecare <span class="math inline">\(A_i\)</span> este ciclic,
alegem pentru fiecare <span class="math inline">\(i \geq 1\)</span> un
submodul maximal <span class="math inline">\(C_i \leq A_i\)</span>.
NotÄƒm <span class="math display">\[C := \bigoplus_{i \geq 1} C_i,
\qquad
P := M/C,
\qquad
S := \bigoplus_{i \geq 1} \frac{A_i}{C_i}.\]</span> Atunci <span
class="math inline">\(S\)</span> este un submodul semisimplu, numÄƒrabil
generat, al lui <span class="math inline">\(P\)</span>.</p>
<p>Pentru orice <span class="math inline">\(n \geq 1\)</span>, aplicÃ¢nd
legea distributivitÄƒÅ£ii modulare, avem <span class="math display">\[(A_1
\oplus \cdots \oplus A_n \oplus C)
  \cap (B_n + C)
= C + (A_1 \oplus \cdots \oplus A_n) \cap B_n
= C + \bigoplus_{k \geq n+1} C_k
= C.\]</span> Prin urmare <span class="math display">\[P = \frac{M}{C}
  = \frac{A_1 \oplus \cdots \oplus A_n \oplus C}{C}
    \oplus \frac{B_n + C}{C}
  \quad \text{pentru orice } n \geq 1.\]</span></p>
<p>DacÄƒ <span class="math inline">\(T \leq S\)</span> este un submodul
finit generat, existÄƒ un <span class="math inline">\(n \geq 1\)</span>
astfel Ã®ncÃ¢t <span class="math display">\[T = \frac{A_1 \oplus \cdots
\oplus A_n + C}{C},\]</span> de unde rezultÄƒ cÄƒ orice submodul finit
generat al lui <span class="math inline">\(S\)</span> este sumand direct
al lui <span class="math inline">\(P\)</span>.</p>
<p>Fie acum <span class="math inline">\(X\)</span> un submodul al lui
<span class="math inline">\(P\)</span> astfel Ã®ncÃ¢t <span
class="math inline">\(S \trianglelefteq X \leq P\)</span>, <span
class="math inline">\(X\)</span> este CS-modul ÅŸi orice submodul finit
generat al lui <span class="math inline">\(S\)</span> este sumand direct
Ã®n <span class="math inline">\(X\)</span>. DacÄƒ <span
class="math inline">\(\operatorname{soc}(X)\)</span> este soclul lui
<span class="math inline">\(X\)</span>, atunci <span
class="math inline">\(S \trianglelefteq\operatorname{soc}(X)\)</span>
ÅŸi, cum <span class="math inline">\(S \trianglelefteq X\)</span>,
obÅ£inem <span class="math inline">\(S =
\operatorname{soc}(X)\)</span>.</p>
<p>RezultÄƒ cÄƒ sunt satisfÄƒcute ipotezele lemei precedente ÅŸi deci <span
class="math inline">\(X/S\)</span> nu este CS-modul, contradicÅ£ie.Â â—»</p>
</div>
<div class="corollary">
<p><strong>Corolar 6.7</strong>. <em>Fie <span
class="math inline">\(R\)</span> un inel astfel Ã®ncÃ¢t orice <span
class="math inline">\(R\)</span>-modul ciclic este CS-modul. Atunci
orice <span class="math inline">\(R\)</span>-modul ciclic este o sumÄƒ
directÄƒ finitÄƒ de module coireductibile.</em></p>
</div>
<div class="proof">
<p><em>Demonstratie.</em> Fie <span class="math inline">\(M_R\)</span>
un modul ciclic, <span class="math inline">\(m \in M\)</span> ÅŸi <span
class="math inline">\(N \leq mR\)</span>. Atunci factorul <span
class="math inline">\(mR/N\)</span> este un modul ciclic ÅŸi, prin
ipotezÄƒ, un CS-modul. AplicÃ¢nd Teorema Osofskyâ€“Smith obÅ£inem cÄƒ <span
class="math inline">\(mR\)</span> (ÅŸi deci <span
class="math inline">\(M\)</span>) este o sumÄƒ directÄƒ finitÄƒ de module
coireductibile.Â â—»</p>
</div>
<div class="corollary">
<p><strong>Corolar 6.8</strong> (Corolar 5.8). <em>DacÄƒ <span
class="math inline">\(N\)</span> este un <span
class="math inline">\(R\)</span>-modul astfel Ã®ncÃ¢t orice modul factor
al oricÄƒrui submodul ciclic al lui <span
class="math inline">\(N\)</span> este injectiv, atunci <span
class="math inline">\(N\)</span> este semisimplu.</em></p>
</div>
<div class="proof">
<p><em>Demonstratie.</em> Fie <span class="math inline">\(0 \neq x \in
N\)</span> ÅŸi <span class="math inline">\(C = xR \leq N\)</span>. Prin
ipotezÄƒ, orice modul factor al unui submodul ciclic al lui <span
class="math inline">\(C\)</span> este injectiv, deci orice submodul
ciclic al lui <span class="math inline">\(C\)</span> este complet CS.
Din Teorema Osofskyâ€“Smith rezultÄƒ cÄƒ <span class="math display">\[C = xR
= \bigoplus_{i=1}^n U_i\]</span> pentru anumite submodule coireductibile
<span class="math inline">\(U_i\)</span>.</p>
<p>Cum <span class="math display">\[U_i \cong C \big/ \bigoplus_{j \neq
i} U_j,\]</span> rezultÄƒ cÄƒ fiecare <span
class="math inline">\(U_i\)</span> este injectiv ÅŸi, prin urmare, <span
class="math inline">\(U_i\)</span> este indecompozabil pentru tot <span
class="math inline">\(i = 1,\dots,n\)</span> (vezi
propoziÅ£iaÂ 3.1).Â â—»</p>
</div>
  <script>
    if ("serviceWorker" in navigator) {
      navigator.serviceWorker.register("/sw.js?v=1763893170").then(registration => {
        console.log("Service Worker registered:", registration);
      }).catch(error => {
        console.log("Service Worker registration failed:", error);
      });
    }
  </script>
</body>
</html>
